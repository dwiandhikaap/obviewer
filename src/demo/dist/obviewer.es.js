var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const import_meta = {};
const DEFAULT_COLOURS = [
  [141, 174, 240],
  [115, 129, 241],
  [214, 214, 214],
  [160, 160, 160]
];
class Colours {
  constructor() {
    this.combo = [];
  }
  parseStringArray(colourStringArray) {
    for (let colourString of colourStringArray) {
      if (colourString.includes("SliderTrackOverride")) {
        this.sliderTrackOverride = colourString.replace(/.+: */g, "").split(",").map(Number);
      } else if (colourString.includes("SliderBorder")) {
        this.sliderBorder = colourString.replace(/.+: */g, "").split(",").map(Number);
      } else {
        this.combo.push(colourString.replace(/.+: */g, "").split(",").map(Number));
      }
    }
    if (this.combo.length === 0) {
      this.combo = DEFAULT_COLOURS;
    }
  }
  get hex() {
    return this.combo.map((colour) => `#${colour.map((c) => c.toString(16).padStart(2, "0")).join("")}`);
  }
}
var Mod = /* @__PURE__ */ ((Mod2) => {
  Mod2[Mod2["None"] = 0] = "None";
  Mod2[Mod2["NoFail"] = 1] = "NoFail";
  Mod2[Mod2["Easy"] = 2] = "Easy";
  Mod2[Mod2["TouchDevice"] = 4] = "TouchDevice";
  Mod2[Mod2["Hidden"] = 8] = "Hidden";
  Mod2[Mod2["HardRock"] = 16] = "HardRock";
  Mod2[Mod2["SuddenDeath"] = 32] = "SuddenDeath";
  Mod2[Mod2["DoubleTime"] = 64] = "DoubleTime";
  Mod2[Mod2["Relax"] = 128] = "Relax";
  Mod2[Mod2["HalfTime"] = 256] = "HalfTime";
  Mod2[Mod2["Nightcore"] = 512] = "Nightcore";
  Mod2[Mod2["Flashlight"] = 1024] = "Flashlight";
  Mod2[Mod2["Autoplay"] = 2048] = "Autoplay";
  Mod2[Mod2["SpunOut"] = 4096] = "SpunOut";
  Mod2[Mod2["Relax2"] = 8192] = "Relax2";
  Mod2[Mod2["Perfect"] = 16384] = "Perfect";
  Mod2[Mod2["TargetPractice"] = 8388608] = "TargetPractice";
  Mod2[Mod2["ScoreV2"] = 536870912] = "ScoreV2";
  return Mod2;
})(Mod || {});
class Mods {
  constructor(value = 0) {
    this.constrain = true;
    this._list = new Array();
    this.numeric = value;
  }
  get reducedListString() {
    let reducedMods = reduceCombinedMods(this._list);
    return reducedMods.map((mod) => Mod[mod]);
  }
  get listString() {
    return this._list.map((mod) => Mod[mod]);
  }
  get reducedList() {
    return reduceCombinedMods(this._list);
  }
  get list() {
    return this._list;
  }
  get numeric() {
    return this._numeric;
  }
  set numeric(value) {
    if (value <= 0) {
      this._numeric = 0;
      this._list = [0];
      return;
    }
    let result = new Array();
    let sum = 0;
    value.toString(2).split("").map(Number).reverse().forEach((currentValue, index2) => {
      if (currentValue === 1) {
        result.push(currentValue << index2);
        sum += currentValue << index2;
      }
    });
    this._numeric = sum;
    this._list = result.reverse();
  }
  contains(arg) {
    if (arg instanceof Array) {
      let result = true;
      for (const mod of arg) {
        if ((mod & this._numeric) !== mod) {
          result = false;
          break;
        }
      }
      return result;
    }
    return (arg & this._numeric) === arg;
  }
  set(mod, enable) {
    if (enable) {
      return this.enable(mod);
    } else {
      return this.disable(mod);
    }
  }
  _enable(...mods) {
    mods.forEach((mod) => this.numeric |= mod);
  }
  _disable(...mods) {
    mods.forEach((mod) => this.numeric ^= this.numeric & mod);
  }
  enable(mod) {
    if (!this.constrain) {
      this._enable(mod);
      return;
    }
    if ([64, 512, 256].includes(mod)) {
      this._disable(64, 512, 256);
    }
    if ([2, 16].includes(mod)) {
      this._disable(2, 16);
    }
    if ([1, 128, 8192, 32, 16384].includes(mod)) {
      this._disable(1, 128, 8192, 32, 16384);
      this._disable(2048);
    }
    if ([4096, 8192].includes(mod)) {
      this._disable(4096, 8192);
    }
    if ([2048].includes(mod)) {
      this._disable(1, 128, 8192, 32, 16384);
    }
    if (mod === 512) {
      this._enable(64);
    }
    if (mod === 16384) {
      this._enable(32);
    }
    this._enable(mod);
    return this;
  }
  disable(mod) {
    if (!this.constrain) {
      this._disable(mod);
      return;
    }
    if (mod === 64) {
      this._disable(512);
    }
    if (mod === 512 && this.contains(512)) {
      this._disable(64);
    }
    if (mod === 32) {
      this._disable(16384);
    }
    if (mod === 16384 && this.contains(16384)) {
      this._disable(32);
    }
    this._disable(mod);
    return this;
  }
  hasSimilar(mod) {
    return (this.numeric & mod) === mod;
  }
}
function reduceCombinedMods(list) {
  const result = [...list];
  if (result.includes(512)) {
    const index2 = result.indexOf(64);
    if (index2 !== -1) {
      result.splice(index2, 1);
    }
  }
  if (result.includes(16384)) {
    const index2 = result.indexOf(32);
    if (index2 !== -1) {
      result.splice(index2, 1);
    }
  }
  return result;
}
const PREEMPT_MIN = 450;
const TIME_PREEMPT = 600;
const TIME_FADEIN = 400;
class Difficulty {
  constructor() {
    this.hp = 5;
    this.cs = 5;
    this.od = 5;
    this.ar = 5;
    this.sliderMultiplier = 1.4;
    this.sliderTickRate = 1;
  }
  parseStringArray(args, mods) {
    const [hp, cs, od, ar, sliderMultiplier, sliderTickRate] = args.map((row) => row.replace(/.+: */g, ""));
    this.hp = parseFloat(hp);
    this.cs = parseFloat(cs);
    this.od = parseFloat(od);
    this.ar = parseFloat(ar);
    this.sliderMultiplier = parseFloat(sliderMultiplier);
    this.sliderTickRate = parseFloat(sliderTickRate);
    this.mods = mods != null ? mods : new Mods();
  }
  get fadeIn() {
    return TIME_FADEIN * Math.min(1, TIME_PREEMPT / PREEMPT_MIN);
  }
  getPreempt(mods = this.mods) {
    let ar = this.getAR(mods);
    return difficultyRange(ar, 1800, 1200, PREEMPT_MIN);
  }
  getAR(mods = this.mods) {
    if (mods.contains(Mod.Easy)) {
      return this.ar / 2;
    }
    if (mods.contains(Mod.HardRock)) {
      return Math.min(this.ar * 1.4, 10);
    } else {
      return this.ar;
    }
  }
  getOD(mods = this.mods) {
    if (mods.contains(Mod.Easy)) {
      return this.od / 2;
    }
    if (mods.contains(Mod.HardRock)) {
      return Math.min(this.od * 1.4, 10);
    } else {
      return this.od;
    }
  }
  getCS(mods = this.mods) {
    if (mods.contains(Mod.Easy)) {
      return this.cs / 2;
    }
    if (mods.contains(Mod.HardRock)) {
      return Math.min(this.cs * 1.3, 10);
    } else {
      return this.cs;
    }
  }
  getHP(mods = this.mods) {
    if (mods.contains(Mod.Easy)) {
      return this.hp / 2;
    }
    if (mods.contains(Mod.HardRock)) {
      return Math.min(this.hp * 1.4, 10);
    } else {
      return this.hp;
    }
  }
  getObjectRadius(mods = this.mods) {
    const cs = this.getCS(mods);
    const r = difficultyRange(cs, 54.4, 32, 9.6);
    return r;
  }
  getHitWindows(mods = this.mods) {
    const hit300 = 79 - this.getOD(mods) * 6 + 0.5;
    const hit100 = 139 - this.getOD(mods) * 8 + 0.5;
    const hit50 = 199 - this.getOD(mods) * 10 + 0.5;
    return [hit300, hit100, hit50];
  }
}
function difficultyRange(difficulty, min, mid, max) {
  if (difficulty > 5)
    return mid + (max - mid) * (difficulty - 5) / 5;
  if (difficulty < 5)
    return mid - (mid - min) * (5 - difficulty) / 5;
  return mid;
}
class Editor {
  parseStringArray(args) {
    const [bookmarks, distanceSpacing, beatDivisor, gridSize, timelineZoom] = args.map((row) => row.replace(/.+: */g, ""));
    this.bookmarks = bookmarks.split(",").map(Number);
    this.distanceSpacing = parseFloat(distanceSpacing);
    this.beatDivisor = parseInt(beatDivisor);
    this.gridSize = parseInt(gridSize);
    this.timelineZoom = parseFloat(timelineZoom);
  }
}
class BackgroundEvent {
  constructor(startTime, eventParams) {
    this.eventType = "background";
    const [filename, xOffset, yOffset] = eventParams;
    this.startTime = startTime;
    this.filename = filename.replace(/^"(.*)"$/, "$1");
    this.xOffset = parseInt(xOffset);
    this.yOffset = parseInt(yOffset);
  }
}
class VideoEvent {
  constructor(startTime, eventParams) {
    this.eventType = "video";
    const [filename, xOffset, yOffset] = eventParams;
    this.startTime = startTime;
    this.filename = filename.replace(/^"(.*)"$/, "$1");
    this.xOffset = parseInt(xOffset);
    this.yOffset = parseInt(yOffset);
  }
}
class BreakEvent {
  constructor(startTime, eventParams) {
    this.eventType = "break";
    this.startTime = startTime;
    this.endTime = parseInt(eventParams[0]);
  }
}
class Events {
  constructor() {
    this.events = [];
  }
  parseStringArray(eventStringArray) {
    this.events = eventStringArray.map((eventString) => {
      const [eventType, startTime, ...eventParams] = eventString.split(",");
      switch (eventType.toLowerCase()) {
        case "0": {
          return new BackgroundEvent(+startTime, eventParams);
        }
        case "video":
        case "1": {
          return new VideoEvent(+startTime, eventParams);
        }
        case "2": {
          return new BreakEvent(+startTime, eventParams);
        }
      }
    }).filter((event) => event !== void 0);
  }
}
class General {
  parseStringArray(args) {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    function findValueByKey(key) {
      const rowFound = args.find((row) => row.split(":")[0].toLowerCase() === key.toLowerCase());
      if (rowFound) {
        return rowFound.replace(/.+: */g, "");
      } else {
        return null;
      }
    }
    this.audioFilename = (_a2 = findValueByKey("audioFilename")) != null ? _a2 : "";
    this.audioLeadIn = parseInt((_b2 = findValueByKey("audioLeadIn")) != null ? _b2 : "0");
    this.previewTime = parseInt((_c2 = findValueByKey("previewTime")) != null ? _c2 : "-1");
    this.countdown = parseInt((_d = findValueByKey("countdown")) != null ? _d : "1");
    this.sampleSet = (_e = findValueByKey("sampleSet")) != null ? _e : "Normal";
    this.stackLeniency = parseFloat((_f = findValueByKey("stackLeniency")) != null ? _f : "0.7");
    this.mode = parseInt((_g = findValueByKey("mode")) != null ? _g : "0");
    this.letterboxInBreaks = parseInt((_h = findValueByKey("letterboxInBreaks")) != null ? _h : "0");
    this.widescreenStoryboard = parseInt((_i = findValueByKey("widescreenStoryboard")) != null ? _i : "0");
    this.useSkinSprites = parseInt((_j = findValueByKey("useSkinSprites")) != null ? _j : "0");
    this.overlayPosition = (_k = findValueByKey("overlayPosition")) != null ? _k : "NoChange";
    this.skinPreference = (_l = findValueByKey("skinPreference")) != null ? _l : "";
    this.epilepsyWarning = parseInt((_m = findValueByKey("epilepsyWarning")) != null ? _m : "0");
    this.countdownOffset = parseInt((_n = findValueByKey("countdownOffset")) != null ? _n : "0");
    this.sampleMatchPlaybackRate = parseInt((_o = findValueByKey("sampleMatchPlaybackRate")) != null ? _o : "0");
  }
}
class MathHelper {
  static BinomialCoefficient(n, k) {
    return this.Factorial(n) / (this.Factorial(k) * this.Factorial(n - k));
  }
  static Factorial(n) {
    return n < 2 ? 1 : n * this.Factorial(n - 1);
  }
  static Clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }
  static Lerp(t, from, to, targetFrom, targetTo) {
    return t / (to - from) * (targetTo - targetFrom) + targetFrom;
  }
  static Sum(numbers) {
    let result = 0;
    for (let i = 0; i < numbers.length; i++) {
      result += numbers[i];
    }
    return result;
  }
  static Average(numbers) {
    return numbers.length === 0 ? 0 : this.Sum(numbers) / numbers.length;
  }
  static InsideCircle(center, point, radius) {
    const dx = point[0] - center[0];
    const dy = point[1] - center[1];
    return dx * dx + dy * dy <= radius * radius;
  }
}
class Vector2 {
  constructor(x, y) {
    this.add = (valueOrVector) => {
      if (typeof valueOrVector === "number") {
        return new Vector2(this[0] + valueOrVector, this[1] + valueOrVector);
      }
      return new Vector2(this[0] + valueOrVector[0], this[1] + valueOrVector[1]);
    };
    this.subtract = (valueOrVector) => {
      if (typeof valueOrVector === "number") {
        return new Vector2(this[0] - valueOrVector, this[1] - valueOrVector);
      }
      return new Vector2(this[0] - valueOrVector[0], this[1] - valueOrVector[1]);
    };
    this.multiply = (scalar) => {
      return new Vector2(this[0] * scalar, this[1] * scalar);
    };
    if (typeof x === "number" && y !== void 0) {
      this[0] = x;
      this[1] = y;
    } else if (x instanceof Array) {
      this[0] = x[0];
      this[1] = x[1];
    }
  }
  lengthSquared() {
    return Math.pow(this[0], 2) + Math.pow(this[1], 2);
  }
  length() {
    return Math.sqrt(this.lengthSquared());
  }
  dot(vector) {
    return Math.min(this[0] * vector[0] + this[1] * vector[1], 1);
  }
  normalize() {
    return new Vector2([this[0] / this.length(), this[1] / this.length()]);
  }
  toArray() {
    return [this[0], this[1]];
  }
  toTuple() {
    return [this[0], this[1]];
  }
  rotate(angle) {
    return new Vector2(this[0] * Math.cos(angle) - this[1] * Math.sin(angle), this[0] * Math.sin(angle) + this[1] * Math.cos(angle));
  }
  clone() {
    return new Vector2(this[0], this[1]);
  }
  static From(numberOrArray, y) {
    if (numberOrArray instanceof Array) {
      return new Vector2(numberOrArray[0], numberOrArray[1]);
    }
    return new Vector2(numberOrArray, y);
  }
  static ToArray(vector) {
    return [vector[0], vector[1]];
  }
  static Normalize(vector) {
    return new Vector2(vector[0] / Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2)), vector[1] / Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2)));
  }
  static PerpendicularRight(vector) {
    return new Vector2(-vector[1], vector[0]);
  }
  static PerpendicularLeft(vector) {
    return new Vector2(vector[1], -vector[0]);
  }
  static Add(vector1, vector2OrValue) {
    if (typeof vector2OrValue === "number") {
      return new Vector2(vector1[0] + vector2OrValue, vector1[1] + vector2OrValue);
    }
    return new Vector2(vector1[0] + vector2OrValue[0], vector1[1] + vector2OrValue[1]);
  }
  static Subtract(vector1, vector2OrValue) {
    if (typeof vector2OrValue === "number") {
      return new Vector2(vector1[0] - vector2OrValue, vector1[1] - vector2OrValue);
    }
    return new Vector2(vector1[0] - vector2OrValue[0], vector1[1] - vector2OrValue[1]);
  }
  static Multiply(vector, scalar) {
    return new Vector2(vector[0] * scalar, vector[1] * scalar);
  }
  static DistanceSquared(vector1, vector2) {
    return Math.pow(vector1[0] - vector2[0], 2) + Math.pow(vector1[1] - vector2[1], 2);
  }
  static Distance(vector1, vector2) {
    return Math.sqrt(this.DistanceSquared(vector1, vector2));
  }
  static LengthSquared(vector) {
    return Math.pow(vector[0], 2) + Math.pow(vector[1], 2);
  }
  static Length(vector) {
    return Math.sqrt(this.LengthSquared(vector));
  }
  static Midpoint(vector1, vector2) {
    return new Vector2((vector1[0] + vector2[0]) / 2, (vector1[1] + vector2[1]) / 2);
  }
  static Dot(vector1, vector2) {
    return Math.min(vector1[0] * vector2[0] + vector1[1] * vector2[1], 1);
  }
  static Equals(vector1, vector2) {
    return vector1[0] === vector2[0] && vector1[1] === vector2[1];
  }
  static LinearInterpolation(vector1, vector2, t) {
    return new Vector2(vector1[0] + (vector2[0] - vector1[0]) * t, vector1[1] + (vector2[1] - vector1[1]) * t);
  }
  static CloseEnough(vector1, vector2, epsilon) {
    return Math.abs(vector1[0] - vector2[0]) < epsilon && Math.abs(vector1[1] - vector2[1]) < epsilon;
  }
  static Angle(from, to) {
    return Math.atan2(to[1] - from[1], to[0] - from[0]);
  }
}
class CircularArcProperties {
  get thetaEnd() {
    return this.thetaStart + this.thetaRange * this.direction;
  }
  constructor(thetaStart, thetaRange, direction, radius, center) {
    this.isValid = true;
    this.thetaStart = thetaStart;
    this.thetaRange = thetaRange;
    this.direction = direction;
    this.radius = radius;
    this.center = center;
  }
}
class PathApproximator {
  static ApproximateLinear(controlPoints) {
    return controlPoints.map((point) => point.clone());
  }
  static ApproximateBezier(controlPoints) {
    const output = new Array();
    let n = controlPoints.length - 1;
    if (n < 0) {
      return output;
    }
    const toFlatten = new Array();
    const freeBuffers = new Array();
    let subdivisionBuffer1 = new Array();
    let subdivisionBuffer2 = new Array();
    let leftChild = subdivisionBuffer2;
    toFlatten.push([...controlPoints]);
    while (toFlatten.length > 0) {
      let parent = toFlatten.pop();
      if (this.bezierIsFlatEnough(parent)) {
        this.bezierApproximate(parent, output, subdivisionBuffer1, subdivisionBuffer2, n + 1);
        freeBuffers.push(parent);
        continue;
      }
      let rightChild = freeBuffers.length > 0 ? freeBuffers.pop() : new Array();
      this.bezierSubdivide(parent, leftChild, rightChild, subdivisionBuffer1, n + 1);
      for (let i = 0; i < n + 1; i++) {
        parent[i] = leftChild[i];
      }
      toFlatten.push(rightChild);
      toFlatten.push(parent);
    }
    output.push(controlPoints[n]);
    return output;
  }
  static ApproximateCatmull(controlPoints) {
    let result = new Array();
    for (let i = 0; i < controlPoints.length - 1; i++) {
      let v1 = i > 0 ? controlPoints[i - 1] : controlPoints[i];
      let v2 = controlPoints[i];
      let v3 = i < controlPoints.length - 1 ? controlPoints[i + 1] : v2.add(v2).subtract(v1);
      let v4 = i < controlPoints.length - 2 ? controlPoints[i + 2] : v3.add(v3).subtract(v2);
      for (let c = 0; c < this.CATMULL_DETAIL; c++) {
        result.push(this.catmullFindPoint(v1, v2, v3, v4, c / this.CATMULL_DETAIL));
        result.push(this.catmullFindPoint(v1, v2, v3, v4, (c + 1) / this.CATMULL_DETAIL));
      }
    }
    return result;
  }
  static ApproximateCircularArc(controlPoints) {
    const asd = [...controlPoints];
    let circularArcProperty = this.circularArcProperties(asd);
    if (!circularArcProperty.isValid) {
      return [...controlPoints];
    }
    const pr = circularArcProperty;
    const amountPoints = 2 * pr.radius <= this.CIRCULAR_ARC_TOLERANCE ? 2 : Math.max(2, Math.ceil(pr.thetaRange / (2 * Math.acos(1 - this.CIRCULAR_ARC_TOLERANCE / pr.radius))));
    const output = new Array();
    for (let i = 0; i < amountPoints; ++i) {
      const fract = i / (amountPoints - 1);
      const theta = pr.thetaStart + pr.direction * fract * pr.thetaRange;
      const o = new Vector2(Math.cos(theta), Math.sin(theta)).multiply(pr.radius);
      output.push(pr.center.add(o));
    }
    return output;
  }
  static bezierIsFlatEnough(controlPoints) {
    for (let i = 1; i < controlPoints.length - 1; i++) {
      const r = controlPoints[i - 1].subtract(controlPoints[i].multiply(2)).add(controlPoints[i + 1]);
      const lengthSquared = r.lengthSquared();
      if (lengthSquared > this.BEZIER_TOLERANCE * this.BEZIER_TOLERANCE * 4) {
        return false;
      }
    }
    return true;
  }
  static bezierSubdivide(controlPoints, l, r, subdivisionBuffer, count) {
    const midpoints = subdivisionBuffer;
    for (let i = 0; i < count; i++) {
      midpoints[i] = controlPoints[i];
    }
    for (let i = 0; i < count; i++) {
      l[i] = midpoints[0];
      r[count - i - 1] = midpoints[count - i - 1];
      for (let j = 0; j < count - i - 1; j++) {
        midpoints[j] = Vector2.Midpoint(midpoints[j], midpoints[j + 1]);
      }
    }
  }
  static bezierApproximate(controlPoints, output, subdivisionBuffer1, subdivisionBuffer2, count) {
    let l = subdivisionBuffer2;
    let r = subdivisionBuffer1;
    this.bezierSubdivide(controlPoints, l, r, subdivisionBuffer1, count);
    for (let i = 0; i < count - 1; i++) {
      l[count + i] = r[i + 1];
    }
    output.push(controlPoints[0].clone());
    for (let i = 1; i < count - 1; i++) {
      let index2 = 2 * i;
      const p = l[index2 - 1].add(l[index2].multiply(2)).add(l[index2 + 1]).multiply(0.25);
      output.push(p);
    }
  }
  static circularArcProperties(controlPoints) {
    const [a, b, c] = controlPoints;
    if (Math.abs((b[1] - a[1]) * (c[0] - a[0]) - (b[0] - a[0]) * (c[1] - a[1])) < this.EPSILON) {
      return { isValid: false };
    }
    const d = 2 * (a[0] * b.subtract(c)[1] + b[0] * c.subtract(a)[1] + c[0] * a.subtract(b)[1]);
    const aSq = a.lengthSquared();
    const bSq = b.lengthSquared();
    const cSq = c.lengthSquared();
    const center = new Vector2((aSq * (b[1] - c[1]) + bSq * (c[1] - a[1]) + cSq * (a[1] - b[1])) / d, (aSq * (c[0] - b[0]) + bSq * (a[0] - c[0]) + cSq * (b[0] - a[0])) / d);
    const dA = a.subtract(center);
    const dC = c.subtract(center);
    const radius = dA.length();
    let thetaStart = Math.atan2(dA[1], dA[0]);
    let thetaEnd = Math.atan2(dC[1], dC[0]);
    while (thetaEnd < thetaStart) {
      thetaEnd += 2 * Math.PI;
    }
    let dir = 1;
    let thetaRange = thetaEnd - thetaStart;
    const orthoAtoC = c.subtract(a).rotate(-Math.PI / 2);
    if (Vector2.Dot(orthoAtoC, b.subtract(a)) < 0) {
      dir = -dir;
      thetaRange = 2 * Math.PI - thetaRange;
    }
    return new CircularArcProperties(thetaStart, thetaRange, dir, radius, center);
  }
  static catmullFindPoint(vec1, vec2, vec3, vec4, t) {
    const t2 = t * t;
    const t3 = t2 * t;
    return new Vector2(0.5 * (2 * vec2[0] + (-vec1[0] + vec3[0]) * t + (2 * vec1[0] - 5 * vec2[0] + 4 * vec3[0] - vec4[0]) * t2 + (-vec1[0] + 3 * vec2[0] - 3 * vec3[0] + vec4[0]) * t3), 0.5 * (2 * vec2[1] + (-vec1[1] + vec3[1]) * t + (2 * vec1[1] - 5 * vec2[1] + 4 * vec3[1] - vec4[1]) * t2 + (-vec1[1] + 3 * vec2[1] - 3 * vec3[1] + vec4[1]) * t3));
  }
}
PathApproximator.BEZIER_TOLERANCE = 0.25;
PathApproximator.EPSILON = 1e-3;
PathApproximator.CIRCULAR_ARC_TOLERANCE = 0.25;
PathApproximator.CATMULL_DETAIL = 50;
class PathHelper {
  static CalculateLength(pathPoints) {
    let length = 0;
    for (let i = 0; i < pathPoints.length - 1; i++) {
      const current = pathPoints[i];
      const next = pathPoints[i + 1];
      length += Vector2.Distance(current, next);
    }
    return length;
  }
  static TrimPath(path, maxLength) {
    const result = new Array();
    if (path.length < 1) {
      return result;
    }
    result.push(path[0]);
    let length = 0;
    for (let i = 1; i < path.length; i++) {
      const prev = path[i - 1];
      const current = path[i];
      const distance = Vector2.Distance(prev, current);
      if (length + distance > maxLength) {
        const t = (maxLength - length) / distance;
        const interp = new Vector2(prev[0] * (1 - t) + current[0] * t, prev[1] * (1 - t) + current[1] * t);
        result.push(interp);
        break;
      }
      length += distance;
      result.push(path[i]);
    }
    return result;
  }
  static GetPointAt(pathPoints, time, interpolate = true) {
    time = MathHelper.Clamp(time, 0, 1);
    let result = null;
    const totalLength = PathHelper.CalculateLength(pathPoints);
    const expectedLength = totalLength * time;
    let length = 0;
    for (let i = 1; i < pathPoints.length; i++) {
      const current = pathPoints[i - 1];
      const next = pathPoints[i];
      const dist = Vector2.Distance(current, next);
      if (length + dist > expectedLength) {
        const t = (expectedLength - length) / dist;
        if (interpolate) {
          result = Vector2.LinearInterpolation(current, next, t);
        } else {
          result = current;
        }
        break;
      }
      length += dist;
    }
    if (!result) {
      result = pathPoints[pathPoints.length - 1];
    }
    return result;
  }
  static GetAngleAt(path, time) {
    time = MathHelper.Clamp(time, 0, 1);
    let currPointIndex = 0;
    const totalLength = PathHelper.CalculateLength(path);
    const expectedLength = totalLength * time;
    let length = 0;
    for (let i = 1; i < path.length; i++) {
      const current = path[i - 1];
      const next2 = path[i];
      const dist = Vector2.Distance(current, next2);
      if (length + dist > expectedLength) {
        currPointIndex = i - 1;
        break;
      }
      length += dist;
    }
    if (!currPointIndex) {
      currPointIndex = path.length - 1;
    }
    const curr = path[currPointIndex];
    const next = path[currPointIndex + 1];
    if (next) {
      return Vector2.Angle(curr, next);
    }
    const prev = path[currPointIndex - 1];
    if (prev) {
      return Vector2.Angle(prev, curr);
    }
    return 0;
  }
  static Interpolate(path, maxSegmentLength) {
    const result = new Array();
    if (path.length < 1) {
      return result;
    }
    result.push(path[0]);
    for (let i = 1; i < path.length; i++) {
      const prev = path[i - 1];
      const current = path[i];
      const distance = Vector2.Distance(prev, current);
      const divideCount = Math.floor(distance / maxSegmentLength);
      for (let j = 0; j < divideCount; j++) {
        const t = (j + 1) / (divideCount + 1);
        result.push(new Vector2(prev[0] * (1 - t) + current[0] * t, prev[1] * (1 - t) + current[1] * t));
      }
      result.push(path[i]);
    }
    return result;
  }
  static SplitControlPoints(controlPoints) {
    const pathsControlPoints = new Array();
    let startIndex = 0;
    for (let i = 1; i < controlPoints.length; i++) {
      const prev = controlPoints[i - 1];
      const current = controlPoints[i];
      if (Vector2.Equals(prev, current) || i === controlPoints.length - 1) {
        const newControlPoints = [];
        const endIndex = i === controlPoints.length - 1 ? i + 1 : i;
        for (let j = startIndex; j < endIndex; j++) {
          newControlPoints.push(controlPoints[j]);
        }
        pathsControlPoints.push(newControlPoints);
        startIndex = i;
      }
    }
    return pathsControlPoints;
  }
  static CombinePath(pathsControlPoints, pathType) {
    const result = [];
    for (let i = 0; i < pathsControlPoints.length; i++) {
      let path = new Array();
      const controlPoints = pathsControlPoints[i];
      switch (pathType) {
        case "B": {
          path = PathApproximator.ApproximateBezier(controlPoints);
          break;
        }
        case "P": {
          path = PathApproximator.ApproximateCircularArc(controlPoints);
          break;
        }
        case "C": {
          path = PathApproximator.ApproximateCatmull(controlPoints);
          break;
        }
        case "L":
        default: {
          path = PathApproximator.ApproximateLinear(controlPoints);
          break;
        }
      }
      const startIndex = i === 0 ? 0 : 1;
      for (let i2 = startIndex; i2 < path.length; i2++) {
        result.push(path[i2]);
      }
    }
    return result;
  }
  static RoundCoordinates(path) {
    const result = [];
    for (let i = 0; i < path.length; i++) {
      const vec = new Vector2(Math.round(path[i][0]), Math.round(path[i][1]));
      result.push(vec);
    }
    return result;
  }
  static Simplify(path, tolerance, highQuality) {
    if (path.length < 2) {
      return path;
    }
    const sqTolerance = tolerance * tolerance;
    path = highQuality ? path : this.simplifyRadialDist(path, sqTolerance);
    path = this.simplifyDouglasPeucker(path, sqTolerance);
    return path;
  }
  static simplifyRadialDist(path, sqTolerance) {
    let prevPoint = path[0];
    let newPoints = [prevPoint];
    let point = path[1];
    for (let i = 1, len = path.length; i < len; i++) {
      point = path[i];
      if (Vector2.DistanceSquared(point, prevPoint) > sqTolerance) {
        newPoints.push(point);
        prevPoint = point;
      }
    }
    if (prevPoint !== point) {
      newPoints.push(point);
    }
    return newPoints;
  }
  static simplifyDouglasPeucker(path, sqTolerance) {
    let last = path.length - 1;
    let simplified = [path[0]];
    this.simplifyDPStep(path, 0, last, sqTolerance, simplified);
    simplified.push(path[last]);
    return simplified;
  }
  static simplifyDPStep(path, first, last, sqTolerance, simplified) {
    let maxSqDist = sqTolerance;
    let index2 = 0;
    for (let i = first + 1; i < last; i++) {
      let sqDist = this.getSqSegDist(path[i], path[first], path[last]);
      if (sqDist > maxSqDist) {
        index2 = i;
        maxSqDist = sqDist;
      }
    }
    if (maxSqDist > sqTolerance) {
      if (index2 - first > 1) {
        this.simplifyDPStep(path, first, index2, sqTolerance, simplified);
      }
      simplified.push(path[index2]);
      if (last - index2 > 1) {
        this.simplifyDPStep(path, index2, last, sqTolerance, simplified);
      }
    }
  }
  static getSqSegDist(p, p1, p2) {
    var x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y;
    if (dx !== 0 || dy !== 0) {
      var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
      if (t > 1) {
        x = p2[0];
        y = p2[1];
      } else if (t > 0) {
        x += dx * t;
        y += dy * t;
      }
    }
    dx = p[0] - x;
    dy = p[1] - y;
    return dx * dx + dy * dy;
  }
}
class Path {
  constructor(pathType, controlPoints, maxLength) {
    this.pathType = pathType;
    this.maxLength = maxLength;
    if (controlPoints[0] instanceof Vector2) {
      this.controlPoints = controlPoints;
    } else {
      this.controlPoints = controlPoints.map((controlPoint) => new Vector2(controlPoint[0], controlPoint[1]));
    }
    const curvesPath = PathHelper.SplitControlPoints(this.controlPoints);
    this.points = PathHelper.CombinePath(curvesPath, this.pathType);
    if (maxLength) {
      this.points = PathHelper.TrimPath(this.points, maxLength);
    }
    this._cachedPointsTime = calcPointsTime(this.points);
    this._cachedPointsAngle = calcPointsAngle(this.points);
  }
  move(startX, startY, endX, endY) {
    for (let i = 0; i < this.points.length; i++) {
      this.points[i][0] += endX - startX;
      this.points[i][1] += endY - startY;
    }
    return this;
  }
  translate(x, y) {
    for (let i = 0; i < this.points.length; i++) {
      this.points[i][0] += x;
      this.points[i][1] += y;
    }
    return this;
  }
  scale(xOrScale, y) {
    if (y === void 0) {
      for (let i = 0; i < this.points.length; i++) {
        this.points[i][0] *= xOrScale;
        this.points[i][1] *= xOrScale;
      }
    } else {
      for (let i = 0; i < this.points.length; i++) {
        this.points[i][0] *= xOrScale;
        this.points[i][1] *= y;
      }
    }
    return this;
  }
  getLength() {
    return PathHelper.CalculateLength(this.points);
  }
  getIndexAt(t) {
    const maxLength = this._cachedPointsTime.length;
    let result = 0;
    if (t > this._cachedPointsTime[maxLength - 1]) {
      result = maxLength - 1;
    } else {
      for (let i = 1; i < this._cachedPointsTime.length; i++) {
        if (this._cachedPointsTime[i] > t) {
          result = i - 1;
          break;
        }
      }
    }
    return result;
  }
  getPointAt(t) {
    let i1 = this.getIndexAt(t);
    if (i1 === this._cachedPointsTime.length - 1) {
      return this.points[i1];
    }
    let i2 = i1 + 1;
    let weight = (t - this._cachedPointsTime[i1]) / (this._cachedPointsTime[i2] - this._cachedPointsTime[i1]);
    const x = this.points[i1][0] * (1 - weight) + this.points[i2][0] * weight;
    const y = this.points[i1][1] * (1 - weight) + this.points[i2][1] * weight;
    return new Vector2(x, y);
  }
  getPointTupleAt(t) {
    let i1 = this.getIndexAt(t);
    if (i1 === this._cachedPointsTime.length - 1) {
      return this.points[i1].toTuple();
    }
    let i2 = i1 + 1;
    let weight = (t - this._cachedPointsTime[i1]) / (this._cachedPointsTime[i2] - this._cachedPointsTime[i1]);
    const x = this.points[i1][0] * (1 - weight) + this.points[i2][0] * weight;
    const y = this.points[i1][1] * (1 - weight) + this.points[i2][1] * weight;
    return [x, y];
  }
  getAngleAt(t) {
    let i1 = this.getIndexAt(t);
    const angle = this._cachedPointsAngle[i1];
    return angle;
  }
  getTranslatedPoints(xOrTranslationOrVector, y) {
    const result = [];
    if (typeof xOrTranslationOrVector === "number") {
      const x = xOrTranslationOrVector;
      if (y === void 0) {
        for (let i = 0; i < this.points.length; i++) {
          result.push(this.points[i].add(x));
        }
      } else {
        for (let i = 0; i < this.points.length; i++) {
          const point = this.points[i].add([x, y]);
          result.push(point);
        }
      }
    } else {
      const vector = xOrTranslationOrVector;
      for (let i = 0; i < this.points.length; i++) {
        const point = this.points[i].add([vector[0], vector[1]]);
        result.push(point);
      }
    }
    return result;
  }
  clone() {
    const controlPoints = this.controlPoints.map((point) => point.clone());
    return new Path(this.pathType, controlPoints, this.maxLength);
  }
}
function calcPointsTime(points) {
  const result = [0];
  const totalLength = PathHelper.CalculateLength(points);
  let length = 0;
  for (let i = 0; i < points.length - 1; i++) {
    length += Vector2.Distance(points[i], points[i + 1]) / totalLength;
    result.push(length);
  }
  return result;
}
function calcPointsAngle(points) {
  const result = [];
  for (let i = 0; i < points.length - 1; i++) {
    result.push(Vector2.Angle(points[i], points[i + 1]));
  }
  return result;
}
function generateInOut(inFunc, outFunc) {
  return function(x) {
    return x < 0.5 ? inFunc(x * 2) / 2 : outFunc(x * 2 - 1) / 2 + 0.5;
  };
}
function elasticBase(x) {
  const n = 7;
  const p = 0.38;
  return 1 + -1 * Math.pow(2, -1 * n * x) * Math.cos(2 * Math.PI * x / p);
}
function bounceBase(x) {
  const g = 100;
  const f = 0.4;
  const T = 2 * Math.sqrt(1 / g);
  const q = 1 - g * (x % T - T / 2) ** 2;
  return Math.pow(f, Math.floor(x / T)) * q;
}
class EasingFunction {
  static Linear(x) {
    return x;
  }
  static InQuad(x) {
    return x ** 2;
  }
  static OutQuad(x) {
    return -((x - 1) ** 2) + 1;
  }
  static InOutQuad(x) {
    return generateInOut(this.InQuad, this.OutQuad)(x);
  }
  static InCubic(x) {
    return x ** 3;
  }
  static OutCubic(x) {
    return (x - 1) ** 3 + 1;
  }
  static InOutCubic(x) {
    return generateInOut(this.InCubic, this.OutCubic)(x);
  }
  static InQuart(x) {
    return x ** 4;
  }
  static OutQuart(x) {
    return -((x - 1) ** 4) + 1;
  }
  static InOutQuart(x) {
    return generateInOut(this.InQuart, this.OutQuart)(x);
  }
  static InQuint(x) {
    return x ** 5;
  }
  static OutQuint(x) {
    return (x - 1) ** 5 + 1;
  }
  static InOutQuint(x) {
    return generateInOut(this.InQuint, this.OutQuint)(x);
  }
  static InSine(x) {
    return 1 - Math.cos(x * Math.PI / 2);
  }
  static OutSine(x) {
    return Math.sin(x * Math.PI / 2);
  }
  static InOutSine(x) {
    return generateInOut(this.InSine, this.OutSine)(x);
  }
  static InExpo(x) {
    return x === 0 ? 0 : 2 ** (10 * (x - 1));
  }
  static OutExpo(x) {
    return x === 1 ? 1 : 1 - 2 ** (-10 * x);
  }
  static InOutExpo(x) {
    return generateInOut(this.InExpo, this.OutExpo)(x);
  }
  static InCirc(x) {
    return 1 - Math.sqrt(1 - x * x);
  }
  static OutCirc(x) {
    return Math.sqrt(-((x - 1) ** 2) + 1);
  }
  static InOutCirc(x) {
    return generateInOut(this.InCirc, this.OutCirc)(x);
  }
  static InElastic(x) {
    return 1 - this.OutElastic(1 - x);
  }
  static OutElastic(x) {
    return elasticBase(x);
  }
  static InOutElastic(x) {
    return generateInOut(this.InElastic, this.OutElastic)(x);
  }
  static InBounce(x) {
    return 1 - this.OutBounce(1 - x);
  }
  static OutBounce(x) {
    return 1 - (x < 0.2 ? bounceBase(x / 2 + 0.1) : bounceBase(x));
  }
  static InOutBounce(x) {
    return generateInOut(this.InBounce, this.OutBounce)(x);
  }
}
class Easer {
  constructor(fallbackValue = 0) {
    this.fallbackValue = fallbackValue;
    this.easings = [];
    this.time = 0;
  }
  static CreateEasing(startTime, endTime, targetFrom, targetTo, easingType = "Linear") {
    return { startTime, endTime, targetFrom, targetTo, easingType };
  }
  get value() {
    return this.getValueAt(this.time);
  }
  getValueAt(time) {
    if (this.easings.length === 0) {
      return this.fallbackValue;
    }
    let result = void 0;
    let selectedEasing = void 0;
    for (let i = this.easings.length - 1; i >= 0; i--) {
      selectedEasing = this.easings[i];
      if (time > selectedEasing.endTime || time < selectedEasing.startTime) {
        continue;
      }
      const t = (time - selectedEasing.startTime) / (selectedEasing.endTime - selectedEasing.startTime);
      result = EasingFunction[selectedEasing.easingType](t) * (selectedEasing.targetTo - selectedEasing.targetFrom) + selectedEasing.targetFrom;
      break;
    }
    if (result === void 0) {
      let minDeltaTime = Infinity;
      let closestIndexBefore = 0;
      if (time < this.easings[0].startTime) {
        result = this.easings[0].targetFrom;
      } else {
        for (let i = 0; i < this.easings.length; i++) {
          const easing = this.easings[i];
          const deltaTime = time - easing.endTime;
          if (deltaTime < 0) {
            break;
          }
          if (minDeltaTime > deltaTime) {
            minDeltaTime = deltaTime;
            closestIndexBefore = i;
          }
        }
        const closestEasing = this.easings[closestIndexBefore];
        result = closestEasing.targetTo;
      }
    }
    return result;
  }
  addEasing(easingsOrStartTime, endTime, targetFrom, targetTo, easingType = "Linear") {
    if (typeof easingsOrStartTime === "number") {
      const startTime = easingsOrStartTime;
      this.easings.push({
        startTime,
        endTime,
        targetFrom,
        targetTo,
        easingType
      });
    } else {
      this.easings.push(...arguments);
    }
    return this;
  }
  removeEasing(...easings) {
    this.easings = this.easings.filter((e2) => !easings.includes(e2));
  }
  removeAllEasings() {
    this.easings = [];
  }
}
class Animation {
  constructor(animationType) {
    this.animationType = animationType;
    this.animationEasers = [];
  }
  setSequence(easer, easings) {
    const easerIndex = this.animationEasers.findIndex((animationEaser) => animationEaser.easer === easer);
    if (easerIndex === -1) {
      this.animationEasers.push({ easer, easings });
      easer.addEasing(...easings);
      return;
    }
    const oldEasings = this.animationEasers[easerIndex].easings;
    this.animationEasers[easerIndex].easer.removeEasing(...oldEasings);
    easer.addEasing(...easings);
  }
  addSequence(easer, easings) {
    const easerIndex = this.animationEasers.findIndex((animationEaser) => animationEaser.easer === easer);
    if (easerIndex === -1) {
      this.setSequence(easer, easings);
      return;
    }
    this.animationEasers[easerIndex].easings.push(...easings);
    easer.addEasing(...easings);
  }
  removeSequence(sequence) {
    const easerIndex = this.animationEasers.findIndex((animationEaser) => animationEaser.easer === sequence.easer);
    this.animationEasers[easerIndex].easer.removeEasing(...sequence.easings);
    this.animationEasers.splice(easerIndex, 1);
  }
}
class DrawableHitObject {
  constructor() {
    this.animations = [];
  }
  update(time) {
    this.removeFutureAnimation(time);
  }
  draw(time) {
  }
  playAnimation(animationType, easer, easings) {
    const animationIndex = this.animations.findIndex((anim) => anim.animationType === animationType);
    if (animationIndex === -1) {
      const animation = new Animation(animationType);
      this.animations.push(animation);
      animation.addSequence(easer, easings);
      return;
    }
    this.animations[animationIndex].addSequence(easer, easings);
  }
  removeFutureAnimation(time) {
    this.animations.forEach((anim) => {
      const futureAnimEasers = anim.animationEasers.filter((animEasers) => {
        return Math.min(...animEasers.easings.map((easing) => easing.startTime)) > time;
      });
      futureAnimEasers.forEach((pog) => {
        anim.removeSequence(pog);
      });
    });
  }
  animate(animationType, time) {
  }
}
class DrawableHitCircle$1 extends DrawableHitObject {
  constructor(hitObject) {
    super();
    this.hitObject = hitObject;
    this.positionOffset = {
      x: new Easer(0),
      y: new Easer(0)
    };
    this.scale = new Easer(1);
    const diff = hitObject.difficulty;
    const fadeIn = diff.fadeIn;
    const preempt = diff.getPreempt();
    const appearTime = hitObject.startTime - preempt;
    const opacity = new Easer();
    if (diff.mods.contains(Mod.Hidden)) {
      opacity.addEasing(appearTime, appearTime + preempt * 0.4, 0, 1);
      opacity.addEasing(appearTime + preempt * 0.4, appearTime + preempt * 0.7, 1, 0);
    } else {
      opacity.addEasing(appearTime, appearTime + fadeIn, 0, 1);
      opacity.addEasing(hitObject.endTime, hitObject.endTime + 150, 1, 0);
    }
    const approachCircleOpacity = new Easer(0);
    if (diff.mods.contains(Mod.Hidden)) {
      if (hitObject.objectIndex === 0) {
        approachCircleOpacity.addEasing(0, Math.min(fadeIn * 2, preempt), 0, 1);
        approachCircleOpacity.addEasing(Math.min(fadeIn * 2, preempt), Math.min(fadeIn * 2, preempt) * 2, 1, 0);
      }
    } else {
      approachCircleOpacity.addEasing(appearTime, appearTime + Math.min(fadeIn * 2, preempt), 0, 1);
      approachCircleOpacity.addEasing(hitObject.startTime, hitObject.startTime + 150, 1, 0);
    }
    const approachCircleScale = new Easer(1);
    approachCircleScale.addEasing(appearTime, hitObject.startTime, 4, 1);
    this.opacity = opacity;
    this.approachCircleOpacity = approachCircleOpacity;
    this.approachCircleScale = approachCircleScale;
    this.animate("HIT", hitObject.endTime);
  }
  draw(time) {
    this.opacity.time = time;
    this.scale.time = time;
    this.approachCircleOpacity.time = time;
    this.approachCircleScale.time = time;
    this.positionOffset.x.time = time;
    this.positionOffset.y.time = time;
  }
  animate(animation, time) {
    switch (animation) {
      case "SHAKE": {
        this.playAnimation("SHAKE", this.positionOffset.x, shake(time));
        break;
      }
      case "MISS": {
        if (this.hitObject.difficulty.mods.contains(Mod.Hidden)) {
          break;
        }
        this.playAnimation("MISS", this.opacity, miss(time));
        this.playAnimation("MISS", this.approachCircleOpacity, miss(time));
        break;
      }
      case "HIT": {
        if (this.hitObject.difficulty.mods.contains(Mod.Hidden)) {
          break;
        }
        this.playAnimation("HIT", this.opacity, opacityAfterHit(time));
        this.playAnimation("HIT", this.scale, scaleAfterHit(time));
        break;
      }
    }
  }
}
function shake(time) {
  const shakeoffset = 7;
  const shakeTimeStep = 50;
  const right = Easer.CreateEasing(time, time + shakeTimeStep, 0, shakeoffset);
  const left = Easer.CreateEasing(time + shakeTimeStep, time + shakeTimeStep * 3, shakeoffset, -shakeoffset);
  const center = Easer.CreateEasing(time + shakeTimeStep * 3, time + shakeTimeStep * 4, -shakeoffset, 0, "OutBounce");
  return [right, left, center];
}
function miss(time) {
  const fadeOutTime = 80;
  const fadeOut = Easer.CreateEasing(time, time + fadeOutTime, 1, 0);
  return [fadeOut];
}
function opacityAfterHit(time) {
  const fadeOutTime = 150;
  const fadeOut = Easer.CreateEasing(time, time + fadeOutTime, 1, 0, "OutQuad");
  return [fadeOut];
}
function scaleAfterHit(time) {
  const scaleOutTime = 150;
  const scaleOut = Easer.CreateEasing(time, time + scaleOutTime, 1, 1.25);
  return [scaleOut];
}
var HitObjectType = /* @__PURE__ */ ((HitObjectType2) => {
  HitObjectType2[HitObjectType2["HitCircle"] = 1] = "HitCircle";
  HitObjectType2[HitObjectType2["Slider"] = 2] = "Slider";
  HitObjectType2[HitObjectType2["Spinner"] = 8] = "Spinner";
  HitObjectType2[HitObjectType2["NewCombo"] = 4] = "NewCombo";
  HitObjectType2[HitObjectType2["ColorSkip1"] = 16] = "ColorSkip1";
  HitObjectType2[HitObjectType2["ColorSkip2"] = 32] = "ColorSkip2";
  HitObjectType2[HitObjectType2["ColorSkip3"] = 64] = "ColorSkip3";
  return HitObjectType2;
})(HitObjectType || {});
class Hitsample {
  constructor(normalSet, additionSet, index2, volume, filename) {
    this.normalSet = normalSet;
    this.additionSet = additionSet;
    this.index = index2;
    this.volume = volume;
    this.filename = filename;
  }
}
class HitObject {
  constructor(hitObjectConfig) {
    this.colour = "#ffffff";
    this.stackCount = 0;
    this.stackOffset = 0;
    const { startPos, endPos, startTime, endTime, type, hitSound, hitSample, comboCount, difficulty, objectIndex } = hitObjectConfig;
    this.startPos = startPos;
    this.endPos = endPos;
    this.startTime = startTime;
    this.endTime = endTime;
    this.type = type;
    this.hitSound = hitSound;
    this.hitSample = hitSample;
    this.difficulty = difficulty;
    this.objectIndex = objectIndex;
    this.comboCount = comboCount;
  }
  draw(time) {
  }
  update(time) {
  }
  getStackedStartPos() {
    return [this.startPos[0] - this.stackOffset, this.startPos[1] - this.stackOffset];
  }
  getStackedEndPos() {
    return [this.endPos[0] - this.stackOffset, this.endPos[1] - this.stackOffset];
  }
  setNewCombo() {
    this.type &= 4;
  }
  isNewCombo() {
    return this.type & 4;
  }
  isHitCircle() {
    return this.type & 1;
  }
  isSlider() {
    return this.type & 2;
  }
  isSpinner() {
    return this.type & 8;
  }
  isVisibleAt(time) {
    return time >= this.startTime - this.difficulty.getPreempt() && time <= this.endTime + 150;
  }
  getColourHax() {
    return ((this.type & (16 | 32 | 64)) >> 4) + 1;
  }
}
class HitCircle extends HitObject {
  constructor(hitObjectConfig) {
    super(hitObjectConfig);
    this.drawable = new DrawableHitCircle$1(this);
  }
  draw(time) {
    this.drawable.draw(time);
  }
  update(time) {
    this.drawable.update(time);
  }
}
class DrawableSliderTick {
  constructor(sliderTick) {
    this.sliderTick = sliderTick;
    const slider = sliderTick.slider;
    const tickOpacity = new Easer(0);
    const tickScale = new Easer(0);
    const slideIndex = slider.getSlideIndexAt(sliderTick.time);
    const diff = slider.difficulty;
    const preempt = diff.getPreempt();
    const appearTime = slider.startTime - preempt;
    const firstTickAppearTime = slideIndex === 0 ? appearTime : slider.getSlideStartTime(slideIndex);
    let fadeStart = firstTickAppearTime + (sliderTick.time - firstTickAppearTime) / 2 - 150;
    let fadeEnd = Math.min(fadeStart + 150, sliderTick.time - 1);
    tickOpacity.addEasing(fadeStart, fadeEnd, 0, 1);
    tickOpacity.addEasing(sliderTick.time - 1, sliderTick.time, 1, 0);
    tickScale.addEasing(fadeStart, fadeEnd, 0, 1, "OutElastic");
    tickScale.addEasing(fadeEnd, sliderTick.time, 1, 1);
    this.opacity = tickOpacity;
    this.scale = tickScale;
  }
  draw(time) {
    this.opacity.time = time;
    this.scale.time = time;
  }
}
const SNAKING_DURATION = 200;
class DrawableReverseTick {
  constructor(reverseTick) {
    this.reverseTick = reverseTick;
    const slider = reverseTick.slider;
    const slideDuration = Math.floor(slider.duration / slider.slides);
    const reverseTime = reverseTick.time;
    const sliderAppearTime = slider.startTime - slider.difficulty.getPreempt();
    const isFirstTick = Math.abs(reverseTime - slideDuration - slider.startTime) < 1;
    const tickOpacity = new Easer(0);
    const tickFadeStart = isFirstTick ? sliderAppearTime + SNAKING_DURATION : reverseTime - slideDuration * 2;
    const tickFadeEnd = tickFadeStart + 300;
    tickOpacity.addEasing(tickFadeStart, tickFadeEnd, 0, 1);
    tickOpacity.addEasing(reverseTime - 1, reverseTime, 1, 0);
    tickOpacity.addEasing(reverseTime, Infinity, 0, 0);
    const tickScale = new Easer(1);
    const tickStart = reverseTime - slideDuration * 2;
    const tickEnd = reverseTime;
    for (let i = tickStart; i < tickEnd; i += 300) {
      tickScale.addEasing(i, i + 300, 1.25, 1);
    }
    this.opacity = tickOpacity;
    this.scale = tickScale;
  }
  draw(time) {
    this.opacity.time = time;
    this.scale.time = time;
  }
}
class DrawableSlider$1 extends DrawableHitObject {
  constructor(slider) {
    super();
    this.slider = slider;
    const diff = slider.difficulty;
    const fadeIn = diff.fadeIn;
    const preempt = diff.getPreempt();
    const bodyOpacity = new Easer();
    const headOpacity = new Easer();
    const appearTime = slider.startTime - preempt;
    if (diff.mods.contains(Mod.Hidden)) {
      bodyOpacity.addEasing(appearTime, appearTime + fadeIn, 0, 0.7);
      bodyOpacity.addEasing(appearTime + fadeIn, slider.endTime, 0.7, 0, "OutQuad");
      headOpacity.addEasing(appearTime, appearTime + preempt * 0.4, 0, 1);
      headOpacity.addEasing(appearTime + preempt * 0.4, appearTime + preempt * 0.7, 1, 0);
    } else {
      bodyOpacity.addEasing(appearTime, appearTime + fadeIn, 0, 0.7);
      bodyOpacity.addEasing(slider.endTime, slider.endTime + 150, 0.7, 0);
      headOpacity.addEasing(appearTime, appearTime + fadeIn, 0, 1);
      headOpacity.addEasing(slider.startTime, slider.startTime + 150, 1, 0);
    }
    const ballOpacity = new Easer(0);
    ballOpacity.addEasing(slider.startTime, slider.startTime + 1, 0, 1);
    ballOpacity.addEasing(slider.endTime, slider.endTime + 1, 1, 0);
    const followCircleOpacity = new Easer(0);
    const followCircleScale = new Easer(1);
    const approachCircleOpacity = new Easer(0);
    if (diff.mods.contains(Mod.Hidden)) {
      if (slider.objectIndex === 0) {
        approachCircleOpacity.addEasing(0, Math.min(fadeIn * 2, preempt), 0, 1);
        approachCircleOpacity.addEasing(Math.min(fadeIn * 2, preempt), Math.min(fadeIn * 2, preempt) * 2, 1, 0);
      }
    } else {
      approachCircleOpacity.addEasing(appearTime, appearTime + Math.min(fadeIn * 2, preempt), 0, 1);
      approachCircleOpacity.addEasing(appearTime + Math.min(fadeIn * 2, preempt), slider.startTime, 1, 1);
      approachCircleOpacity.addEasing(slider.startTime, slider.startTime + 150, 1, 0);
    }
    const approachCircleScale = new Easer(1);
    approachCircleScale.addEasing(appearTime, slider.startTime, 4, 1);
    approachCircleScale.addEasing(slider.startTime, slider.startTime + 100, 1, 1.05);
    this.progress = 0;
    this.progressPosition = slider.getPositionAt(0);
    this.isVisible = false;
    this.isSliding = false;
    this.isReversed = false;
    this.slideIndex = 0;
    this.ballRotation = slider.getBallRotationAt(0);
    this.ballOpacity = ballOpacity;
    this.bodyOpacity = bodyOpacity;
    this.headOpacity = headOpacity;
    this.followCircleOpacity = followCircleOpacity;
    this.followCircleScale = followCircleScale;
    this.approachCircleOpacity = approachCircleOpacity;
    this.approachCircleScale = approachCircleScale;
    this.animate("FOLLOW_START", slider.startTime);
    this.animate("FOLLOW_END", slider.endTime);
  }
  draw(time) {
    this.progress = MathHelper.Clamp((time - this.slider.startTime) / this.slider.duration, 0, 1);
    this.progressPosition = this.slider.getStackedPositionAt(time);
    this.isVisible = this.slider.isVisibleAt(time);
    this.isSliding = time >= this.slider.startTime && time <= this.slider.endTime;
    this.slideIndex = this.slider.getSlideIndexAt(time);
    this.isReversed = this.slider.getSlideDirectionAt(time) === -1;
    this.ballRotation = this.slider.getBallRotationAt(time);
    this.ballOpacity.time = time;
    this.bodyOpacity.time = time;
    this.headOpacity.time = time;
    this.followCircleOpacity.time = time;
    this.followCircleScale.time = time;
    this.approachCircleOpacity.time = time;
    this.approachCircleScale.time = time;
  }
  animate(animationType, time) {
    switch (animationType) {
      case "FOLLOW_START": {
        this.playAnimation("FOLLOW_START", this.followCircleOpacity, followStartOpacityAnim(time));
        this.playAnimation("FOLLOW_START", this.followCircleScale, followStartScaleAnim(time));
        break;
      }
      case "UNFOLLOW": {
        this.playAnimation("UNFOLLOW", this.followCircleOpacity, unfollowOpacityAnim(time));
        this.playAnimation("UNFOLLOW", this.followCircleScale, unfollowScaleAnim(time));
        break;
      }
      case "FOLLOW_END": {
        const opacity = this.followCircleOpacity;
        const scale = this.followCircleScale;
        this.playAnimation("FOLLOW_END", opacity, followerEndOpacityAnim(opacity.getValueAt(time), time));
        this.playAnimation("FOLLOW_END", scale, followerEndScaleAnim(scale.getValueAt(time), time));
        break;
      }
    }
  }
}
const followerStartSize = 1 / 1.4;
function followStartOpacityAnim(time) {
  return [Easer.CreateEasing(time, time + 75, 0, 1, "OutQuad")];
}
function followStartScaleAnim(time) {
  return [Easer.CreateEasing(time, time + 450, followerStartSize, 1, "OutQuad")];
}
function unfollowOpacityAnim(time) {
  return [Easer.CreateEasing(time, time + 250, 1, 0, "OutQuad")];
}
function unfollowScaleAnim(time) {
  return [Easer.CreateEasing(time, time + 450, 1, 2, "OutQuad")];
}
function followerEndOpacityAnim(currentOpacity, time) {
  return [Easer.CreateEasing(time, time + 150, currentOpacity, 0, "OutQuad")];
}
function followerEndScaleAnim(currentScale, time) {
  return [Easer.CreateEasing(time, time + 250, currentScale, followerStartSize, "OutQuad")];
}
class SliderTick {
  constructor(slider, time, position) {
    this.slider = slider;
    this.time = time;
    this.position = position;
    this.drawable = new DrawableSliderTick(this);
  }
}
class SliderReverseTick {
  constructor(slider, time, position, isReversed) {
    this.slider = slider;
    this.time = time;
    this.position = position;
    this.isReversed = isReversed;
    this.drawable = new DrawableReverseTick(this);
  }
}
class Slider extends HitObject {
  constructor(hitObjectConfig, sliderConfig, timing) {
    super(hitObjectConfig);
    this.timing = timing;
    this.sliderTicks = [];
    this.reverseTicks = [];
    const { curveType, curvePoints, curvePath, slides, length, edgeSounds, edgeSets } = sliderConfig;
    this.curveType = curveType;
    this.curvePoints = curvePoints;
    this.curvePath = curvePath;
    this.slides = slides;
    this.length = length;
    this.edgeSounds = edgeSounds;
    this.edgeSets = edgeSets;
    const stackedCurvePath = this.curvePath.clone();
    stackedCurvePath.translate(-this.stackOffset, -this.stackOffset);
    this.stackedCurvePath = stackedCurvePath;
    const points = this.curvePath.points;
    const s1 = points[1];
    const s2 = points[0];
    this.startAngle = Vector2.Angle(s2, s1);
    const e1 = points[points.length - 2];
    const e2 = points[points.length - 1];
    this.endAngle = Vector2.Angle(e2, e1);
    const { duration, endTime } = this.initializeTiming();
    this.duration = duration;
    this.endTime = endTime;
    this.sliderTicks = this.initializeSliderTicks();
    this.reverseTicks = this.initializeReverseTicks();
    this.drawable = new DrawableSlider$1(this);
  }
  initializeTiming() {
    const sliderStartTime = this.startTime;
    const timing = this.timing.getTimingAt(sliderStartTime);
    const beatLength = timing.beatLength;
    const sliderMult = this.difficulty.sliderMultiplier;
    const sliderPixelVelocity = sliderMult * 100;
    const sliderBeatCount = this.length * this.slides / sliderPixelVelocity;
    const sliderDuration = sliderBeatCount * beatLength;
    const duration = sliderDuration;
    const endTime = this.startTime + sliderDuration;
    return { duration, endTime };
  }
  initializeSliderTicks() {
    const timing = this.timing.getTimingAt(this.startTime);
    const sliderTickRate = this.difficulty.sliderTickRate;
    const sliderTickDuration = timing.beatLengthBase / sliderTickRate;
    const sliderSlideDuration = Math.floor(this.duration / this.slides);
    const tickCountPerSlide = Math.max(0, Math.ceil(sliderSlideDuration / sliderTickDuration) - 1);
    const sliderTicks = [];
    for (let i = 0; i < this.slides; i++) {
      const isReverse = i % 2 === 1;
      if (!isReverse) {
        for (let j = 0; j < tickCountPerSlide; j++) {
          const tickTime = this.startTime + (j + 1) * sliderTickDuration + i * sliderSlideDuration;
          const tickPos = this.getPositionAt(tickTime);
          const tick = new SliderTick(this, tickTime, tickPos);
          sliderTicks.push(tick);
        }
      } else {
        for (let j = tickCountPerSlide - 1; j >= 0; j--) {
          const tickTime = this.startTime + sliderSlideDuration - (j + 1) * sliderTickDuration + i * sliderSlideDuration;
          const tickPos = this.getPositionAt(tickTime);
          const tick = new SliderTick(this, tickTime, tickPos);
          sliderTicks.push(tick);
        }
      }
    }
    return sliderTicks;
  }
  initializeReverseTicks() {
    const reverseTicks = [];
    for (let i = 1; i < this.slides; i++) {
      const slideDuration = Math.floor(this.duration / this.slides);
      const reverseTime = this.startTime + slideDuration * i;
      const reversePos = this.getPositionAt(reverseTime);
      const sliderCurvePoints = this.curvePath.points;
      if (i % 2 === 0) {
        const p1 = sliderCurvePoints[1];
        const p2 = sliderCurvePoints[0];
        Vector2.Angle(p2, p1);
      } else {
        const p1 = sliderCurvePoints[sliderCurvePoints.length - 2];
        const p2 = sliderCurvePoints[sliderCurvePoints.length - 1];
        Vector2.Angle(p2, p1);
      }
      const isReversed = i % 2 === 1;
      const reverseTick = new SliderReverseTick(this, reverseTime, reversePos, isReversed);
      reverseTicks.push(reverseTick);
    }
    return reverseTicks;
  }
  draw(time) {
    this.drawable.draw(time);
    this.sliderTicks.forEach((ticks) => ticks.drawable.draw(time));
    this.reverseTicks.forEach((ticks) => ticks.drawable.draw(time));
  }
  getPositionAt(time) {
    time = MathHelper.Clamp(time, this.startTime, this.endTime);
    const slideIndex = this.getSlideIndexAt(time);
    const t1 = (time - this.startTime) / (this.duration / this.slides) - slideIndex;
    const t2 = slideIndex % 2 === 0 ? t1 : 1 - t1;
    return this.curvePath.getPointTupleAt(t2);
  }
  getStackedPositionAt(time) {
    const position = this.getPositionAt(time);
    return [position[0] - this.stackOffset, position[1] - this.stackOffset];
  }
  getSlideDirectionAt(time) {
    time = MathHelper.Clamp(time, this.startTime, this.endTime);
    return this.getSlideIndexAt(time) % 2 === 0 ? 1 : -1;
  }
  getBallRotationAt(time) {
    time = MathHelper.Clamp(time, this.startTime, this.endTime);
    const slideIndex = this.getSlideIndexAt(time);
    const t1 = (time - this.startTime) / (this.duration / this.slides) - slideIndex;
    const t2 = slideIndex % 2 === 0 ? t1 : 1 - t1;
    let angle = this.curvePath.getAngleAt(t2);
    if (slideIndex % 2 === 1) {
      angle = Math.PI + angle;
    }
    return angle;
  }
  getSlideIndexAt(time) {
    time = MathHelper.Clamp(time, this.startTime, this.endTime);
    return Math.max(0, Math.ceil((time - this.startTime) * this.slides / this.duration) - 1);
  }
  getSlideStartTime(index2) {
    return this.startTime + index2 * this.duration / this.slides;
  }
  getCurvePath() {
    return this.curvePath;
  }
  getStackedCurvePath() {
    return this.stackedCurvePath;
  }
  getSliderTicks() {
    return this.sliderTicks;
  }
  getStackedSliderTicks() {
    const ticks = [];
    for (const tick of this.sliderTicks) {
      ticks.push(new SliderTick(this, tick.time, [tick.position[0] - this.stackOffset, tick.position[1] - this.stackOffset]));
    }
    return ticks;
  }
  getReverseTicks() {
    return this.reverseTicks;
  }
  getStackedReverseTicks() {
    const ticks = [];
    for (const tick of this.reverseTicks) {
      ticks.push(new SliderReverseTick(this, tick.time, [tick.position[0] - this.stackOffset, tick.position[1] - this.stackOffset], tick.isReversed));
    }
    return ticks;
  }
}
class DrawableSpinner$1 {
  constructor(spinner) {
    this.spinner = spinner;
    const opacity = new Easer();
    const appearTime = spinner.startTime - spinner.difficulty.getPreempt();
    const dissapearTime = spinner.endTime + 150;
    opacity.addEasing(appearTime, spinner.startTime, 0, 1);
    opacity.addEasing(spinner.startTime, spinner.endTime, 1, 1);
    opacity.addEasing(spinner.endTime, dissapearTime, 1, 0);
    this.rpm = 0;
    this.rotation = 0;
    this.meter = 0;
    this.opacity = opacity;
    const spinDuration = spinner.endTime - spinner.startTime;
    const rotation = spinDuration / 60 * 220;
    const progressStep = 10;
    this.fakeMeter = new Easer();
    for (let i = 1; i <= progressStep; i++) {
      this.fakeMeter.addEasing(spinner.startTime + (i - 0.55) / progressStep * spinDuration, spinner.startTime + (i - 0.5) / progressStep * spinDuration, (i - 1) / progressStep, i / progressStep);
    }
    this.fakeRotation = new Easer();
    this.fakeRotation.addEasing(spinner.startTime, spinner.endTime, 0, rotation);
  }
  draw(time) {
    this.opacity.time = time;
    this.fakeMeter.time = time;
    this.fakeRotation.time = time;
  }
}
class Spinner extends HitObject {
  constructor(hitObjectConfig) {
    super(hitObjectConfig);
    this.drawable = new DrawableSpinner$1(this);
  }
  draw(time) {
    this.drawable.draw(time);
  }
}
class HitObjects {
  constructor() {
    this.objects = [];
  }
  parseStringArray(hitObjectStringArray, difficulty, timing) {
    let comboCount = 0;
    let objectIndex = 0;
    for (let hitObjectString of hitObjectStringArray) {
      const hitObjectParams = hitObjectString.split(",");
      const hitObjectType = parseInt(hitObjectParams[3]);
      (hitObjectType & HitObjectType.NewCombo || hitObjectType & HitObjectType.Spinner) && (comboCount = 0);
      comboCount++;
      if (hitObjectType & HitObjectType.HitCircle) {
        let [x, y, time, type, hitSound] = hitObjectParams.slice(0, 5).map(Number);
        if (difficulty.mods.contains(Mod.HardRock)) {
          y = 384 - y;
        }
        const startPos = [x, y];
        const endPos = [x, y];
        const startTime = time;
        const endTime = time;
        const [normalSet, additionSet, index2, volume, filename] = hitObjectParams[5].split(":");
        const hitSample = new Hitsample(+normalSet, +additionSet, +index2, +volume, filename);
        const hitObjectConfig = {
          startPos,
          endPos,
          startTime,
          endTime,
          type,
          hitSound,
          hitSample,
          comboCount,
          difficulty,
          objectIndex
        };
        const hitCircle = new HitCircle(hitObjectConfig);
        this.objects.push(hitCircle);
      } else if (hitObjectType & HitObjectType.Slider) {
        let [x, y, time, type, hitSound] = hitObjectParams.slice(0, 5).map(Number);
        const startTime = time;
        const endTime = time;
        const [curveType, ...curvePointsStr] = hitObjectParams[5].split("|");
        const [slides, length] = hitObjectParams.slice(6, 8).map(Number);
        const curvePoints = curvePointsStr.map((curvePoint) => curvePoint.split(":").map(Number));
        if (difficulty.mods.contains(Mod.HardRock)) {
          y = 384 - y;
          curvePoints.forEach((curvePoint) => curvePoint[1] = 384 - curvePoint[1]);
        }
        const curvePath = new Path(curveType, [[x, y]].concat(curvePoints), length);
        const startPos = [x, y];
        const endPosRaw = curvePath.points[curvePath.points.length - 1].toTuple();
        const endPos = [Math.floor(endPosRaw[0]), Math.floor(endPosRaw[1])];
        let hitSample = new Hitsample(0, 0, 0, 0, "");
        let edgeSounds = [];
        let edgeSets = [];
        if (hitObjectParams.length > 8) {
          edgeSounds = hitObjectParams[8].split("|").map(Number);
          edgeSets = hitObjectParams[9].split("|").map((edgeSet) => edgeSet.split(":"));
          const [normalSet, additionSet, index2, volume, filename] = hitObjectParams[10].split(":");
          hitSample = new Hitsample(+normalSet, +additionSet, +index2, +volume, filename);
        }
        const hitObjectConfig = {
          startPos,
          endPos,
          startTime,
          endTime,
          type,
          hitSound,
          hitSample,
          comboCount,
          difficulty,
          objectIndex
        };
        const sliderConfig = { curveType, curvePoints, curvePath, slides, length, edgeSounds, edgeSets };
        const slider = new Slider(hitObjectConfig, sliderConfig, timing);
        this.objects.push(slider);
      } else if (hitObjectType & HitObjectType.Spinner) {
        const [x, y, time, type, hitSound, endTime] = hitObjectParams.slice(0, 6).map(Number);
        const startPos = [x, y];
        const endPos = startPos;
        const startTime = time;
        const [normalSet, additionSet, index2, volume, filename] = hitObjectParams[6].split(":");
        const hitSample = new Hitsample(+normalSet, +additionSet, +index2, +volume, filename);
        const hitObjectConfig = {
          startPos,
          endPos,
          startTime,
          endTime,
          type,
          hitSound,
          hitSample,
          comboCount,
          difficulty,
          objectIndex
        };
        const spinner = new Spinner(hitObjectConfig);
        this.objects.push(spinner);
      }
      objectIndex++;
    }
  }
  applyColour(colour) {
    let colourIndex = 0;
    for (let hitObject of this.objects) {
      if (hitObject.isNewCombo()) {
        colourIndex = (colourIndex + hitObject.getColourHax()) % colour.length;
      }
      hitObject.colour = colour[colourIndex];
    }
  }
  applyStacking(difficulty, stackLeniency) {
    const hitObjectRadius = difficulty.getObjectRadius();
    const stackOffset = hitObjectRadius / 10;
    const STACK_LENIENCE = 3;
    const stackThreshold = difficulty.getPreempt() * stackLeniency;
    for (let i = this.objects.length - 1; i > 0; i--) {
      let n = i;
      let objectI = this.objects[i];
      if (objectI.stackCount != 0 || objectI.isSpinner())
        continue;
      if (objectI.isHitCircle()) {
        while (--n >= 0) {
          const objectN = this.objects[n];
          if (objectN.isSpinner())
            continue;
          if (objectI.startTime - objectN.endTime > stackThreshold)
            break;
          if (objectN.isSlider() && Vector2.Distance(objectN.endPos, objectI.startPos) < STACK_LENIENCE) {
            let offset = objectI.stackCount - objectN.stackCount + 1;
            for (let j = n + 1; j <= i; j++) {
              if (Vector2.Distance(objectN.endPos, this.objects[j].startPos) < STACK_LENIENCE) {
                this.objects[j].stackCount -= offset;
              }
            }
            break;
          }
          if (Vector2.Distance(objectN.startPos, objectI.startPos) < STACK_LENIENCE) {
            objectN.stackCount = objectI.stackCount + 1;
            objectI = objectN;
          }
        }
      } else if (objectI.isSlider()) {
        while (--n >= 0) {
          let objectN = this.objects[n];
          if (objectN.isSpinner())
            continue;
          if (objectI.startTime - objectN.startTime > stackThreshold)
            break;
          if (Vector2.Distance(objectN.endPos, objectI.startPos) < STACK_LENIENCE) {
            objectN.stackCount = objectI.stackCount + 1;
            objectI = objectN;
          }
        }
      }
    }
    for (const object of this.objects) {
      if (object.isSpinner())
        continue;
      const stackCount = object.stackCount;
      const stackDistance = stackCount * stackOffset;
      object.stackOffset = stackDistance;
    }
  }
  getIndexNear(timestamp) {
    let mid;
    let lo = 0;
    let hi = this.objects.length - 1;
    while (hi - lo > 1) {
      mid = Math.floor((lo + hi) / 2);
      if (this.objects[mid].startTime < timestamp) {
        lo = mid;
      } else {
        hi = mid;
      }
    }
    if (timestamp - this.objects[lo].startTime <= this.objects[hi].startTime - timestamp) {
      return lo;
    }
    return hi;
  }
}
class Metadata {
  parseStringArray(args) {
    const [title, titleUnicode, artist, artistUnicode, creator, version, source, tags, beatmapId, beatmapSetId] = args.map((row) => row.replace(/.+: */g, ""));
    this.title = title || "";
    this.titleUnicode = titleUnicode || "";
    this.artist = artist || "";
    this.artistUnicode = artistUnicode || "";
    this.creator = creator || "";
    this.version = version || "";
    this.source = source || "";
    this.tags = tags || "";
    this.beatmapId = parseInt(beatmapId) || 0;
    this.beatmapSetId = parseInt(beatmapSetId) || 0;
  }
}
class Timing {
  constructor(time, _beatlength, base, meter, sampleSet, sampleIndex, volume, uninhereted, effects) {
    this.time = time;
    this.meter = meter;
    this.sampleSet = sampleSet;
    this.sampleIndex = sampleIndex;
    this.volume = volume;
    this.uninhereted = uninhereted;
    this.effects = effects;
    this.beatLengthBase = base;
    if (uninhereted) {
      this.beatLength = _beatlength;
    } else {
      this.beatLength = Math.max(10, Math.min(1e3, -_beatlength)) * base / 100;
    }
  }
  get bpm() {
    return 1 / this.beatLengthBase * 1e3 * 60;
  }
}
class TimingPoints {
  constructor() {
    this.timings = [];
  }
  parseStringArray(timingStringArray) {
    let inheritedBase = 0;
    for (let timingString of timingStringArray) {
      const [time, beatLength, meter, sampleSet, sampleIndex, volume, uninherited, effects] = timingString.split(",").map(Number);
      if (uninherited) {
        inheritedBase = beatLength;
      }
      const timing = new Timing(time, beatLength, inheritedBase, meter, sampleSet, sampleIndex, volume, uninherited, effects);
      this.timings.push(timing);
    }
  }
  getTimingAt(time) {
    let timing = this.timings[0];
    for (let i = 0; i < this.timings.length; i++) {
      if (this.timings[i].time > time) {
        break;
      }
      timing = this.timings[i];
    }
    return timing;
  }
  getInheritedTimingAt(time) {
    let timing = this.timings[0];
    for (let i = 0; i < this.timings.length; i++) {
      if (this.timings[i].time > time) {
        break;
      }
      if (!this.timings[i].uninhereted) {
        timing = this.timings[i];
      }
    }
    return timing;
  }
  getUninheritedTimingAt(time) {
    let timing = this.timings[0];
    for (let i = 0; i < this.timings.length; i++) {
      if (this.timings[i].time > time) {
        break;
      }
      if (this.timings[i].uninhereted) {
        timing = this.timings[i];
      }
    }
    return timing;
  }
}
class Beatmap {
  constructor(mapData = "", mods) {
    this.mapData = mapData;
    const { general, editor, metadata, difficulty, events, timingPoints, colours, hitObjects } = this.parseBeatmap(mods);
    this.general = general;
    this.editor = editor;
    this.metadata = metadata;
    this.difficulty = difficulty;
    this.events = events;
    this.timingPoints = timingPoints;
    this.colours = colours;
    this.hitObjects = hitObjects;
  }
  parseBeatmap(mods) {
    const general = new General();
    const editor = new Editor();
    const metadata = new Metadata();
    const difficulty = new Difficulty();
    const events = new Events();
    const timingPoints = new TimingPoints();
    const colours = new Colours();
    const hitObjects = new HitObjects();
    const row = this.mapData.replace(/(\/\/.+)/g, "").split(/\r?\n/).filter((str) => str !== "");
    const sections = [
      "[General]",
      "[Editor]",
      "[Metadata]",
      "[Difficulty]",
      "[Events]",
      "[TimingPoints]",
      "[Colours]",
      "[HitObjects]"
    ];
    const sectionsIndex = sections.map((section) => row.findIndex((str) => str === section));
    const sectionChunk = [];
    sectionsIndex.reverse().forEach((index2) => {
      sectionChunk.push(row.splice(index2).splice(1));
    });
    sectionChunk.reverse();
    general.parseStringArray(sectionChunk[0]);
    editor.parseStringArray(sectionChunk[1]);
    metadata.parseStringArray(sectionChunk[2]);
    difficulty.parseStringArray(sectionChunk[3], mods);
    events.parseStringArray(sectionChunk[4]);
    timingPoints.parseStringArray(sectionChunk[5]);
    colours.parseStringArray(sectionChunk[6]);
    hitObjects.parseStringArray(sectionChunk[7], difficulty, timingPoints);
    const hexColours = colours.hex;
    hitObjects.applyColour(hexColours);
    const stackLeniency = general.stackLeniency;
    hitObjects.applyStacking(difficulty, stackLeniency);
    return { general, editor, metadata, difficulty, events, timingPoints, colours, hitObjects };
  }
  getMods() {
    return this.difficulty.mods;
  }
  setMods(mods) {
    const { general, editor, metadata, difficulty, events, timingPoints, colours, hitObjects } = this.parseBeatmap(mods);
    this.difficulty = difficulty;
    this.hitObjects = hitObjects;
  }
  getBackgroundFileNames() {
    const backgroundNames = [];
    this.events.events.forEach((event) => {
      if (event.eventType === "background") {
        backgroundNames.push(event.filename);
      }
    });
    return backgroundNames;
  }
  getAudioFilename() {
    return this.general.audioFilename;
  }
  getAssetsFilename() {
    const assets = [];
    assets.push(this.general.audioFilename);
    const customHitSamples = this.hitObjects.objects.filter((hitObject) => {
      var _a2;
      return (_a2 = hitObject.hitSample) == null ? void 0 : _a2.filename;
    }).map((hitObject) => hitObject.hitSample.filename);
    assets.push(...customHitSamples);
    this.events.events.forEach((event) => {
      if (event.eventType === "background") {
        assets.push(event.filename);
      } else if (event.eventType === "video") {
        assets.push(event.filename);
      }
    });
    return assets;
  }
}
const AppWidth = 1280;
const AppHeight = 720;
const AudioVolume = 0.2;
const AudioOffset = 0;
const AudioAutoSyncEnabled = true;
const AudioAutoSyncThresholdMS = 150;
const AudioAutoSyncDetectIssue = true;
var DEFAULT_SETTINGS = {
  AppWidth,
  AppHeight,
  AudioVolume,
  AudioOffset,
  AudioAutoSyncEnabled,
  AudioAutoSyncThresholdMS,
  AudioAutoSyncDetectIssue
};
class Settings {
  static addUpdateListener(key, listener) {
    if (this.listeners[key] === void 0) {
      this.listeners[key] = [];
    }
    this.listeners[key].push(listener);
  }
  static removeUpdateListener(key, listener) {
    if (this.listeners[key] === void 0) {
      return;
    }
    const index2 = this.listeners[key].findIndex((val) => val === listener);
    index2 > -1 && this.listeners[key].splice(index2, 1);
  }
  static set(key, value) {
    if (this._settings[key] === value) {
      return;
    }
    this._settings[key] = value;
    this.notify(key);
  }
  static get(key) {
    return this._settings[key];
  }
  static toString() {
    return JSON.stringify(this._settings);
  }
  static fromString(settings2) {
    const keys = Object.keys(this._settings);
    const newSettings = JSON.parse(settings2);
    for (const key of keys) {
      if (newSettings[key] === void 0) {
        continue;
      }
      this._settings[key] = newSettings[key];
    }
  }
  static notify(key) {
    if (this.listeners[key] === void 0) {
      return;
    }
    for (let listener of this.listeners[key]) {
      const value = this._settings[key];
      listener(value);
    }
  }
}
Settings._settings = DEFAULT_SETTINGS;
Settings.listeners = {};
class GameInstance {
  constructor(renderer, audioHandler) {
    this._rate = 1;
    this.isPlaying = false;
    this._autoSyncCount = 0;
    this._autoSyncLastTime = 0;
    this.averageTimeDiff = 0;
    this._setAppRate = () => {
    };
    this.renderer = renderer;
    this.audioHandler = audioHandler;
  }
  get rate() {
    return this._rate;
  }
  set rate(value) {
    var _a2;
    this._rate = value;
    (_a2 = this.beatmapAudio) == null ? void 0 : _a2.rate(value);
  }
  get time() {
    return this._time;
  }
  set time(time) {
    this._time = time;
    this.draw(time);
  }
  async loadBeatmap(beatmap) {
    this.beatmap = beatmap;
    this.handleMods(beatmap);
    await this.reloadAudio();
  }
  loadReplay(replay) {
    this.replay = replay;
  }
  play() {
    var _a2, _b2;
    this.isPlaying = true;
    (_a2 = this.beatmapAudio) == null ? void 0 : _a2.seek(this.time / 1e3);
    (_b2 = this.beatmapAudio) == null ? void 0 : _b2.play();
  }
  pause() {
    var _a2;
    this.isPlaying = false;
    (_a2 = this.beatmapAudio) == null ? void 0 : _a2.pause();
  }
  draw(time) {
    if (!this.beatmap)
      return;
    const hitObjects = this.beatmap.hitObjects.objects;
    for (let i = 0; i < hitObjects.length; i++) {
      if (hitObjects[i].isVisibleAt(time)) {
        hitObjects[i].draw(time);
      }
    }
    this._autoSync(time);
  }
  _autoSync(time) {
    var _a2;
    if (Settings.get("AudioAutoSyncEnabled") && document.hasFocus() && ((_a2 = this.beatmapAudio) == null ? void 0 : _a2.playing())) {
      const currTime = this.beatmapAudio.seek() * 1e3;
      const offset = Settings.get("AudioOffset");
      const timeDiff = currTime - offset - this.time;
      this.averageTimeDiff = (this.averageTimeDiff * this._autoSyncCount + timeDiff) / (this._autoSyncCount + 1);
      if (Math.abs(timeDiff) > Settings.get("AudioAutoSyncThresholdMS")) {
        this.beatmapAudio.seek(this.time / 1e3);
        if (Settings.get("AudioAutoSyncDetectIssue")) {
          this._autoSyncCount++;
          if (time - this._autoSyncLastTime > 500) {
            this._autoSyncCount = 0;
          }
          this._autoSyncLastTime = time;
        }
      }
    }
    if (this._autoSyncCount > 10) {
      console.warn("[Audio] Auto sync issue detected! Disabling audio auto sync!");
      Settings.set("AudioAutoSyncEnabled", false);
      this._autoSyncCount = 0;
    }
  }
  async reloadAudio() {
    var _a2, _b2, _c2, _d;
    if (!this.beatmap)
      return;
    const audioFilename = this.beatmap.getAudioFilename();
    (_a2 = this.beatmapAudio) == null ? void 0 : _a2.pause();
    this.beatmapAudio = await this.getAudioInstance(audioFilename);
    (_b2 = this.beatmapAudio) == null ? void 0 : _b2.seek(this.time / 1e3);
    (_c2 = this.beatmapAudio) == null ? void 0 : _c2.rate(this.rate);
    if (this.isPlaying) {
      (_d = this.beatmapAudio) == null ? void 0 : _d.play();
    }
  }
  handleMods(beatmap) {
    if (beatmap.getMods().hasSimilar(Mod.DoubleTime)) {
      this._setAppRate(1.5);
    } else if (beatmap.getMods().hasSimilar(Mod.HalfTime)) {
      this._setAppRate(0.75);
    }
  }
  async getAudioInstance(audioFilename) {
    var _a2, _b2, _c2;
    const mods = (_a2 = this.beatmap) == null ? void 0 : _a2.getMods();
    if ((mods == null ? void 0 : mods.contains(Mod.DoubleTime)) && !(mods == null ? void 0 : mods.contains(Mod.Nightcore)) || (mods == null ? void 0 : mods.contains(Mod.HalfTime))) {
      return await ((_b2 = this.audioHandler.getHTMLAudio(audioFilename)) == null ? void 0 : _b2.then((audio2) => audio2 == null ? void 0 : audio2.instance));
    }
    return (_c2 = this.audioHandler.find(audioFilename)) == null ? void 0 : _c2.instance;
  }
}
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(function(value) {
    return constructor.resolve(callback()).then(function() {
      return value;
    });
  }, function(reason) {
    return constructor.resolve(callback()).then(function() {
      return constructor.reject(reason);
    });
  });
}
function allSettled(arr) {
  var P = this;
  return new P(function(resolve2, reject2) {
    if (!(arr && typeof arr.length !== "undefined")) {
      return reject2(new TypeError(typeof arr + " " + arr + " is not iterable(cannot read property Symbol(Symbol.iterator))"));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0)
      return resolve2([]);
    var remaining = args.length;
    function res(i2, val) {
      if (val && (typeof val === "object" || typeof val === "function")) {
        var then = val.then;
        if (typeof then === "function") {
          then.call(val, function(val2) {
            res(i2, val2);
          }, function(e2) {
            args[i2] = { status: "rejected", reason: e2 };
            if (--remaining === 0) {
              resolve2(args);
            }
          });
          return;
        }
      }
      args[i2] = { status: "fulfilled", value: val };
      if (--remaining === 0) {
        resolve2(args);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
}
var setTimeoutFunc = setTimeout;
var setImmediateFunc = typeof setImmediate !== "undefined" ? setImmediate : null;
function isArray(x) {
  return Boolean(x && typeof x.length !== "undefined");
}
function noop() {
}
function bind(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}
function Promise$1(fn) {
  if (!(this instanceof Promise$1))
    throw new TypeError("Promises must be constructed via new");
  if (typeof fn !== "function")
    throw new TypeError("not a function");
  this._state = 0;
  this._handled = false;
  this._value = void 0;
  this._deferreds = [];
  doResolve(fn, this);
}
function handle(self2, deferred) {
  while (self2._state === 3) {
    self2 = self2._value;
  }
  if (self2._state === 0) {
    self2._deferreds.push(deferred);
    return;
  }
  self2._handled = true;
  Promise$1._immediateFn(function() {
    var cb = self2._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self2._state === 1 ? resolve$1 : reject)(deferred.promise, self2._value);
      return;
    }
    var ret;
    try {
      ret = cb(self2._value);
    } catch (e2) {
      reject(deferred.promise, e2);
      return;
    }
    resolve$1(deferred.promise, ret);
  });
}
function resolve$1(self2, newValue) {
  try {
    if (newValue === self2)
      throw new TypeError("A promise cannot be resolved with itself.");
    if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
      var then = newValue.then;
      if (newValue instanceof Promise$1) {
        self2._state = 3;
        self2._value = newValue;
        finale(self2);
        return;
      } else if (typeof then === "function") {
        doResolve(bind(then, newValue), self2);
        return;
      }
    }
    self2._state = 1;
    self2._value = newValue;
    finale(self2);
  } catch (e2) {
    reject(self2, e2);
  }
}
function reject(self2, newValue) {
  self2._state = 2;
  self2._value = newValue;
  finale(self2);
}
function finale(self2) {
  if (self2._state === 2 && self2._deferreds.length === 0) {
    Promise$1._immediateFn(function() {
      if (!self2._handled) {
        Promise$1._unhandledRejectionFn(self2._value);
      }
    });
  }
  for (var i = 0, len = self2._deferreds.length; i < len; i++) {
    handle(self2, self2._deferreds[i]);
  }
  self2._deferreds = null;
}
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
  this.onRejected = typeof onRejected === "function" ? onRejected : null;
  this.promise = promise;
}
function doResolve(fn, self2) {
  var done = false;
  try {
    fn(function(value) {
      if (done)
        return;
      done = true;
      resolve$1(self2, value);
    }, function(reason) {
      if (done)
        return;
      done = true;
      reject(self2, reason);
    });
  } catch (ex) {
    if (done)
      return;
    done = true;
    reject(self2, ex);
  }
}
Promise$1.prototype["catch"] = function(onRejected) {
  return this.then(null, onRejected);
};
Promise$1.prototype.then = function(onFulfilled, onRejected) {
  var prom = new this.constructor(noop);
  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};
Promise$1.prototype["finally"] = finallyConstructor;
Promise$1.all = function(arr) {
  return new Promise$1(function(resolve2, reject2) {
    if (!isArray(arr)) {
      return reject2(new TypeError("Promise.all accepts an array"));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0)
      return resolve2([]);
    var remaining = args.length;
    function res(i2, val) {
      try {
        if (val && (typeof val === "object" || typeof val === "function")) {
          var then = val.then;
          if (typeof then === "function") {
            then.call(val, function(val2) {
              res(i2, val2);
            }, reject2);
            return;
          }
        }
        args[i2] = val;
        if (--remaining === 0) {
          resolve2(args);
        }
      } catch (ex) {
        reject2(ex);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};
Promise$1.allSettled = allSettled;
Promise$1.resolve = function(value) {
  if (value && typeof value === "object" && value.constructor === Promise$1) {
    return value;
  }
  return new Promise$1(function(resolve2) {
    resolve2(value);
  });
};
Promise$1.reject = function(value) {
  return new Promise$1(function(resolve2, reject2) {
    reject2(value);
  });
};
Promise$1.race = function(arr) {
  return new Promise$1(function(resolve2, reject2) {
    if (!isArray(arr)) {
      return reject2(new TypeError("Promise.race accepts an array"));
    }
    for (var i = 0, len = arr.length; i < len; i++) {
      Promise$1.resolve(arr[i]).then(resolve2, reject2);
    }
  });
};
Promise$1._immediateFn = typeof setImmediateFunc === "function" && function(fn) {
  setImmediateFunc(fn);
} || function(fn) {
  setTimeoutFunc(fn, 0);
};
Promise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== "undefined" && console) {
    console.warn("Possible Unhandled Promise Rejection:", err);
  }
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
      return test2[n];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);
    for (var key in from) {
      if (hasOwnProperty$1.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to;
};
/*!
 * @pixi/polyfill - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/polyfill is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
if (!self.Promise) {
  self.Promise = Promise$1;
}
if (!Object.assign) {
  Object.assign = objectAssign;
}
var ONE_FRAME_TIME = 16;
if (!(Date.now && Date.prototype.getTime)) {
  Date.now = function now() {
    return new Date().getTime();
  };
}
if (!(self.performance && self.performance.now)) {
  var startTime_1 = Date.now();
  if (!self.performance) {
    self.performance = {};
  }
  self.performance.now = function() {
    return Date.now() - startTime_1;
  };
}
var lastTime = Date.now();
var vendors = ["ms", "moz", "webkit", "o"];
for (var x = 0; x < vendors.length && !self.requestAnimationFrame; ++x) {
  var p = vendors[x];
  self.requestAnimationFrame = self[p + "RequestAnimationFrame"];
  self.cancelAnimationFrame = self[p + "CancelAnimationFrame"] || self[p + "CancelRequestAnimationFrame"];
}
if (!self.requestAnimationFrame) {
  self.requestAnimationFrame = function(callback) {
    if (typeof callback !== "function") {
      throw new TypeError(callback + "is not a function");
    }
    var currentTime = Date.now();
    var delay = ONE_FRAME_TIME + lastTime - currentTime;
    if (delay < 0) {
      delay = 0;
    }
    lastTime = currentTime;
    return self.setTimeout(function() {
      lastTime = Date.now();
      callback(performance.now());
    }, delay);
  };
}
if (!self.cancelAnimationFrame) {
  self.cancelAnimationFrame = function(id) {
    return clearTimeout(id);
  };
}
if (!Math.sign) {
  Math.sign = function mathSign(x) {
    x = Number(x);
    if (x === 0 || isNaN(x)) {
      return x;
    }
    return x > 0 ? 1 : -1;
  };
}
if (!Number.isInteger) {
  Number.isInteger = function numberIsInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
}
if (!self.ArrayBuffer) {
  self.ArrayBuffer = Array;
}
if (!self.Float32Array) {
  self.Float32Array = Array;
}
if (!self.Uint32Array) {
  self.Uint32Array = Array;
}
if (!self.Uint16Array) {
  self.Uint16Array = Array;
}
if (!self.Uint8Array) {
  self.Uint8Array = Array;
}
if (!self.Int32Array) {
  self.Int32Array = Array;
}
var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = function(navigator2) {
  return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
};
function createMatch(userAgent) {
  return function(regex) {
    return regex.test(userAgent);
  };
}
function isMobile$1(param) {
  var nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  var userAgent = nav.userAgent;
  var tmp = userAgent.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  tmp = userAgent.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  var match = createMatch(userAgent);
  var result = {
    apple: {
      phone: match(appleIphone) && !match(windowsPhone),
      ipod: match(appleIpod),
      tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
      universal: match(appleUniversal),
      device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
    },
    amazon: {
      phone: match(amazonPhone),
      tablet: !match(amazonPhone) && match(amazonTablet),
      device: match(amazonPhone) || match(amazonTablet)
    },
    android: {
      phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
      tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
      device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
    },
    windows: {
      phone: match(windowsPhone),
      tablet: match(windowsTablet),
      device: match(windowsPhone) || match(windowsTablet)
    },
    other: {
      blackberry: match(otherBlackBerry),
      blackberry10: match(otherBlackBerry10),
      opera: match(otherOpera),
      firefox: match(otherFirefox),
      chrome: match(otherChrome),
      device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
/*!
 * @pixi/settings - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var isMobile = isMobile$1(self.navigator);
function maxRecommendedTextures(max) {
  var allowMax = true;
  if (isMobile.tablet || isMobile.phone) {
    if (isMobile.apple.device) {
      var match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (match) {
        var majorVersion = parseInt(match[1], 10);
        if (majorVersion < 11) {
          allowMax = false;
        }
      }
    }
    if (isMobile.android.device) {
      var match = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (match) {
        var majorVersion = parseInt(match[1], 10);
        if (majorVersion < 7) {
          allowMax = false;
        }
      }
    }
  }
  return allowMax ? max : 4;
}
function canUploadSameBuffer() {
  return !isMobile.apple.device;
}
/*!
 * @pixi/constants - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$4;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV$4 || (ENV$4 = {}));
var RENDERER_TYPE$4;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE$4 || (RENDERER_TYPE$4 = {}));
var BUFFER_BITS$4;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS$4 || (BUFFER_BITS$4 = {}));
var BLEND_MODES$4;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES$4 || (BLEND_MODES$4 = {}));
var DRAW_MODES$4;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$4 || (DRAW_MODES$4 = {}));
var FORMATS$4;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS$4 || (FORMATS$4 = {}));
var TARGETS$4;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$4 || (TARGETS$4 = {}));
var TYPES$4;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES$4 || (TYPES$4 = {}));
var SAMPLER_TYPES$4;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES$4 || (SAMPLER_TYPES$4 = {}));
var SCALE_MODES$4;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES$4 || (SCALE_MODES$4 = {}));
var WRAP_MODES$4;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$4 || (WRAP_MODES$4 = {}));
var MIPMAP_MODES$4;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES$4 || (MIPMAP_MODES$4 = {}));
var ALPHA_MODES$4;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$4 || (ALPHA_MODES$4 = {}));
var CLEAR_MODES$4;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES$4 || (CLEAR_MODES$4 = {}));
var GC_MODES$4;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES$4 || (GC_MODES$4 = {}));
var PRECISION$4;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION$4 || (PRECISION$4 = {}));
var MASK_TYPES$4;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES$4 || (MASK_TYPES$4 = {}));
var MSAA_QUALITY$4;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY$4 || (MSAA_QUALITY$4 = {}));
var BUFFER_TYPE$4;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$4 || (BUFFER_TYPE$4 = {}));
var settings = {
  MIPMAP_TEXTURES: MIPMAP_MODES$4.POW2,
  ANISOTROPIC_LEVEL: 0,
  RESOLUTION: 1,
  FILTER_RESOLUTION: 1,
  FILTER_MULTISAMPLE: MSAA_QUALITY$4.NONE,
  SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),
  SPRITE_BATCH_SIZE: 4096,
  RENDER_OPTIONS: {
    view: null,
    antialias: false,
    autoDensity: false,
    backgroundColor: 0,
    backgroundAlpha: 1,
    useContextAlpha: true,
    clearBeforeRender: true,
    preserveDrawingBuffer: false,
    width: 800,
    height: 600,
    legacy: false
  },
  GC_MODE: GC_MODES$4.AUTO,
  GC_MAX_IDLE: 60 * 60,
  GC_MAX_CHECK_COUNT: 60 * 10,
  WRAP_MODE: WRAP_MODES$4.CLAMP,
  SCALE_MODE: SCALE_MODES$4.LINEAR,
  PRECISION_VERTEX: PRECISION$4.HIGH,
  PRECISION_FRAGMENT: isMobile.apple.device ? PRECISION$4.HIGH : PRECISION$4.MEDIUM,
  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
  CREATE_IMAGE_BITMAP: false,
  ROUND_PIXELS: false
};
var eventemitter3 = { exports: {} };
(function(module) {
  var has = Object.prototype.hasOwnProperty, prefix = "~";
  function Events2() {
  }
  if (Object.create) {
    Events2.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events2().__proto__)
      prefix = false;
  }
  function EE(fn, context2, once) {
    this.fn = fn;
    this.context = context2;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context2, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context2 || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events2();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events2();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context2) {
    return addListener(this, event, fn, context2, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context2) {
    return addListener(this, event, fn, context2, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context2, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context2 && listeners[i].context !== context2) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events2();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3);
var EventEmitter = eventemitter3.exports;
var earcut$2 = { exports: {} };
earcut$2.exports = earcut;
earcut$2.exports.default = earcut;
function earcut(data, holeIndices, dim) {
  dim = dim || 2;
  var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev)
    return triangles;
  var minX, minY, maxX, maxY, x, y, invSize;
  if (hasHoles)
    outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
  if (data.length > 80 * dim) {
    minX = maxX = data[0];
    minY = maxY = data[1];
    for (var i = dim; i < outerLen; i += dim) {
      x = data[i];
      y = data[i + 1];
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 1 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
  return triangles;
}
function linkedList(data, start, end, dim, clockwise) {
  var i, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim)
      last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim)
      last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  var p = start, again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next)
        break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  var stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  var a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0)
    return false;
  var p = ear.next.next;
  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  var a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0)
    return false;
  var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
  var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  var p = ear.prevZ, n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  var p = start;
  do {
    var a = p.prev, b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim);
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  var a = start;
  do {
    var b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        var c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [], i, len, start, end, list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    outerNode = eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  var bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  var bridgeReverse = splitPolygon(bridge, hole);
  var filteredBridge = filterPoints(bridge, bridge.next);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return outerNode === bridge ? filteredBridge : outerNode;
}
function findHoleBridge(hole, outerNode) {
  var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        if (x === hx) {
          if (hy === p.y)
            return p;
          if (hy === p.next.y)
            return p.next;
        }
        m = p.x < p.next.x ? p : p.next;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m)
    return null;
  if (hx === qx)
    return m;
  var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan2;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan2 = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan2 < tanMin || tan2 === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan2;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  var p = start;
  do {
    if (p.z === null)
      p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  var i, p, q, e2, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e2 = p;
          p = p.nextZ;
          pSize--;
        } else {
          e2 = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e2;
        else
          list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y, minX, minY, invSize) {
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y = (y | y << 8) & 16711935;
  y = (y | y << 4) & 252645135;
  y = (y | y << 2) & 858993459;
  y = (y | y << 1) & 1431655765;
  return x | y << 1;
}
function getLeftmost(start) {
  var p = start, leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
      leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  var o1 = sign$1(area(p1, q1, p2));
  var o2 = sign$1(area(p1, q1, q2));
  var o3 = sign$1(area(p2, q2, p1));
  var o4 = sign$1(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign$1(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  var p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
      return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y, last) {
  var p = new Node(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ)
    p.prevZ.nextZ = p.nextZ;
  if (p.nextZ)
    p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
  this.i = i;
  this.x = x;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
earcut.deviation = function(data, holeIndices, dim, triangles) {
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
  if (hasHoles) {
    for (var i = 0, len = holeIndices.length; i < len; i++) {
      var start = holeIndices[i] * dim;
      var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      polygonArea -= Math.abs(signedArea(data, start, end, dim));
    }
  }
  var trianglesArea = 0;
  for (i = 0; i < triangles.length; i += 3) {
    var a = triangles[i] * dim;
    var b = triangles[i + 1] * dim;
    var c = triangles[i + 2] * dim;
    trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
  }
  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data, start, end, dim) {
  var sum = 0;
  for (var i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum;
}
earcut.flatten = function(data) {
  var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
  for (var i = 0; i < data.length; i++) {
    for (var j = 0; j < data[i].length; j++) {
      for (var d = 0; d < dim; d++)
        result.vertices.push(data[i][j][d]);
    }
    if (i > 0) {
      holeIndex += data[i - 1].length;
      result.holes.push(holeIndex);
    }
  }
  return result;
};
var earcut$1 = earcut$2.exports;
var punycode$1 = { exports: {} };
/*! https://mths.be/punycode v1.3.2 by @mathias */
(function(module, exports) {
  (function(root) {
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = module && !module.nodeType && module;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
      root = freeGlobal;
    }
    var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
    function error(type) {
      throw RangeError(errors[type]);
    }
    function map2(array, fn) {
      var length = array.length;
      var result = [];
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map2(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output = [], counter = 0, length = string.length, value, extra;
      while (counter < length) {
        value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    function ucs2encode(array) {
      return map2(array, function(value) {
        var output = "";
        if (value > 65535) {
          value -= 65536;
          output += stringFromCharCode(value >>> 10 & 1023 | 55296);
          value = 56320 | value & 1023;
        }
        output += stringFromCharCode(value);
        return output;
      }).join("");
    }
    function basicToDigit(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    }
    function digitToBasic(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    function adapt(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    }
    function decode2(input) {
      var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index2, oldi, w, k, digit, t, baseMinusT;
      basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
        for (oldi = i, w = 1, k = base; ; k += base) {
          if (index2 >= inputLength) {
            error("invalid-input");
          }
          digit = basicToDigit(input.charCodeAt(index2++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error("overflow");
          }
          i += digit * w;
          t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w *= baseMinusT;
        }
        out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return ucs2encode(output);
    }
    function encode2(input) {
      var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
      input = ucs2decode(input);
      inputLength = input.length;
      n = initialN;
      delta = 0;
      bias = initialBias;
      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      handledCPCount = basicLength = output.length;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        for (m = maxInt, j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < n && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue == n) {
            for (q = delta, k = base; ; k += base) {
              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              qMinusT = q - t;
              baseMinusT = base - t;
              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    }
    function toUnicode(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
      });
    }
    function toASCII(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
      });
    }
    punycode2 = {
      "version": "1.3.2",
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode2,
      "encode": encode2,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    if (freeExports && freeModule) {
      if (module.exports == freeExports) {
        freeModule.exports = punycode2;
      } else {
        for (key in punycode2) {
          punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
        }
      }
    } else {
      root.punycode = punycode2;
    }
  })(commonjsGlobal);
})(punycode$1, punycode$1.exports);
var util$1 = {
  isString: function(arg) {
    return typeof arg === "string";
  },
  isObject: function(arg) {
    return typeof arg === "object" && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};
var querystring$1 = {};
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var decode = function(qs, sep, eq, options) {
  sep = sep || "&";
  eq = eq || "=";
  var obj = {};
  if (typeof qs !== "string" || qs.length === 0) {
    return obj;
  }
  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1e3;
  if (options && typeof options.maxKeys === "number") {
    maxKeys = options.maxKeys;
  }
  var len = qs.length;
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }
  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = "";
    }
    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);
    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }
  return obj;
};
var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case "string":
      return v;
    case "boolean":
      return v ? "true" : "false";
    case "number":
      return isFinite(v) ? v : "";
    default:
      return "";
  }
};
var encode = function(obj, sep, eq, name) {
  sep = sep || "&";
  eq = eq || "=";
  if (obj === null) {
    obj = void 0;
  }
  if (typeof obj === "object") {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }
  if (!name)
    return "";
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};
querystring$1.decode = querystring$1.parse = decode;
querystring$1.encode = querystring$1.stringify = encode;
var punycode = punycode$1.exports;
var util = util$1;
var parse = urlParse;
var resolve = urlResolve;
var format = urlFormat;
function Url$1() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
  "javascript": true,
  "javascript:": true
}, hostlessProtocol = {
  "javascript": true,
  "javascript:": true
}, slashedProtocol = {
  "http": true,
  "https": true,
  "ftp": true,
  "gopher": true,
  "file": true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
}, querystring = querystring$1;
function urlParse(url2, parseQueryString, slashesDenoteHost) {
  if (url2 && util.isObject(url2) && url2 instanceof Url$1)
    return url2;
  var u = new Url$1();
  u.parse(url2, parseQueryString, slashesDenoteHost);
  return u;
}
Url$1.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url2)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
  }
  var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, "/");
  url2 = uSplit.join(splitter);
  var rest = url2;
  rest = rest.trim();
  if (!slashesDenoteHost && url2.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      return this;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    if (hostEnd === -1)
      hostEnd = rest.length;
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost();
    this.hostname = this.hostname || "";
    var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part)
          continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              newpart += "x";
            } else {
              newpart += part[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    } else {
      this.hostname = this.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      this.hostname = punycode.toASCII(this.hostname);
    }
    var p = this.port ? ":" + this.port : "";
    var h = this.hostname || "";
    this.host = h + p;
    this.href += this.host;
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== "/") {
        rest = "/" + rest;
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }
  var hash2 = rest.indexOf("#");
  if (hash2 !== -1) {
    this.hash = rest.substr(hash2);
    rest = rest.slice(0, hash2);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    this.search = "";
    this.query = {};
  }
  if (rest)
    this.pathname = rest;
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "/";
  }
  if (this.pathname || this.search) {
    var p = this.pathname || "";
    var s = this.search || "";
    this.path = p + s;
  }
  this.href = this.format();
  return this;
};
function urlFormat(obj) {
  if (util.isString(obj))
    obj = urlParse(obj);
  if (!(obj instanceof Url$1))
    return Url$1.prototype.format.call(obj);
  return obj.format();
}
Url$1.prototype.format = function() {
  var auth = this.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol = this.protocol || "", pathname = this.pathname || "", hash2 = this.hash || "", host = false, query = "";
  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
    if (this.port) {
      host += ":" + this.port;
    }
  }
  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }
  var search = this.search || query && "?" + query || "";
  if (protocol && protocol.substr(-1) !== ":")
    protocol += ":";
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname.charAt(0) !== "/")
      pathname = "/" + pathname;
  } else if (!host) {
    host = "";
  }
  if (hash2 && hash2.charAt(0) !== "#")
    hash2 = "#" + hash2;
  if (search && search.charAt(0) !== "?")
    search = "?" + search;
  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace("#", "%23");
  return protocol + host + pathname + search + hash2;
};
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
Url$1.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};
Url$1.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url$1();
    rel.parse(relative, false, true);
    relative = rel;
  }
  var result = new Url$1();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }
  result.hash = relative.hash;
  if (relative.href === "") {
    result.href = result.format();
    return result;
  }
  if (relative.slashes && !relative.protocol) {
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== "protocol")
        result[rkey] = relative[rkey];
    }
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = "/";
    }
    result.href = result.format();
    return result;
  }
  if (relative.protocol && relative.protocol !== result.protocol) {
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }
    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || "").split("/");
      while (relPath.length && !(relative.host = relPath.shift()))
        ;
      if (!relative.host)
        relative.host = "";
      if (!relative.hostname)
        relative.hostname = "";
      if (relPath[0] !== "")
        relPath.unshift("");
      if (relPath.length < 2)
        relPath.unshift("");
      result.pathname = relPath.join("/");
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || "";
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    if (result.pathname || result.search) {
      var p = result.pathname || "";
      var s = result.search || "";
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }
  var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
  if (psychotic) {
    result.hostname = "";
    result.port = null;
    if (result.host) {
      if (srcPath[0] === "")
        srcPath[0] = result.host;
      else
        srcPath.unshift(result.host);
    }
    result.host = "";
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === "")
          relPath[0] = relative.host;
        else
          relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
  }
  if (isRelAbs) {
    result.host = relative.host || relative.host === "" ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
  } else if (relPath.length) {
    if (!srcPath)
      srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.href = result.format();
    return result;
  }
  if (!srcPath.length) {
    result.pathname = null;
    if (result.search) {
      result.path = "/" + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === ".") {
      srcPath.splice(i, 1);
    } else if (last === "..") {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift("..");
    }
  }
  if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
    srcPath.unshift("");
  }
  if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
    srcPath.push("");
  }
  var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }
  mustEndAbs = mustEndAbs || result.host && srcPath.length;
  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift("");
  }
  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join("/");
  }
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};
Url$1.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host)
    this.hostname = host;
};
/*!
 * @pixi/constants - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$3;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV$3 || (ENV$3 = {}));
var RENDERER_TYPE$3;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE$3 || (RENDERER_TYPE$3 = {}));
var BUFFER_BITS$3;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS$3 || (BUFFER_BITS$3 = {}));
var BLEND_MODES$3;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES$3 || (BLEND_MODES$3 = {}));
var DRAW_MODES$3;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$3 || (DRAW_MODES$3 = {}));
var FORMATS$3;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS$3 || (FORMATS$3 = {}));
var TARGETS$3;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$3 || (TARGETS$3 = {}));
var TYPES$3;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES$3 || (TYPES$3 = {}));
var SAMPLER_TYPES$3;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES$3 || (SAMPLER_TYPES$3 = {}));
var SCALE_MODES$3;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES$3 || (SCALE_MODES$3 = {}));
var WRAP_MODES$3;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$3 || (WRAP_MODES$3 = {}));
var MIPMAP_MODES$3;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES$3 || (MIPMAP_MODES$3 = {}));
var ALPHA_MODES$3;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$3 || (ALPHA_MODES$3 = {}));
var CLEAR_MODES$3;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES$3 || (CLEAR_MODES$3 = {}));
var GC_MODES$3;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES$3 || (GC_MODES$3 = {}));
var PRECISION$3;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION$3 || (PRECISION$3 = {}));
var MASK_TYPES$3;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES$3 || (MASK_TYPES$3 = {}));
var MSAA_QUALITY$3;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY$3 || (MSAA_QUALITY$3 = {}));
var BUFFER_TYPE$3;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$3 || (BUFFER_TYPE$3 = {}));
/*!
 * @pixi/utils - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/utils is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var url = {
  parse,
  format,
  resolve
};
settings.RETINA_PREFIX = /@([0-9\.]+)x/;
settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
var saidHello = false;
var VERSION = "6.2.2";
function sayHello(type) {
  var _a2;
  if (saidHello) {
    return;
  }
  if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
    var args = [
      "\n %c %c %c PixiJS " + VERSION + " - \u2730 " + type + " \u2730  %c  %c  http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 \n\n",
      "background: #ff66a5; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "color: #ff66a5; background: #030307; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "background: #ffc3dc; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;"
    ];
    (_a2 = self.console).log.apply(_a2, args);
  } else if (self.console) {
    self.console.log("PixiJS " + VERSION + " - " + type + " - http://www.pixijs.com/");
  }
  saidHello = true;
}
var supported;
function isWebGLSupported() {
  if (typeof supported === "undefined") {
    supported = function supported2() {
      var contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
      };
      try {
        if (!self.WebGLRenderingContext) {
          return false;
        }
        var canvas2 = document.createElement("canvas");
        var gl = canvas2.getContext("webgl", contextOptions) || canvas2.getContext("experimental-webgl", contextOptions);
        var success = !!(gl && gl.getContextAttributes().stencil);
        if (gl) {
          var loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e2) {
        return false;
      }
    }();
  }
  return supported;
}
var aliceblue = "#f0f8ff";
var antiquewhite = "#faebd7";
var aqua = "#00ffff";
var aquamarine = "#7fffd4";
var azure = "#f0ffff";
var beige = "#f5f5dc";
var bisque = "#ffe4c4";
var black = "#000000";
var blanchedalmond = "#ffebcd";
var blue = "#0000ff";
var blueviolet = "#8a2be2";
var brown = "#a52a2a";
var burlywood = "#deb887";
var cadetblue = "#5f9ea0";
var chartreuse = "#7fff00";
var chocolate = "#d2691e";
var coral = "#ff7f50";
var cornflowerblue = "#6495ed";
var cornsilk = "#fff8dc";
var crimson = "#dc143c";
var cyan = "#00ffff";
var darkblue = "#00008b";
var darkcyan = "#008b8b";
var darkgoldenrod = "#b8860b";
var darkgray = "#a9a9a9";
var darkgreen = "#006400";
var darkgrey = "#a9a9a9";
var darkkhaki = "#bdb76b";
var darkmagenta = "#8b008b";
var darkolivegreen = "#556b2f";
var darkorange = "#ff8c00";
var darkorchid = "#9932cc";
var darkred = "#8b0000";
var darksalmon = "#e9967a";
var darkseagreen = "#8fbc8f";
var darkslateblue = "#483d8b";
var darkslategray = "#2f4f4f";
var darkslategrey = "#2f4f4f";
var darkturquoise = "#00ced1";
var darkviolet = "#9400d3";
var deeppink = "#ff1493";
var deepskyblue = "#00bfff";
var dimgray = "#696969";
var dimgrey = "#696969";
var dodgerblue = "#1e90ff";
var firebrick = "#b22222";
var floralwhite = "#fffaf0";
var forestgreen = "#228b22";
var fuchsia = "#ff00ff";
var gainsboro = "#dcdcdc";
var ghostwhite = "#f8f8ff";
var goldenrod = "#daa520";
var gold = "#ffd700";
var gray = "#808080";
var green = "#008000";
var greenyellow = "#adff2f";
var grey = "#808080";
var honeydew = "#f0fff0";
var hotpink = "#ff69b4";
var indianred = "#cd5c5c";
var indigo = "#4b0082";
var ivory = "#fffff0";
var khaki = "#f0e68c";
var lavenderblush = "#fff0f5";
var lavender = "#e6e6fa";
var lawngreen = "#7cfc00";
var lemonchiffon = "#fffacd";
var lightblue = "#add8e6";
var lightcoral = "#f08080";
var lightcyan = "#e0ffff";
var lightgoldenrodyellow = "#fafad2";
var lightgray = "#d3d3d3";
var lightgreen = "#90ee90";
var lightgrey = "#d3d3d3";
var lightpink = "#ffb6c1";
var lightsalmon = "#ffa07a";
var lightseagreen = "#20b2aa";
var lightskyblue = "#87cefa";
var lightslategray = "#778899";
var lightslategrey = "#778899";
var lightsteelblue = "#b0c4de";
var lightyellow = "#ffffe0";
var lime = "#00ff00";
var limegreen = "#32cd32";
var linen = "#faf0e6";
var magenta = "#ff00ff";
var maroon = "#800000";
var mediumaquamarine = "#66cdaa";
var mediumblue = "#0000cd";
var mediumorchid = "#ba55d3";
var mediumpurple = "#9370db";
var mediumseagreen = "#3cb371";
var mediumslateblue = "#7b68ee";
var mediumspringgreen = "#00fa9a";
var mediumturquoise = "#48d1cc";
var mediumvioletred = "#c71585";
var midnightblue = "#191970";
var mintcream = "#f5fffa";
var mistyrose = "#ffe4e1";
var moccasin = "#ffe4b5";
var navajowhite = "#ffdead";
var navy = "#000080";
var oldlace = "#fdf5e6";
var olive = "#808000";
var olivedrab = "#6b8e23";
var orange = "#ffa500";
var orangered = "#ff4500";
var orchid = "#da70d6";
var palegoldenrod = "#eee8aa";
var palegreen = "#98fb98";
var paleturquoise = "#afeeee";
var palevioletred = "#db7093";
var papayawhip = "#ffefd5";
var peachpuff = "#ffdab9";
var peru = "#cd853f";
var pink = "#ffc0cb";
var plum = "#dda0dd";
var powderblue = "#b0e0e6";
var purple = "#800080";
var rebeccapurple = "#663399";
var red = "#ff0000";
var rosybrown = "#bc8f8f";
var royalblue = "#4169e1";
var saddlebrown = "#8b4513";
var salmon = "#fa8072";
var sandybrown = "#f4a460";
var seagreen = "#2e8b57";
var seashell = "#fff5ee";
var sienna = "#a0522d";
var silver = "#c0c0c0";
var skyblue = "#87ceeb";
var slateblue = "#6a5acd";
var slategray = "#708090";
var slategrey = "#708090";
var snow = "#fffafa";
var springgreen = "#00ff7f";
var steelblue = "#4682b4";
var tan = "#d2b48c";
var teal = "#008080";
var thistle = "#d8bfd8";
var tomato = "#ff6347";
var turquoise = "#40e0d0";
var violet = "#ee82ee";
var wheat = "#f5deb3";
var white = "#ffffff";
var whitesmoke = "#f5f5f5";
var yellow = "#ffff00";
var yellowgreen = "#9acd32";
var cssColorNames = {
  aliceblue,
  antiquewhite,
  aqua,
  aquamarine,
  azure,
  beige,
  bisque,
  black,
  blanchedalmond,
  blue,
  blueviolet,
  brown,
  burlywood,
  cadetblue,
  chartreuse,
  chocolate,
  coral,
  cornflowerblue,
  cornsilk,
  crimson,
  cyan,
  darkblue,
  darkcyan,
  darkgoldenrod,
  darkgray,
  darkgreen,
  darkgrey,
  darkkhaki,
  darkmagenta,
  darkolivegreen,
  darkorange,
  darkorchid,
  darkred,
  darksalmon,
  darkseagreen,
  darkslateblue,
  darkslategray,
  darkslategrey,
  darkturquoise,
  darkviolet,
  deeppink,
  deepskyblue,
  dimgray,
  dimgrey,
  dodgerblue,
  firebrick,
  floralwhite,
  forestgreen,
  fuchsia,
  gainsboro,
  ghostwhite,
  goldenrod,
  gold,
  gray,
  green,
  greenyellow,
  grey,
  honeydew,
  hotpink,
  indianred,
  indigo,
  ivory,
  khaki,
  lavenderblush,
  lavender,
  lawngreen,
  lemonchiffon,
  lightblue,
  lightcoral,
  lightcyan,
  lightgoldenrodyellow,
  lightgray,
  lightgreen,
  lightgrey,
  lightpink,
  lightsalmon,
  lightseagreen,
  lightskyblue,
  lightslategray,
  lightslategrey,
  lightsteelblue,
  lightyellow,
  lime,
  limegreen,
  linen,
  magenta,
  maroon,
  mediumaquamarine,
  mediumblue,
  mediumorchid,
  mediumpurple,
  mediumseagreen,
  mediumslateblue,
  mediumspringgreen,
  mediumturquoise,
  mediumvioletred,
  midnightblue,
  mintcream,
  mistyrose,
  moccasin,
  navajowhite,
  navy,
  oldlace,
  olive,
  olivedrab,
  orange,
  orangered,
  orchid,
  palegoldenrod,
  palegreen,
  paleturquoise,
  palevioletred,
  papayawhip,
  peachpuff,
  peru,
  pink,
  plum,
  powderblue,
  purple,
  rebeccapurple,
  red,
  rosybrown,
  royalblue,
  saddlebrown,
  salmon,
  sandybrown,
  seagreen,
  seashell,
  sienna,
  silver,
  skyblue,
  slateblue,
  slategray,
  slategrey,
  snow,
  springgreen,
  steelblue,
  tan,
  teal,
  thistle,
  tomato,
  turquoise,
  violet,
  wheat,
  white,
  whitesmoke,
  yellow,
  yellowgreen
};
function hex2rgb(hex, out) {
  if (out === void 0) {
    out = [];
  }
  out[0] = (hex >> 16 & 255) / 255;
  out[1] = (hex >> 8 & 255) / 255;
  out[2] = (hex & 255) / 255;
  return out;
}
function hex2string(hex) {
  var hexString = hex.toString(16);
  hexString = "000000".substr(0, 6 - hexString.length) + hexString;
  return "#" + hexString;
}
function string2hex(string) {
  if (typeof string === "string") {
    string = cssColorNames[string.toLowerCase()] || string;
    if (string[0] === "#") {
      string = string.substr(1);
    }
  }
  return parseInt(string, 16);
}
function mapPremultipliedBlendModes() {
  var pm = [];
  var npm = [];
  for (var i = 0; i < 32; i++) {
    pm[i] = i;
    npm[i] = i;
  }
  pm[BLEND_MODES$3.NORMAL_NPM] = BLEND_MODES$3.NORMAL;
  pm[BLEND_MODES$3.ADD_NPM] = BLEND_MODES$3.ADD;
  pm[BLEND_MODES$3.SCREEN_NPM] = BLEND_MODES$3.SCREEN;
  npm[BLEND_MODES$3.NORMAL] = BLEND_MODES$3.NORMAL_NPM;
  npm[BLEND_MODES$3.ADD] = BLEND_MODES$3.ADD_NPM;
  npm[BLEND_MODES$3.SCREEN] = BLEND_MODES$3.SCREEN_NPM;
  var array = [];
  array.push(npm);
  array.push(pm);
  return array;
}
var premultiplyBlendMode = mapPremultipliedBlendModes();
function correctBlendMode(blendMode, premultiplied) {
  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
}
function premultiplyRgba(rgb, alpha, out, premultiply) {
  out = out || new Float32Array(4);
  if (premultiply || premultiply === void 0) {
    out[0] = rgb[0] * alpha;
    out[1] = rgb[1] * alpha;
    out[2] = rgb[2] * alpha;
  } else {
    out[0] = rgb[0];
    out[1] = rgb[1];
    out[2] = rgb[2];
  }
  out[3] = alpha;
  return out;
}
function premultiplyTint(tint, alpha) {
  if (alpha === 1) {
    return (alpha * 255 << 24) + tint;
  }
  if (alpha === 0) {
    return 0;
  }
  var R = tint >> 16 & 255;
  var G = tint >> 8 & 255;
  var B = tint & 255;
  R = R * alpha + 0.5 | 0;
  G = G * alpha + 0.5 | 0;
  B = B * alpha + 0.5 | 0;
  return (alpha * 255 << 24) + (R << 16) + (G << 8) + B;
}
function premultiplyTintToRgba(tint, alpha, out, premultiply) {
  out = out || new Float32Array(4);
  out[0] = (tint >> 16 & 255) / 255;
  out[1] = (tint >> 8 & 255) / 255;
  out[2] = (tint & 255) / 255;
  if (premultiply || premultiply === void 0) {
    out[0] *= alpha;
    out[1] *= alpha;
    out[2] *= alpha;
  }
  out[3] = alpha;
  return out;
}
function createIndicesForQuads(size, outBuffer) {
  if (outBuffer === void 0) {
    outBuffer = null;
  }
  var totalIndices = size * 6;
  outBuffer = outBuffer || new Uint16Array(totalIndices);
  if (outBuffer.length !== totalIndices) {
    throw new Error("Out buffer length is incorrect, got " + outBuffer.length + " and expected " + totalIndices);
  }
  for (var i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
    outBuffer[i + 0] = j + 0;
    outBuffer[i + 1] = j + 1;
    outBuffer[i + 2] = j + 2;
    outBuffer[i + 3] = j + 0;
    outBuffer[i + 4] = j + 2;
    outBuffer[i + 5] = j + 3;
  }
  return outBuffer;
}
function getBufferType(array) {
  if (array.BYTES_PER_ELEMENT === 4) {
    if (array instanceof Float32Array) {
      return "Float32Array";
    } else if (array instanceof Uint32Array) {
      return "Uint32Array";
    }
    return "Int32Array";
  } else if (array.BYTES_PER_ELEMENT === 2) {
    if (array instanceof Uint16Array) {
      return "Uint16Array";
    }
  } else if (array.BYTES_PER_ELEMENT === 1) {
    if (array instanceof Uint8Array) {
      return "Uint8Array";
    }
  }
  return null;
}
function nextPow2(v) {
  v += v === 0 ? 1 : 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}
function isPow2(v) {
  return !(v & v - 1) && !!v;
}
function log2(v) {
  var r = (v > 65535 ? 1 : 0) << 4;
  v >>>= r;
  var shift = (v > 255 ? 1 : 0) << 3;
  v >>>= shift;
  r |= shift;
  shift = (v > 15 ? 1 : 0) << 2;
  v >>>= shift;
  r |= shift;
  shift = (v > 3 ? 1 : 0) << 1;
  v >>>= shift;
  r |= shift;
  return r | v >> 1;
}
function removeItems(arr, startIdx, removeCount) {
  var length = arr.length;
  var i;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  var len = length - removeCount;
  for (i = startIdx; i < len; ++i) {
    arr[i] = arr[i + removeCount];
  }
  arr.length = len;
}
function sign(n) {
  if (n === 0) {
    return 0;
  }
  return n < 0 ? -1 : 1;
}
var nextUid = 0;
function uid() {
  return ++nextUid;
}
var warnings = {};
function deprecation(version, message, ignoreDepth) {
  if (ignoreDepth === void 0) {
    ignoreDepth = 3;
  }
  if (warnings[message]) {
    return;
  }
  var stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", message + "\nDeprecated since v" + version);
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
      console.warn(stack);
    }
  }
  warnings[message] = true;
}
var ProgramCache = {};
var TextureCache = /* @__PURE__ */ Object.create(null);
var BaseTextureCache = /* @__PURE__ */ Object.create(null);
function clearTextureCache() {
  var key;
  for (key in TextureCache) {
    delete TextureCache[key];
  }
  for (key in BaseTextureCache) {
    delete BaseTextureCache[key];
  }
}
var CanvasRenderTarget = function() {
  function CanvasRenderTarget2(width, height, resolution) {
    this.canvas = document.createElement("canvas");
    this.context = this.canvas.getContext("2d");
    this.resolution = resolution || settings.RESOLUTION;
    this.resize(width, height);
  }
  CanvasRenderTarget2.prototype.clear = function() {
    this.context.setTransform(1, 0, 0, 1, 0, 0);
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  };
  CanvasRenderTarget2.prototype.resize = function(desiredWidth, desiredHeight) {
    this.canvas.width = Math.round(desiredWidth * this.resolution);
    this.canvas.height = Math.round(desiredHeight * this.resolution);
  };
  CanvasRenderTarget2.prototype.destroy = function() {
    this.context = null;
    this.canvas = null;
  };
  Object.defineProperty(CanvasRenderTarget2.prototype, "width", {
    get: function() {
      return this.canvas.width;
    },
    set: function(val) {
      this.canvas.width = Math.round(val);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CanvasRenderTarget2.prototype, "height", {
    get: function() {
      return this.canvas.height;
    },
    set: function(val) {
      this.canvas.height = Math.round(val);
    },
    enumerable: false,
    configurable: true
  });
  return CanvasRenderTarget2;
}();
function trimCanvas(canvas2) {
  var width = canvas2.width;
  var height = canvas2.height;
  var context2 = canvas2.getContext("2d");
  var imageData = context2.getImageData(0, 0, width, height);
  var pixels = imageData.data;
  var len = pixels.length;
  var bound = {
    top: null,
    left: null,
    right: null,
    bottom: null
  };
  var data = null;
  var i;
  var x;
  var y;
  for (i = 0; i < len; i += 4) {
    if (pixels[i + 3] !== 0) {
      x = i / 4 % width;
      y = ~~(i / 4 / width);
      if (bound.top === null) {
        bound.top = y;
      }
      if (bound.left === null) {
        bound.left = x;
      } else if (x < bound.left) {
        bound.left = x;
      }
      if (bound.right === null) {
        bound.right = x + 1;
      } else if (bound.right < x) {
        bound.right = x + 1;
      }
      if (bound.bottom === null) {
        bound.bottom = y;
      } else if (bound.bottom < y) {
        bound.bottom = y;
      }
    }
  }
  if (bound.top !== null) {
    width = bound.right - bound.left;
    height = bound.bottom - bound.top + 1;
    data = context2.getImageData(bound.left, bound.top, width, height);
  }
  return {
    height,
    width,
    data
  };
}
var tempAnchor$1;
function determineCrossOrigin(url$1, loc) {
  if (loc === void 0) {
    loc = self.location;
  }
  if (url$1.indexOf("data:") === 0) {
    return "";
  }
  loc = loc || self.location;
  if (!tempAnchor$1) {
    tempAnchor$1 = document.createElement("a");
  }
  tempAnchor$1.href = url$1;
  var parsedUrl = url.parse(tempAnchor$1.href);
  var samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
  if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}
function getResolutionOfUrl(url2, defaultValue2) {
  var resolution = settings.RETINA_PREFIX.exec(url2);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue2 !== void 0 ? defaultValue2 : 1;
}
/*!
 * @pixi/math - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var PI_2 = Math.PI * 2;
var RAD_TO_DEG = 180 / Math.PI;
var DEG_TO_RAD = Math.PI / 180;
var SHAPES;
(function(SHAPES2) {
  SHAPES2[SHAPES2["POLY"] = 0] = "POLY";
  SHAPES2[SHAPES2["RECT"] = 1] = "RECT";
  SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";
  SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";
  SHAPES2[SHAPES2["RREC"] = 4] = "RREC";
})(SHAPES || (SHAPES = {}));
var Rectangle = function() {
  function Rectangle2(x, y, width, height) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    this.x = Number(x);
    this.y = Number(y);
    this.width = Number(width);
    this.height = Number(height);
    this.type = SHAPES.RECT;
  }
  Object.defineProperty(Rectangle2.prototype, "left", {
    get: function() {
      return this.x;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Rectangle2.prototype, "right", {
    get: function() {
      return this.x + this.width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Rectangle2.prototype, "top", {
    get: function() {
      return this.y;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Rectangle2.prototype, "bottom", {
    get: function() {
      return this.y + this.height;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Rectangle2, "EMPTY", {
    get: function() {
      return new Rectangle2(0, 0, 0, 0);
    },
    enumerable: false,
    configurable: true
  });
  Rectangle2.prototype.clone = function() {
    return new Rectangle2(this.x, this.y, this.width, this.height);
  };
  Rectangle2.prototype.copyFrom = function(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  };
  Rectangle2.prototype.copyTo = function(rectangle) {
    rectangle.x = this.x;
    rectangle.y = this.y;
    rectangle.width = this.width;
    rectangle.height = this.height;
    return rectangle;
  };
  Rectangle2.prototype.contains = function(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x >= this.x && x < this.x + this.width) {
      if (y >= this.y && y < this.y + this.height) {
        return true;
      }
    }
    return false;
  };
  Rectangle2.prototype.pad = function(paddingX, paddingY) {
    if (paddingX === void 0) {
      paddingX = 0;
    }
    if (paddingY === void 0) {
      paddingY = paddingX;
    }
    this.x -= paddingX;
    this.y -= paddingY;
    this.width += paddingX * 2;
    this.height += paddingY * 2;
    return this;
  };
  Rectangle2.prototype.fit = function(rectangle) {
    var x1 = Math.max(this.x, rectangle.x);
    var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
    var y1 = Math.max(this.y, rectangle.y);
    var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = Math.max(x2 - x1, 0);
    this.y = y1;
    this.height = Math.max(y2 - y1, 0);
    return this;
  };
  Rectangle2.prototype.ceil = function(resolution, eps) {
    if (resolution === void 0) {
      resolution = 1;
    }
    if (eps === void 0) {
      eps = 1e-3;
    }
    var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
    var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
    this.x = Math.floor((this.x + eps) * resolution) / resolution;
    this.y = Math.floor((this.y + eps) * resolution) / resolution;
    this.width = x2 - this.x;
    this.height = y2 - this.y;
    return this;
  };
  Rectangle2.prototype.enlarge = function(rectangle) {
    var x1 = Math.min(this.x, rectangle.x);
    var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
    var y1 = Math.min(this.y, rectangle.y);
    var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = x2 - x1;
    this.y = y1;
    this.height = y2 - y1;
    return this;
  };
  Rectangle2.prototype.toString = function() {
    return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
  };
  return Rectangle2;
}();
var Circle = function() {
  function Circle2(x, y, radius) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (radius === void 0) {
      radius = 0;
    }
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.type = SHAPES.CIRC;
  }
  Circle2.prototype.clone = function() {
    return new Circle2(this.x, this.y, this.radius);
  };
  Circle2.prototype.contains = function(x, y) {
    if (this.radius <= 0) {
      return false;
    }
    var r2 = this.radius * this.radius;
    var dx = this.x - x;
    var dy = this.y - y;
    dx *= dx;
    dy *= dy;
    return dx + dy <= r2;
  };
  Circle2.prototype.getBounds = function() {
    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  };
  Circle2.prototype.toString = function() {
    return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]";
  };
  return Circle2;
}();
var Ellipse = function() {
  function Ellipse2(x, y, halfWidth, halfHeight) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (halfWidth === void 0) {
      halfWidth = 0;
    }
    if (halfHeight === void 0) {
      halfHeight = 0;
    }
    this.x = x;
    this.y = y;
    this.width = halfWidth;
    this.height = halfHeight;
    this.type = SHAPES.ELIP;
  }
  Ellipse2.prototype.clone = function() {
    return new Ellipse2(this.x, this.y, this.width, this.height);
  };
  Ellipse2.prototype.contains = function(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    var normx = (x - this.x) / this.width;
    var normy = (y - this.y) / this.height;
    normx *= normx;
    normy *= normy;
    return normx + normy <= 1;
  };
  Ellipse2.prototype.getBounds = function() {
    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
  };
  Ellipse2.prototype.toString = function() {
    return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
  };
  return Ellipse2;
}();
var Polygon = function() {
  function Polygon2() {
    var arguments$1 = arguments;
    var points = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      points[_i] = arguments$1[_i];
    }
    var flat = Array.isArray(points[0]) ? points[0] : points;
    if (typeof flat[0] !== "number") {
      var p = [];
      for (var i = 0, il = flat.length; i < il; i++) {
        p.push(flat[i].x, flat[i].y);
      }
      flat = p;
    }
    this.points = flat;
    this.type = SHAPES.POLY;
    this.closeStroke = true;
  }
  Polygon2.prototype.clone = function() {
    var points = this.points.slice();
    var polygon = new Polygon2(points);
    polygon.closeStroke = this.closeStroke;
    return polygon;
  };
  Polygon2.prototype.contains = function(x, y) {
    var inside = false;
    var length = this.points.length / 2;
    for (var i = 0, j = length - 1; i < length; j = i++) {
      var xi = this.points[i * 2];
      var yi = this.points[i * 2 + 1];
      var xj = this.points[j * 2];
      var yj = this.points[j * 2 + 1];
      var intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;
      if (intersect) {
        inside = !inside;
      }
    }
    return inside;
  };
  Polygon2.prototype.toString = function() {
    return "[@pixi/math:Polygon" + ("closeStroke=" + this.closeStroke) + ("points=" + this.points.reduce(function(pointsDesc, currentPoint) {
      return pointsDesc + ", " + currentPoint;
    }, "") + "]");
  };
  return Polygon2;
}();
var RoundedRectangle = function() {
  function RoundedRectangle2(x, y, width, height, radius) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    if (radius === void 0) {
      radius = 20;
    }
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.radius = radius;
    this.type = SHAPES.RREC;
  }
  RoundedRectangle2.prototype.clone = function() {
    return new RoundedRectangle2(this.x, this.y, this.width, this.height, this.radius);
  };
  RoundedRectangle2.prototype.contains = function(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x >= this.x && x <= this.x + this.width) {
      if (y >= this.y && y <= this.y + this.height) {
        var radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {
          return true;
        }
        var dx = x - (this.x + radius);
        var dy = y - (this.y + radius);
        var radius2 = radius * radius;
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x - (this.x + this.width - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dy = y - (this.y + this.height - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x - (this.x + radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
      }
    }
    return false;
  };
  RoundedRectangle2.prototype.toString = function() {
    return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + ("width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]");
  };
  return RoundedRectangle2;
}();
var Point = function() {
  function Point2(x, y) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    this.x = 0;
    this.y = 0;
    this.x = x;
    this.y = y;
  }
  Point2.prototype.clone = function() {
    return new Point2(this.x, this.y);
  };
  Point2.prototype.copyFrom = function(p) {
    this.set(p.x, p.y);
    return this;
  };
  Point2.prototype.copyTo = function(p) {
    p.set(this.x, this.y);
    return p;
  };
  Point2.prototype.equals = function(p) {
    return p.x === this.x && p.y === this.y;
  };
  Point2.prototype.set = function(x, y) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = x;
    }
    this.x = x;
    this.y = y;
    return this;
  };
  Point2.prototype.toString = function() {
    return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
  };
  return Point2;
}();
var ObservablePoint = function() {
  function ObservablePoint2(cb, scope, x, y) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    this._x = x;
    this._y = y;
    this.cb = cb;
    this.scope = scope;
  }
  ObservablePoint2.prototype.clone = function(cb, scope) {
    if (cb === void 0) {
      cb = this.cb;
    }
    if (scope === void 0) {
      scope = this.scope;
    }
    return new ObservablePoint2(cb, scope, this._x, this._y);
  };
  ObservablePoint2.prototype.set = function(x, y) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = x;
    }
    if (this._x !== x || this._y !== y) {
      this._x = x;
      this._y = y;
      this.cb.call(this.scope);
    }
    return this;
  };
  ObservablePoint2.prototype.copyFrom = function(p) {
    if (this._x !== p.x || this._y !== p.y) {
      this._x = p.x;
      this._y = p.y;
      this.cb.call(this.scope);
    }
    return this;
  };
  ObservablePoint2.prototype.copyTo = function(p) {
    p.set(this._x, this._y);
    return p;
  };
  ObservablePoint2.prototype.equals = function(p) {
    return p.x === this._x && p.y === this._y;
  };
  ObservablePoint2.prototype.toString = function() {
    return "[@pixi/math:ObservablePoint x=" + 0 + " y=" + 0 + " scope=" + this.scope + "]";
  };
  Object.defineProperty(ObservablePoint2.prototype, "x", {
    get: function() {
      return this._x;
    },
    set: function(value) {
      if (this._x !== value) {
        this._x = value;
        this.cb.call(this.scope);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ObservablePoint2.prototype, "y", {
    get: function() {
      return this._y;
    },
    set: function(value) {
      if (this._y !== value) {
        this._y = value;
        this.cb.call(this.scope);
      }
    },
    enumerable: false,
    configurable: true
  });
  return ObservablePoint2;
}();
var Matrix = function() {
  function Matrix2(a, b, c, d, tx, ty) {
    if (a === void 0) {
      a = 1;
    }
    if (b === void 0) {
      b = 0;
    }
    if (c === void 0) {
      c = 0;
    }
    if (d === void 0) {
      d = 1;
    }
    if (tx === void 0) {
      tx = 0;
    }
    if (ty === void 0) {
      ty = 0;
    }
    this.array = null;
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
  }
  Matrix2.prototype.fromArray = function(array) {
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
  };
  Matrix2.prototype.set = function(a, b, c, d, tx, ty) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
    return this;
  };
  Matrix2.prototype.toArray = function(transpose, out) {
    if (!this.array) {
      this.array = new Float32Array(9);
    }
    var array = out || this.array;
    if (transpose) {
      array[0] = this.a;
      array[1] = this.b;
      array[2] = 0;
      array[3] = this.c;
      array[4] = this.d;
      array[5] = 0;
      array[6] = this.tx;
      array[7] = this.ty;
      array[8] = 1;
    } else {
      array[0] = this.a;
      array[1] = this.c;
      array[2] = this.tx;
      array[3] = this.b;
      array[4] = this.d;
      array[5] = this.ty;
      array[6] = 0;
      array[7] = 0;
      array[8] = 1;
    }
    return array;
  };
  Matrix2.prototype.apply = function(pos, newPos) {
    newPos = newPos || new Point();
    var x = pos.x;
    var y = pos.y;
    newPos.x = this.a * x + this.c * y + this.tx;
    newPos.y = this.b * x + this.d * y + this.ty;
    return newPos;
  };
  Matrix2.prototype.applyInverse = function(pos, newPos) {
    newPos = newPos || new Point();
    var id = 1 / (this.a * this.d + this.c * -this.b);
    var x = pos.x;
    var y = pos.y;
    newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
    newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;
    return newPos;
  };
  Matrix2.prototype.translate = function(x, y) {
    this.tx += x;
    this.ty += y;
    return this;
  };
  Matrix2.prototype.scale = function(x, y) {
    this.a *= x;
    this.d *= y;
    this.c *= x;
    this.b *= y;
    this.tx *= x;
    this.ty *= y;
    return this;
  };
  Matrix2.prototype.rotate = function(angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    var a1 = this.a;
    var c1 = this.c;
    var tx1 = this.tx;
    this.a = a1 * cos - this.b * sin;
    this.b = a1 * sin + this.b * cos;
    this.c = c1 * cos - this.d * sin;
    this.d = c1 * sin + this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;
    return this;
  };
  Matrix2.prototype.append = function(matrix) {
    var a1 = this.a;
    var b1 = this.b;
    var c1 = this.c;
    var d1 = this.d;
    this.a = matrix.a * a1 + matrix.b * c1;
    this.b = matrix.a * b1 + matrix.b * d1;
    this.c = matrix.c * a1 + matrix.d * c1;
    this.d = matrix.c * b1 + matrix.d * d1;
    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
    return this;
  };
  Matrix2.prototype.setTransform = function(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
    this.a = Math.cos(rotation + skewY) * scaleX;
    this.b = Math.sin(rotation + skewY) * scaleX;
    this.c = -Math.sin(rotation - skewX) * scaleY;
    this.d = Math.cos(rotation - skewX) * scaleY;
    this.tx = x - (pivotX * this.a + pivotY * this.c);
    this.ty = y - (pivotX * this.b + pivotY * this.d);
    return this;
  };
  Matrix2.prototype.prepend = function(matrix) {
    var tx1 = this.tx;
    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
      var a1 = this.a;
      var c1 = this.c;
      this.a = a1 * matrix.a + this.b * matrix.c;
      this.b = a1 * matrix.b + this.b * matrix.d;
      this.c = c1 * matrix.a + this.d * matrix.c;
      this.d = c1 * matrix.b + this.d * matrix.d;
    }
    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
    return this;
  };
  Matrix2.prototype.decompose = function(transform) {
    var a = this.a;
    var b = this.b;
    var c = this.c;
    var d = this.d;
    var pivot = transform.pivot;
    var skewX = -Math.atan2(-c, d);
    var skewY = Math.atan2(b, a);
    var delta = Math.abs(skewX + skewY);
    if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
      transform.rotation = skewY;
      transform.skew.x = transform.skew.y = 0;
    } else {
      transform.rotation = 0;
      transform.skew.x = skewX;
      transform.skew.y = skewY;
    }
    transform.scale.x = Math.sqrt(a * a + b * b);
    transform.scale.y = Math.sqrt(c * c + d * d);
    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);
    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);
    return transform;
  };
  Matrix2.prototype.invert = function() {
    var a1 = this.a;
    var b1 = this.b;
    var c1 = this.c;
    var d1 = this.d;
    var tx1 = this.tx;
    var n = a1 * d1 - b1 * c1;
    this.a = d1 / n;
    this.b = -b1 / n;
    this.c = -c1 / n;
    this.d = a1 / n;
    this.tx = (c1 * this.ty - d1 * tx1) / n;
    this.ty = -(a1 * this.ty - b1 * tx1) / n;
    return this;
  };
  Matrix2.prototype.identity = function() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
    return this;
  };
  Matrix2.prototype.clone = function() {
    var matrix = new Matrix2();
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  };
  Matrix2.prototype.copyTo = function(matrix) {
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  };
  Matrix2.prototype.copyFrom = function(matrix) {
    this.a = matrix.a;
    this.b = matrix.b;
    this.c = matrix.c;
    this.d = matrix.d;
    this.tx = matrix.tx;
    this.ty = matrix.ty;
    return this;
  };
  Matrix2.prototype.toString = function() {
    return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
  };
  Object.defineProperty(Matrix2, "IDENTITY", {
    get: function() {
      return new Matrix2();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Matrix2, "TEMP_MATRIX", {
    get: function() {
      return new Matrix2();
    },
    enumerable: false,
    configurable: true
  });
  return Matrix2;
}();
var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
var rotationCayley = [];
var rotationMatrices = [];
var signum = Math.sign;
function init() {
  for (var i = 0; i < 16; i++) {
    var row = [];
    rotationCayley.push(row);
    for (var j = 0; j < 16; j++) {
      var _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
      var _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
      var _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
      var _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
      for (var k = 0; k < 16; k++) {
        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
          row.push(k);
          break;
        }
      }
    }
  }
  for (var i = 0; i < 16; i++) {
    var mat = new Matrix();
    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
    rotationMatrices.push(mat);
  }
}
init();
var groupD8 = {
  E: 0,
  SE: 1,
  S: 2,
  SW: 3,
  W: 4,
  NW: 5,
  N: 6,
  NE: 7,
  MIRROR_VERTICAL: 8,
  MAIN_DIAGONAL: 10,
  MIRROR_HORIZONTAL: 12,
  REVERSE_DIAGONAL: 14,
  uX: function(ind) {
    return ux[ind];
  },
  uY: function(ind) {
    return uy[ind];
  },
  vX: function(ind) {
    return vx[ind];
  },
  vY: function(ind) {
    return vy[ind];
  },
  inv: function(rotation) {
    if (rotation & 8) {
      return rotation & 15;
    }
    return -rotation & 7;
  },
  add: function(rotationSecond, rotationFirst) {
    return rotationCayley[rotationSecond][rotationFirst];
  },
  sub: function(rotationSecond, rotationFirst) {
    return rotationCayley[rotationSecond][groupD8.inv(rotationFirst)];
  },
  rotate180: function(rotation) {
    return rotation ^ 4;
  },
  isVertical: function(rotation) {
    return (rotation & 3) === 2;
  },
  byDirection: function(dx, dy) {
    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
      if (dy >= 0) {
        return groupD8.S;
      }
      return groupD8.N;
    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
      if (dx > 0) {
        return groupD8.E;
      }
      return groupD8.W;
    } else if (dy > 0) {
      if (dx > 0) {
        return groupD8.SE;
      }
      return groupD8.SW;
    } else if (dx > 0) {
      return groupD8.NE;
    }
    return groupD8.NW;
  },
  matrixAppendRotationInv: function(matrix, rotation, tx, ty) {
    if (tx === void 0) {
      tx = 0;
    }
    if (ty === void 0) {
      ty = 0;
    }
    var mat = rotationMatrices[groupD8.inv(rotation)];
    mat.tx = tx;
    mat.ty = ty;
    matrix.append(mat);
  }
};
var Transform = function() {
  function Transform2() {
    this.worldTransform = new Matrix();
    this.localTransform = new Matrix();
    this.position = new ObservablePoint(this.onChange, this, 0, 0);
    this.scale = new ObservablePoint(this.onChange, this, 1, 1);
    this.pivot = new ObservablePoint(this.onChange, this, 0, 0);
    this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);
    this._rotation = 0;
    this._cx = 1;
    this._sx = 0;
    this._cy = 0;
    this._sy = 1;
    this._localID = 0;
    this._currentLocalID = 0;
    this._worldID = 0;
    this._parentID = 0;
  }
  Transform2.prototype.onChange = function() {
    this._localID++;
  };
  Transform2.prototype.updateSkew = function() {
    this._cx = Math.cos(this._rotation + this.skew.y);
    this._sx = Math.sin(this._rotation + this.skew.y);
    this._cy = -Math.sin(this._rotation - this.skew.x);
    this._sy = Math.cos(this._rotation - this.skew.x);
    this._localID++;
  };
  Transform2.prototype.toString = function() {
    return "[@pixi/math:Transform " + ("position=(" + this.position.x + ", " + this.position.y + ") ") + ("rotation=" + this.rotation + " ") + ("scale=(" + this.scale.x + ", " + this.scale.y + ") ") + ("skew=(" + this.skew.x + ", " + this.skew.y + ") ") + "]";
  };
  Transform2.prototype.updateLocalTransform = function() {
    var lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
  };
  Transform2.prototype.updateTransform = function(parentTransform) {
    var lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
    if (this._parentID !== parentTransform._worldID) {
      var pt = parentTransform.worldTransform;
      var wt = this.worldTransform;
      wt.a = lt.a * pt.a + lt.b * pt.c;
      wt.b = lt.a * pt.b + lt.b * pt.d;
      wt.c = lt.c * pt.a + lt.d * pt.c;
      wt.d = lt.c * pt.b + lt.d * pt.d;
      wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
      wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
      this._parentID = parentTransform._worldID;
      this._worldID++;
    }
  };
  Transform2.prototype.setFromMatrix = function(matrix) {
    matrix.decompose(this);
    this._localID++;
  };
  Object.defineProperty(Transform2.prototype, "rotation", {
    get: function() {
      return this._rotation;
    },
    set: function(value) {
      if (this._rotation !== value) {
        this._rotation = value;
        this.updateSkew();
      }
    },
    enumerable: false,
    configurable: true
  });
  Transform2.IDENTITY = new Transform2();
  return Transform2;
}();
/*!
 * @pixi/display - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/display is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.SORTABLE_CHILDREN = false;
var Bounds = function() {
  function Bounds2() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
    this.rect = null;
    this.updateID = -1;
  }
  Bounds2.prototype.isEmpty = function() {
    return this.minX > this.maxX || this.minY > this.maxY;
  };
  Bounds2.prototype.clear = function() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
  };
  Bounds2.prototype.getRectangle = function(rect) {
    if (this.minX > this.maxX || this.minY > this.maxY) {
      return Rectangle.EMPTY;
    }
    rect = rect || new Rectangle(0, 0, 1, 1);
    rect.x = this.minX;
    rect.y = this.minY;
    rect.width = this.maxX - this.minX;
    rect.height = this.maxY - this.minY;
    return rect;
  };
  Bounds2.prototype.addPoint = function(point) {
    this.minX = Math.min(this.minX, point.x);
    this.maxX = Math.max(this.maxX, point.x);
    this.minY = Math.min(this.minY, point.y);
    this.maxY = Math.max(this.maxY, point.y);
  };
  Bounds2.prototype.addPointMatrix = function(matrix, point) {
    var a = matrix.a, b = matrix.b, c = matrix.c, d = matrix.d, tx = matrix.tx, ty = matrix.ty;
    var x = a * point.x + c * point.y + tx;
    var y = b * point.x + d * point.y + ty;
    this.minX = Math.min(this.minX, x);
    this.maxX = Math.max(this.maxX, x);
    this.minY = Math.min(this.minY, y);
    this.maxY = Math.max(this.maxY, y);
  };
  Bounds2.prototype.addQuad = function(vertices) {
    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;
    var x = vertices[0];
    var y = vertices[1];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = vertices[2];
    y = vertices[3];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = vertices[4];
    y = vertices[5];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = vertices[6];
    y = vertices[7];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  };
  Bounds2.prototype.addFrame = function(transform, x0, y0, x1, y1) {
    this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
  };
  Bounds2.prototype.addFrameMatrix = function(matrix, x0, y0, x1, y1) {
    var a = matrix.a;
    var b = matrix.b;
    var c = matrix.c;
    var d = matrix.d;
    var tx = matrix.tx;
    var ty = matrix.ty;
    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;
    var x = a * x0 + c * y0 + tx;
    var y = b * x0 + d * y0 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = a * x1 + c * y0 + tx;
    y = b * x1 + d * y0 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = a * x0 + c * y1 + tx;
    y = b * x0 + d * y1 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = a * x1 + c * y1 + tx;
    y = b * x1 + d * y1 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  };
  Bounds2.prototype.addVertexData = function(vertexData, beginOffset, endOffset) {
    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;
    for (var i = beginOffset; i < endOffset; i += 2) {
      var x = vertexData[i];
      var y = vertexData[i + 1];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  };
  Bounds2.prototype.addVertices = function(transform, vertices, beginOffset, endOffset) {
    this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
  };
  Bounds2.prototype.addVerticesMatrix = function(matrix, vertices, beginOffset, endOffset, padX, padY) {
    if (padX === void 0) {
      padX = 0;
    }
    if (padY === void 0) {
      padY = padX;
    }
    var a = matrix.a;
    var b = matrix.b;
    var c = matrix.c;
    var d = matrix.d;
    var tx = matrix.tx;
    var ty = matrix.ty;
    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;
    for (var i = beginOffset; i < endOffset; i += 2) {
      var rawX = vertices[i];
      var rawY = vertices[i + 1];
      var x = a * rawX + c * rawY + tx;
      var y = d * rawY + b * rawX + ty;
      minX = Math.min(minX, x - padX);
      maxX = Math.max(maxX, x + padX);
      minY = Math.min(minY, y - padY);
      maxY = Math.max(maxY, y + padY);
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  };
  Bounds2.prototype.addBounds = function(bounds) {
    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;
    this.minX = bounds.minX < minX ? bounds.minX : minX;
    this.minY = bounds.minY < minY ? bounds.minY : minY;
    this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
    this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
  };
  Bounds2.prototype.addBoundsMask = function(bounds, mask) {
    var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
    var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
    var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
    var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
    if (_minX <= _maxX && _minY <= _maxY) {
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  };
  Bounds2.prototype.addBoundsMatrix = function(bounds, matrix) {
    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
  };
  Bounds2.prototype.addBoundsArea = function(bounds, area2) {
    var _minX = bounds.minX > area2.x ? bounds.minX : area2.x;
    var _minY = bounds.minY > area2.y ? bounds.minY : area2.y;
    var _maxX = bounds.maxX < area2.x + area2.width ? bounds.maxX : area2.x + area2.width;
    var _maxY = bounds.maxY < area2.y + area2.height ? bounds.maxY : area2.y + area2.height;
    if (_minX <= _maxX && _minY <= _maxY) {
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  };
  Bounds2.prototype.pad = function(paddingX, paddingY) {
    if (paddingX === void 0) {
      paddingX = 0;
    }
    if (paddingY === void 0) {
      paddingY = paddingX;
    }
    if (!this.isEmpty()) {
      this.minX -= paddingX;
      this.maxX += paddingX;
      this.minY -= paddingY;
      this.maxY += paddingY;
    }
  };
  Bounds2.prototype.addFramePad = function(x0, y0, x1, y1, padX, padY) {
    x0 -= padX;
    y0 -= padY;
    x1 += padX;
    y1 += padY;
    this.minX = this.minX < x0 ? this.minX : x0;
    this.maxX = this.maxX > x1 ? this.maxX : x1;
    this.minY = this.minY < y0 ? this.minY : y0;
    this.maxY = this.maxY > y1 ? this.maxY : y1;
  };
  return Bounds2;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$j = function(d, b) {
  extendStatics$j = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$j(d, b);
};
function __extends$j(d, b) {
  extendStatics$j(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var DisplayObject = function(_super) {
  __extends$j(DisplayObject2, _super);
  function DisplayObject2() {
    var _this = _super.call(this) || this;
    _this.tempDisplayObjectParent = null;
    _this.transform = new Transform();
    _this.alpha = 1;
    _this.visible = true;
    _this.renderable = true;
    _this.parent = null;
    _this.worldAlpha = 1;
    _this._lastSortedIndex = 0;
    _this._zIndex = 0;
    _this.filterArea = null;
    _this.filters = null;
    _this._enabledFilters = null;
    _this._bounds = new Bounds();
    _this._localBounds = null;
    _this._boundsID = 0;
    _this._boundsRect = null;
    _this._localBoundsRect = null;
    _this._mask = null;
    _this._maskRefCount = 0;
    _this._destroyed = false;
    _this.isSprite = false;
    _this.isMask = false;
    return _this;
  }
  DisplayObject2.mixin = function(source) {
    var keys = Object.keys(source);
    for (var i = 0; i < keys.length; ++i) {
      var propertyName = keys[i];
      Object.defineProperty(DisplayObject2.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
    }
  };
  Object.defineProperty(DisplayObject2.prototype, "destroyed", {
    get: function() {
      return this._destroyed;
    },
    enumerable: false,
    configurable: true
  });
  DisplayObject2.prototype._recursivePostUpdateTransform = function() {
    if (this.parent) {
      this.parent._recursivePostUpdateTransform();
      this.transform.updateTransform(this.parent.transform);
    } else {
      this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }
  };
  DisplayObject2.prototype.updateTransform = function() {
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
  };
  DisplayObject2.prototype.getBounds = function(skipUpdate, rect) {
    if (!skipUpdate) {
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.updateTransform();
        this.parent = null;
      } else {
        this._recursivePostUpdateTransform();
        this.updateTransform();
      }
    }
    if (this._bounds.updateID !== this._boundsID) {
      this.calculateBounds();
      this._bounds.updateID = this._boundsID;
    }
    if (!rect) {
      if (!this._boundsRect) {
        this._boundsRect = new Rectangle();
      }
      rect = this._boundsRect;
    }
    return this._bounds.getRectangle(rect);
  };
  DisplayObject2.prototype.getLocalBounds = function(rect) {
    if (!rect) {
      if (!this._localBoundsRect) {
        this._localBoundsRect = new Rectangle();
      }
      rect = this._localBoundsRect;
    }
    if (!this._localBounds) {
      this._localBounds = new Bounds();
    }
    var transformRef = this.transform;
    var parentRef = this.parent;
    this.parent = null;
    this.transform = this._tempDisplayObjectParent.transform;
    var worldBounds = this._bounds;
    var worldBoundsID = this._boundsID;
    this._bounds = this._localBounds;
    var bounds = this.getBounds(false, rect);
    this.parent = parentRef;
    this.transform = transformRef;
    this._bounds = worldBounds;
    this._bounds.updateID += this._boundsID - worldBoundsID;
    return bounds;
  };
  DisplayObject2.prototype.toGlobal = function(position, point, skipUpdate) {
    if (skipUpdate === void 0) {
      skipUpdate = false;
    }
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.apply(position, point);
  };
  DisplayObject2.prototype.toLocal = function(position, from, point, skipUpdate) {
    if (from) {
      position = from.toGlobal(position, point, skipUpdate);
    }
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.applyInverse(position, point);
  };
  DisplayObject2.prototype.setParent = function(container) {
    if (!container || !container.addChild) {
      throw new Error("setParent: Argument must be a Container");
    }
    container.addChild(this);
    return container;
  };
  DisplayObject2.prototype.setTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (scaleX === void 0) {
      scaleX = 1;
    }
    if (scaleY === void 0) {
      scaleY = 1;
    }
    if (rotation === void 0) {
      rotation = 0;
    }
    if (skewX === void 0) {
      skewX = 0;
    }
    if (skewY === void 0) {
      skewY = 0;
    }
    if (pivotX === void 0) {
      pivotX = 0;
    }
    if (pivotY === void 0) {
      pivotY = 0;
    }
    this.position.x = x;
    this.position.y = y;
    this.scale.x = !scaleX ? 1 : scaleX;
    this.scale.y = !scaleY ? 1 : scaleY;
    this.rotation = rotation;
    this.skew.x = skewX;
    this.skew.y = skewY;
    this.pivot.x = pivotX;
    this.pivot.y = pivotY;
    return this;
  };
  DisplayObject2.prototype.destroy = function(_options) {
    if (this.parent) {
      this.parent.removeChild(this);
    }
    this.emit("destroyed");
    this.removeAllListeners();
    this.transform = null;
    this.parent = null;
    this._bounds = null;
    this.mask = null;
    this.filters = null;
    this.filterArea = null;
    this.hitArea = null;
    this.interactive = false;
    this.interactiveChildren = false;
    this._destroyed = true;
  };
  Object.defineProperty(DisplayObject2.prototype, "_tempDisplayObjectParent", {
    get: function() {
      if (this.tempDisplayObjectParent === null) {
        this.tempDisplayObjectParent = new TemporaryDisplayObject();
      }
      return this.tempDisplayObjectParent;
    },
    enumerable: false,
    configurable: true
  });
  DisplayObject2.prototype.enableTempParent = function() {
    var myParent = this.parent;
    this.parent = this._tempDisplayObjectParent;
    return myParent;
  };
  DisplayObject2.prototype.disableTempParent = function(cacheParent) {
    this.parent = cacheParent;
  };
  Object.defineProperty(DisplayObject2.prototype, "x", {
    get: function() {
      return this.position.x;
    },
    set: function(value) {
      this.transform.position.x = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "y", {
    get: function() {
      return this.position.y;
    },
    set: function(value) {
      this.transform.position.y = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "worldTransform", {
    get: function() {
      return this.transform.worldTransform;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "localTransform", {
    get: function() {
      return this.transform.localTransform;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "position", {
    get: function() {
      return this.transform.position;
    },
    set: function(value) {
      this.transform.position.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "scale", {
    get: function() {
      return this.transform.scale;
    },
    set: function(value) {
      this.transform.scale.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "pivot", {
    get: function() {
      return this.transform.pivot;
    },
    set: function(value) {
      this.transform.pivot.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "skew", {
    get: function() {
      return this.transform.skew;
    },
    set: function(value) {
      this.transform.skew.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "rotation", {
    get: function() {
      return this.transform.rotation;
    },
    set: function(value) {
      this.transform.rotation = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "angle", {
    get: function() {
      return this.transform.rotation * RAD_TO_DEG;
    },
    set: function(value) {
      this.transform.rotation = value * DEG_TO_RAD;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "zIndex", {
    get: function() {
      return this._zIndex;
    },
    set: function(value) {
      this._zIndex = value;
      if (this.parent) {
        this.parent.sortDirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "worldVisible", {
    get: function() {
      var item = this;
      do {
        if (!item.visible) {
          return false;
        }
        item = item.parent;
      } while (item);
      return true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "mask", {
    get: function() {
      return this._mask;
    },
    set: function(value) {
      if (this._mask === value) {
        return;
      }
      if (this._mask) {
        var maskObject = this._mask.maskObject || this._mask;
        maskObject._maskRefCount--;
        if (maskObject._maskRefCount === 0) {
          maskObject.renderable = true;
          maskObject.isMask = false;
        }
      }
      this._mask = value;
      if (this._mask) {
        var maskObject = this._mask.maskObject || this._mask;
        if (maskObject._maskRefCount === 0) {
          maskObject.renderable = false;
          maskObject.isMask = true;
        }
        maskObject._maskRefCount++;
      }
    },
    enumerable: false,
    configurable: true
  });
  return DisplayObject2;
}(EventEmitter);
var TemporaryDisplayObject = function(_super) {
  __extends$j(TemporaryDisplayObject2, _super);
  function TemporaryDisplayObject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.sortDirty = null;
    return _this;
  }
  return TemporaryDisplayObject2;
}(DisplayObject);
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
/*!
 * @pixi/constants - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$2;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV$2 || (ENV$2 = {}));
var RENDERER_TYPE$2;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE$2 || (RENDERER_TYPE$2 = {}));
var BUFFER_BITS$2;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS$2 || (BUFFER_BITS$2 = {}));
var BLEND_MODES$2;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES$2 || (BLEND_MODES$2 = {}));
var DRAW_MODES$2;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$2 || (DRAW_MODES$2 = {}));
var FORMATS$2;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS$2 || (FORMATS$2 = {}));
var TARGETS$2;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$2 || (TARGETS$2 = {}));
var TYPES$2;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES$2 || (TYPES$2 = {}));
var SAMPLER_TYPES$2;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES$2 || (SAMPLER_TYPES$2 = {}));
var SCALE_MODES$2;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES$2 || (SCALE_MODES$2 = {}));
var WRAP_MODES$2;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$2 || (WRAP_MODES$2 = {}));
var MIPMAP_MODES$2;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES$2 || (MIPMAP_MODES$2 = {}));
var ALPHA_MODES$2;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$2 || (ALPHA_MODES$2 = {}));
var CLEAR_MODES$2;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES$2 || (CLEAR_MODES$2 = {}));
var GC_MODES$2;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES$2 || (GC_MODES$2 = {}));
var PRECISION$2;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION$2 || (PRECISION$2 = {}));
var MASK_TYPES$2;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES$2 || (MASK_TYPES$2 = {}));
var MSAA_QUALITY$2;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY$2 || (MSAA_QUALITY$2 = {}));
var BUFFER_TYPE$2;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$2 || (BUFFER_TYPE$2 = {}));
function sortChildren(a, b) {
  if (a.zIndex === b.zIndex) {
    return a._lastSortedIndex - b._lastSortedIndex;
  }
  return a.zIndex - b.zIndex;
}
var Container = function(_super) {
  __extends$j(Container2, _super);
  function Container2() {
    var _this = _super.call(this) || this;
    _this.children = [];
    _this.sortableChildren = settings.SORTABLE_CHILDREN;
    _this.sortDirty = false;
    return _this;
  }
  Container2.prototype.onChildrenChange = function(_length) {
  };
  Container2.prototype.addChild = function() {
    var arguments$1 = arguments;
    var children = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      children[_i] = arguments$1[_i];
    }
    if (children.length > 1) {
      for (var i = 0; i < children.length; i++) {
        this.addChild(children[i]);
      }
    } else {
      var child = children[0];
      if (child.parent) {
        child.parent.removeChild(child);
      }
      child.parent = this;
      this.sortDirty = true;
      child.transform._parentID = -1;
      this.children.push(child);
      this._boundsID++;
      this.onChildrenChange(this.children.length - 1);
      this.emit("childAdded", child, this, this.children.length - 1);
      child.emit("added", this);
    }
    return children[0];
  };
  Container2.prototype.addChildAt = function(child, index2) {
    if (index2 < 0 || index2 > this.children.length) {
      throw new Error(child + "addChildAt: The index " + index2 + " supplied is out of bounds " + this.children.length);
    }
    if (child.parent) {
      child.parent.removeChild(child);
    }
    child.parent = this;
    this.sortDirty = true;
    child.transform._parentID = -1;
    this.children.splice(index2, 0, child);
    this._boundsID++;
    this.onChildrenChange(index2);
    child.emit("added", this);
    this.emit("childAdded", child, this, index2);
    return child;
  };
  Container2.prototype.swapChildren = function(child, child2) {
    if (child === child2) {
      return;
    }
    var index1 = this.getChildIndex(child);
    var index2 = this.getChildIndex(child2);
    this.children[index1] = child2;
    this.children[index2] = child;
    this.onChildrenChange(index1 < index2 ? index1 : index2);
  };
  Container2.prototype.getChildIndex = function(child) {
    var index2 = this.children.indexOf(child);
    if (index2 === -1) {
      throw new Error("The supplied DisplayObject must be a child of the caller");
    }
    return index2;
  };
  Container2.prototype.setChildIndex = function(child, index2) {
    if (index2 < 0 || index2 >= this.children.length) {
      throw new Error("The index " + index2 + " supplied is out of bounds " + this.children.length);
    }
    var currentIndex = this.getChildIndex(child);
    removeItems(this.children, currentIndex, 1);
    this.children.splice(index2, 0, child);
    this.onChildrenChange(index2);
  };
  Container2.prototype.getChildAt = function(index2) {
    if (index2 < 0 || index2 >= this.children.length) {
      throw new Error("getChildAt: Index (" + index2 + ") does not exist.");
    }
    return this.children[index2];
  };
  Container2.prototype.removeChild = function() {
    var arguments$1 = arguments;
    var children = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      children[_i] = arguments$1[_i];
    }
    if (children.length > 1) {
      for (var i = 0; i < children.length; i++) {
        this.removeChild(children[i]);
      }
    } else {
      var child = children[0];
      var index2 = this.children.indexOf(child);
      if (index2 === -1) {
        return null;
      }
      child.parent = null;
      child.transform._parentID = -1;
      removeItems(this.children, index2, 1);
      this._boundsID++;
      this.onChildrenChange(index2);
      child.emit("removed", this);
      this.emit("childRemoved", child, this, index2);
    }
    return children[0];
  };
  Container2.prototype.removeChildAt = function(index2) {
    var child = this.getChildAt(index2);
    child.parent = null;
    child.transform._parentID = -1;
    removeItems(this.children, index2, 1);
    this._boundsID++;
    this.onChildrenChange(index2);
    child.emit("removed", this);
    this.emit("childRemoved", child, this, index2);
    return child;
  };
  Container2.prototype.removeChildren = function(beginIndex, endIndex) {
    if (beginIndex === void 0) {
      beginIndex = 0;
    }
    if (endIndex === void 0) {
      endIndex = this.children.length;
    }
    var begin = beginIndex;
    var end = endIndex;
    var range = end - begin;
    var removed;
    if (range > 0 && range <= end) {
      removed = this.children.splice(begin, range);
      for (var i = 0; i < removed.length; ++i) {
        removed[i].parent = null;
        if (removed[i].transform) {
          removed[i].transform._parentID = -1;
        }
      }
      this._boundsID++;
      this.onChildrenChange(beginIndex);
      for (var i = 0; i < removed.length; ++i) {
        removed[i].emit("removed", this);
        this.emit("childRemoved", removed[i], this, i);
      }
      return removed;
    } else if (range === 0 && this.children.length === 0) {
      return [];
    }
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  };
  Container2.prototype.sortChildren = function() {
    var sortRequired = false;
    for (var i = 0, j = this.children.length; i < j; ++i) {
      var child = this.children[i];
      child._lastSortedIndex = i;
      if (!sortRequired && child.zIndex !== 0) {
        sortRequired = true;
      }
    }
    if (sortRequired && this.children.length > 1) {
      this.children.sort(sortChildren);
    }
    this.sortDirty = false;
  };
  Container2.prototype.updateTransform = function() {
    if (this.sortableChildren && this.sortDirty) {
      this.sortChildren();
    }
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
    for (var i = 0, j = this.children.length; i < j; ++i) {
      var child = this.children[i];
      if (child.visible) {
        child.updateTransform();
      }
    }
  };
  Container2.prototype.calculateBounds = function() {
    this._bounds.clear();
    this._calculateBounds();
    for (var i = 0; i < this.children.length; i++) {
      var child = this.children[i];
      if (!child.visible || !child.renderable) {
        continue;
      }
      child.calculateBounds();
      if (child._mask) {
        var maskObject = child._mask.maskObject || child._mask;
        maskObject.calculateBounds();
        this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
      } else if (child.filterArea) {
        this._bounds.addBoundsArea(child._bounds, child.filterArea);
      } else {
        this._bounds.addBounds(child._bounds);
      }
    }
    this._bounds.updateID = this._boundsID;
  };
  Container2.prototype.getLocalBounds = function(rect, skipChildrenUpdate) {
    if (skipChildrenUpdate === void 0) {
      skipChildrenUpdate = false;
    }
    var result = _super.prototype.getLocalBounds.call(this, rect);
    if (!skipChildrenUpdate) {
      for (var i = 0, j = this.children.length; i < j; ++i) {
        var child = this.children[i];
        if (child.visible) {
          child.updateTransform();
        }
      }
    }
    return result;
  };
  Container2.prototype._calculateBounds = function() {
  };
  Container2.prototype.render = function(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    if (this._mask || this.filters && this.filters.length) {
      this.renderAdvanced(renderer);
    } else {
      this._render(renderer);
      for (var i = 0, j = this.children.length; i < j; ++i) {
        this.children[i].render(renderer);
      }
    }
  };
  Container2.prototype.renderAdvanced = function(renderer) {
    var filters = this.filters;
    var mask = this._mask;
    if (filters) {
      if (!this._enabledFilters) {
        this._enabledFilters = [];
      }
      this._enabledFilters.length = 0;
      for (var i = 0; i < filters.length; i++) {
        if (filters[i].enabled) {
          this._enabledFilters.push(filters[i]);
        }
      }
    }
    var flush = filters && this._enabledFilters && this._enabledFilters.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES$2.NONE));
    if (flush) {
      renderer.batch.flush();
    }
    if (filters && this._enabledFilters && this._enabledFilters.length) {
      renderer.filter.push(this, this._enabledFilters);
    }
    if (mask) {
      renderer.mask.push(this, this._mask);
    }
    this._render(renderer);
    for (var i = 0, j = this.children.length; i < j; i++) {
      this.children[i].render(renderer);
    }
    if (flush) {
      renderer.batch.flush();
    }
    if (mask) {
      renderer.mask.pop(this);
    }
    if (filters && this._enabledFilters && this._enabledFilters.length) {
      renderer.filter.pop();
    }
  };
  Container2.prototype._render = function(_renderer) {
  };
  Container2.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this);
    this.sortDirty = false;
    var destroyChildren = typeof options === "boolean" ? options : options && options.children;
    var oldChildren = this.removeChildren(0, this.children.length);
    if (destroyChildren) {
      for (var i = 0; i < oldChildren.length; ++i) {
        oldChildren[i].destroy(options);
      }
    }
  };
  Object.defineProperty(Container2.prototype, "width", {
    get: function() {
      return this.scale.x * this.getLocalBounds().width;
    },
    set: function(value) {
      var width = this.getLocalBounds().width;
      if (width !== 0) {
        this.scale.x = value / width;
      } else {
        this.scale.x = 1;
      }
      this._width = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Container2.prototype, "height", {
    get: function() {
      return this.scale.y * this.getLocalBounds().height;
    },
    set: function(value) {
      var height = this.getLocalBounds().height;
      if (height !== 0) {
        this.scale.y = value / height;
      } else {
        this.scale.y = 1;
      }
      this._height = value;
    },
    enumerable: false,
    configurable: true
  });
  return Container2;
}(DisplayObject);
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
/*!
 * @pixi/accessibility - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/accessibility is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var accessibleTarget = {
  accessible: false,
  accessibleTitle: null,
  accessibleHint: null,
  tabIndex: 0,
  _accessibleActive: false,
  _accessibleDiv: null,
  accessibleType: "button",
  accessiblePointerEvents: "auto",
  accessibleChildren: true,
  renderId: -1
};
DisplayObject.mixin(accessibleTarget);
var KEY_CODE_TAB = 9;
var DIV_TOUCH_SIZE = 100;
var DIV_TOUCH_POS_X = 0;
var DIV_TOUCH_POS_Y = 0;
var DIV_TOUCH_ZINDEX = 2;
var DIV_HOOK_SIZE = 1;
var DIV_HOOK_POS_X = -1e3;
var DIV_HOOK_POS_Y = -1e3;
var DIV_HOOK_ZINDEX = 2;
var AccessibilityManager = function() {
  function AccessibilityManager2(renderer) {
    this.debug = false;
    this._isActive = false;
    this._isMobileAccessibility = false;
    this.pool = [];
    this.renderId = 0;
    this.children = [];
    this.androidUpdateCount = 0;
    this.androidUpdateFrequency = 500;
    this._hookDiv = null;
    if (isMobile.tablet || isMobile.phone) {
      this.createTouchHook();
    }
    var div = document.createElement("div");
    div.style.width = DIV_TOUCH_SIZE + "px";
    div.style.height = DIV_TOUCH_SIZE + "px";
    div.style.position = "absolute";
    div.style.top = DIV_TOUCH_POS_X + "px";
    div.style.left = DIV_TOUCH_POS_Y + "px";
    div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
    this.div = div;
    this.renderer = renderer;
    this._onKeyDown = this._onKeyDown.bind(this);
    this._onMouseMove = this._onMouseMove.bind(this);
    self.addEventListener("keydown", this._onKeyDown, false);
  }
  Object.defineProperty(AccessibilityManager2.prototype, "isActive", {
    get: function() {
      return this._isActive;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AccessibilityManager2.prototype, "isMobileAccessibility", {
    get: function() {
      return this._isMobileAccessibility;
    },
    enumerable: false,
    configurable: true
  });
  AccessibilityManager2.prototype.createTouchHook = function() {
    var _this = this;
    var hookDiv = document.createElement("button");
    hookDiv.style.width = DIV_HOOK_SIZE + "px";
    hookDiv.style.height = DIV_HOOK_SIZE + "px";
    hookDiv.style.position = "absolute";
    hookDiv.style.top = DIV_HOOK_POS_X + "px";
    hookDiv.style.left = DIV_HOOK_POS_Y + "px";
    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
    hookDiv.style.backgroundColor = "#FF0000";
    hookDiv.title = "select to enable accessibility for this content";
    hookDiv.addEventListener("focus", function() {
      _this._isMobileAccessibility = true;
      _this.activate();
      _this.destroyTouchHook();
    });
    document.body.appendChild(hookDiv);
    this._hookDiv = hookDiv;
  };
  AccessibilityManager2.prototype.destroyTouchHook = function() {
    if (!this._hookDiv) {
      return;
    }
    document.body.removeChild(this._hookDiv);
    this._hookDiv = null;
  };
  AccessibilityManager2.prototype.activate = function() {
    var _a2;
    if (this._isActive) {
      return;
    }
    this._isActive = true;
    self.document.addEventListener("mousemove", this._onMouseMove, true);
    self.removeEventListener("keydown", this._onKeyDown, false);
    this.renderer.on("postrender", this.update, this);
    (_a2 = this.renderer.view.parentNode) === null || _a2 === void 0 ? void 0 : _a2.appendChild(this.div);
  };
  AccessibilityManager2.prototype.deactivate = function() {
    var _a2;
    if (!this._isActive || this._isMobileAccessibility) {
      return;
    }
    this._isActive = false;
    self.document.removeEventListener("mousemove", this._onMouseMove, true);
    self.addEventListener("keydown", this._onKeyDown, false);
    this.renderer.off("postrender", this.update);
    (_a2 = this.div.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.div);
  };
  AccessibilityManager2.prototype.updateAccessibleObjects = function(displayObject) {
    if (!displayObject.visible || !displayObject.accessibleChildren) {
      return;
    }
    if (displayObject.accessible && displayObject.interactive) {
      if (!displayObject._accessibleActive) {
        this.addChild(displayObject);
      }
      displayObject.renderId = this.renderId;
    }
    var children = displayObject.children;
    if (children) {
      for (var i = 0; i < children.length; i++) {
        this.updateAccessibleObjects(children[i]);
      }
    }
  };
  AccessibilityManager2.prototype.update = function() {
    var now = performance.now();
    if (isMobile.android.device && now < this.androidUpdateCount) {
      return;
    }
    this.androidUpdateCount = now + this.androidUpdateFrequency;
    if (!this.renderer.renderingToScreen) {
      return;
    }
    if (this.renderer._lastObjectRendered) {
      this.updateAccessibleObjects(this.renderer._lastObjectRendered);
    }
    var _a2 = this.renderer.view.getBoundingClientRect(), left = _a2.left, top = _a2.top, width = _a2.width, height = _a2.height;
    var _b2 = this.renderer, viewWidth = _b2.width, viewHeight = _b2.height, resolution = _b2.resolution;
    var sx = width / viewWidth * resolution;
    var sy = height / viewHeight * resolution;
    var div = this.div;
    div.style.left = left + "px";
    div.style.top = top + "px";
    div.style.width = viewWidth + "px";
    div.style.height = viewHeight + "px";
    for (var i = 0; i < this.children.length; i++) {
      var child = this.children[i];
      if (child.renderId !== this.renderId) {
        child._accessibleActive = false;
        removeItems(this.children, i, 1);
        this.div.removeChild(child._accessibleDiv);
        this.pool.push(child._accessibleDiv);
        child._accessibleDiv = null;
        i--;
      } else {
        div = child._accessibleDiv;
        var hitArea = child.hitArea;
        var wt = child.worldTransform;
        if (child.hitArea) {
          div.style.left = (wt.tx + hitArea.x * wt.a) * sx + "px";
          div.style.top = (wt.ty + hitArea.y * wt.d) * sy + "px";
          div.style.width = hitArea.width * wt.a * sx + "px";
          div.style.height = hitArea.height * wt.d * sy + "px";
        } else {
          hitArea = child.getBounds();
          this.capHitArea(hitArea);
          div.style.left = hitArea.x * sx + "px";
          div.style.top = hitArea.y * sy + "px";
          div.style.width = hitArea.width * sx + "px";
          div.style.height = hitArea.height * sy + "px";
          if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
            div.title = child.accessibleTitle;
          }
          if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
            div.setAttribute("aria-label", child.accessibleHint);
          }
        }
        if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
          div.title = child.accessibleTitle;
          div.tabIndex = child.tabIndex;
          if (this.debug) {
            this.updateDebugHTML(div);
          }
        }
      }
    }
    this.renderId++;
  };
  AccessibilityManager2.prototype.updateDebugHTML = function(div) {
    div.innerHTML = "type: " + div.type + "</br> title : " + div.title + "</br> tabIndex: " + div.tabIndex;
  };
  AccessibilityManager2.prototype.capHitArea = function(hitArea) {
    if (hitArea.x < 0) {
      hitArea.width += hitArea.x;
      hitArea.x = 0;
    }
    if (hitArea.y < 0) {
      hitArea.height += hitArea.y;
      hitArea.y = 0;
    }
    var _a2 = this.renderer, viewWidth = _a2.width, viewHeight = _a2.height;
    if (hitArea.x + hitArea.width > viewWidth) {
      hitArea.width = viewWidth - hitArea.x;
    }
    if (hitArea.y + hitArea.height > viewHeight) {
      hitArea.height = viewHeight - hitArea.y;
    }
  };
  AccessibilityManager2.prototype.addChild = function(displayObject) {
    var div = this.pool.pop();
    if (!div) {
      div = document.createElement("button");
      div.style.width = DIV_TOUCH_SIZE + "px";
      div.style.height = DIV_TOUCH_SIZE + "px";
      div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
      div.style.position = "absolute";
      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      div.style.borderStyle = "none";
      if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
        div.setAttribute("aria-live", "off");
      } else {
        div.setAttribute("aria-live", "polite");
      }
      if (navigator.userAgent.match(/rv:.*Gecko\//)) {
        div.setAttribute("aria-relevant", "additions");
      } else {
        div.setAttribute("aria-relevant", "text");
      }
      div.addEventListener("click", this._onClick.bind(this));
      div.addEventListener("focus", this._onFocus.bind(this));
      div.addEventListener("focusout", this._onFocusOut.bind(this));
    }
    div.style.pointerEvents = displayObject.accessiblePointerEvents;
    div.type = displayObject.accessibleType;
    if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
      div.title = displayObject.accessibleTitle;
    } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {
      div.title = "displayObject " + displayObject.tabIndex;
    }
    if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {
      div.setAttribute("aria-label", displayObject.accessibleHint);
    }
    if (this.debug) {
      this.updateDebugHTML(div);
    }
    displayObject._accessibleActive = true;
    displayObject._accessibleDiv = div;
    div.displayObject = displayObject;
    this.children.push(displayObject);
    this.div.appendChild(displayObject._accessibleDiv);
    displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
  };
  AccessibilityManager2.prototype._onClick = function(e2) {
    var interactionManager = this.renderer.plugins.interaction;
    var displayObject = e2.target.displayObject;
    var eventData = interactionManager.eventData;
    interactionManager.dispatchEvent(displayObject, "click", eventData);
    interactionManager.dispatchEvent(displayObject, "pointertap", eventData);
    interactionManager.dispatchEvent(displayObject, "tap", eventData);
  };
  AccessibilityManager2.prototype._onFocus = function(e2) {
    if (!e2.target.getAttribute("aria-live")) {
      e2.target.setAttribute("aria-live", "assertive");
    }
    var interactionManager = this.renderer.plugins.interaction;
    var displayObject = e2.target.displayObject;
    var eventData = interactionManager.eventData;
    interactionManager.dispatchEvent(displayObject, "mouseover", eventData);
  };
  AccessibilityManager2.prototype._onFocusOut = function(e2) {
    if (!e2.target.getAttribute("aria-live")) {
      e2.target.setAttribute("aria-live", "polite");
    }
    var interactionManager = this.renderer.plugins.interaction;
    var displayObject = e2.target.displayObject;
    var eventData = interactionManager.eventData;
    interactionManager.dispatchEvent(displayObject, "mouseout", eventData);
  };
  AccessibilityManager2.prototype._onKeyDown = function(e2) {
    if (e2.keyCode !== KEY_CODE_TAB) {
      return;
    }
    this.activate();
  };
  AccessibilityManager2.prototype._onMouseMove = function(e2) {
    if (e2.movementX === 0 && e2.movementY === 0) {
      return;
    }
    this.deactivate();
  };
  AccessibilityManager2.prototype.destroy = function() {
    this.destroyTouchHook();
    this.div = null;
    self.document.removeEventListener("mousemove", this._onMouseMove, true);
    self.removeEventListener("keydown", this._onKeyDown);
    this.pool = null;
    this.children = null;
    this.renderer = null;
  };
  return AccessibilityManager2;
}();
/*!
 * @pixi/ticker - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/ticker is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.TARGET_FPMS = 0.06;
var UPDATE_PRIORITY;
(function(UPDATE_PRIORITY2) {
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
})(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));
var TickerListener = function() {
  function TickerListener2(fn, context2, priority, once) {
    if (context2 === void 0) {
      context2 = null;
    }
    if (priority === void 0) {
      priority = 0;
    }
    if (once === void 0) {
      once = false;
    }
    this.next = null;
    this.previous = null;
    this._destroyed = false;
    this.fn = fn;
    this.context = context2;
    this.priority = priority;
    this.once = once;
  }
  TickerListener2.prototype.match = function(fn, context2) {
    if (context2 === void 0) {
      context2 = null;
    }
    return this.fn === fn && this.context === context2;
  };
  TickerListener2.prototype.emit = function(deltaTime) {
    if (this.fn) {
      if (this.context) {
        this.fn.call(this.context, deltaTime);
      } else {
        this.fn(deltaTime);
      }
    }
    var redirect = this.next;
    if (this.once) {
      this.destroy(true);
    }
    if (this._destroyed) {
      this.next = null;
    }
    return redirect;
  };
  TickerListener2.prototype.connect = function(previous) {
    this.previous = previous;
    if (previous.next) {
      previous.next.previous = this;
    }
    this.next = previous.next;
    previous.next = this;
  };
  TickerListener2.prototype.destroy = function(hard) {
    if (hard === void 0) {
      hard = false;
    }
    this._destroyed = true;
    this.fn = null;
    this.context = null;
    if (this.previous) {
      this.previous.next = this.next;
    }
    if (this.next) {
      this.next.previous = this.previous;
    }
    var redirect = this.next;
    this.next = hard ? null : redirect;
    this.previous = null;
    return redirect;
  };
  return TickerListener2;
}();
var Ticker = function() {
  function Ticker2() {
    var _this = this;
    this.autoStart = false;
    this.deltaTime = 1;
    this.lastTime = -1;
    this.speed = 1;
    this.started = false;
    this._requestId = null;
    this._maxElapsedMS = 100;
    this._minElapsedMS = 0;
    this._protected = false;
    this._lastFrame = -1;
    this._head = new TickerListener(null, null, Infinity);
    this.deltaMS = 1 / settings.TARGET_FPMS;
    this.elapsedMS = 1 / settings.TARGET_FPMS;
    this._tick = function(time) {
      _this._requestId = null;
      if (_this.started) {
        _this.update(time);
        if (_this.started && _this._requestId === null && _this._head.next) {
          _this._requestId = requestAnimationFrame(_this._tick);
        }
      }
    };
  }
  Ticker2.prototype._requestIfNeeded = function() {
    if (this._requestId === null && this._head.next) {
      this.lastTime = performance.now();
      this._lastFrame = this.lastTime;
      this._requestId = requestAnimationFrame(this._tick);
    }
  };
  Ticker2.prototype._cancelIfNeeded = function() {
    if (this._requestId !== null) {
      cancelAnimationFrame(this._requestId);
      this._requestId = null;
    }
  };
  Ticker2.prototype._startIfPossible = function() {
    if (this.started) {
      this._requestIfNeeded();
    } else if (this.autoStart) {
      this.start();
    }
  };
  Ticker2.prototype.add = function(fn, context2, priority) {
    if (priority === void 0) {
      priority = UPDATE_PRIORITY.NORMAL;
    }
    return this._addListener(new TickerListener(fn, context2, priority));
  };
  Ticker2.prototype.addOnce = function(fn, context2, priority) {
    if (priority === void 0) {
      priority = UPDATE_PRIORITY.NORMAL;
    }
    return this._addListener(new TickerListener(fn, context2, priority, true));
  };
  Ticker2.prototype._addListener = function(listener) {
    var current = this._head.next;
    var previous = this._head;
    if (!current) {
      listener.connect(previous);
    } else {
      while (current) {
        if (listener.priority > current.priority) {
          listener.connect(previous);
          break;
        }
        previous = current;
        current = current.next;
      }
      if (!listener.previous) {
        listener.connect(previous);
      }
    }
    this._startIfPossible();
    return this;
  };
  Ticker2.prototype.remove = function(fn, context2) {
    var listener = this._head.next;
    while (listener) {
      if (listener.match(fn, context2)) {
        listener = listener.destroy();
      } else {
        listener = listener.next;
      }
    }
    if (!this._head.next) {
      this._cancelIfNeeded();
    }
    return this;
  };
  Object.defineProperty(Ticker2.prototype, "count", {
    get: function() {
      if (!this._head) {
        return 0;
      }
      var count = 0;
      var current = this._head;
      while (current = current.next) {
        count++;
      }
      return count;
    },
    enumerable: false,
    configurable: true
  });
  Ticker2.prototype.start = function() {
    if (!this.started) {
      this.started = true;
      this._requestIfNeeded();
    }
  };
  Ticker2.prototype.stop = function() {
    if (this.started) {
      this.started = false;
      this._cancelIfNeeded();
    }
  };
  Ticker2.prototype.destroy = function() {
    if (!this._protected) {
      this.stop();
      var listener = this._head.next;
      while (listener) {
        listener = listener.destroy(true);
      }
      this._head.destroy();
      this._head = null;
    }
  };
  Ticker2.prototype.update = function(currentTime) {
    if (currentTime === void 0) {
      currentTime = performance.now();
    }
    var elapsedMS;
    if (currentTime > this.lastTime) {
      elapsedMS = this.elapsedMS = currentTime - this.lastTime;
      if (elapsedMS > this._maxElapsedMS) {
        elapsedMS = this._maxElapsedMS;
      }
      elapsedMS *= this.speed;
      if (this._minElapsedMS) {
        var delta = currentTime - this._lastFrame | 0;
        if (delta < this._minElapsedMS) {
          return;
        }
        this._lastFrame = currentTime - delta % this._minElapsedMS;
      }
      this.deltaMS = elapsedMS;
      this.deltaTime = this.deltaMS * settings.TARGET_FPMS;
      var head = this._head;
      var listener = head.next;
      while (listener) {
        listener = listener.emit(this.deltaTime);
      }
      if (!head.next) {
        this._cancelIfNeeded();
      }
    } else {
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    }
    this.lastTime = currentTime;
  };
  Object.defineProperty(Ticker2.prototype, "FPS", {
    get: function() {
      return 1e3 / this.elapsedMS;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Ticker2.prototype, "minFPS", {
    get: function() {
      return 1e3 / this._maxElapsedMS;
    },
    set: function(fps) {
      var minFPS = Math.min(this.maxFPS, fps);
      var minFPMS = Math.min(Math.max(0, minFPS) / 1e3, settings.TARGET_FPMS);
      this._maxElapsedMS = 1 / minFPMS;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Ticker2.prototype, "maxFPS", {
    get: function() {
      if (this._minElapsedMS) {
        return Math.round(1e3 / this._minElapsedMS);
      }
      return 0;
    },
    set: function(fps) {
      if (fps === 0) {
        this._minElapsedMS = 0;
      } else {
        var maxFPS = Math.max(this.minFPS, fps);
        this._minElapsedMS = 1 / (maxFPS / 1e3);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Ticker2, "shared", {
    get: function() {
      if (!Ticker2._shared) {
        var shared = Ticker2._shared = new Ticker2();
        shared.autoStart = true;
        shared._protected = true;
      }
      return Ticker2._shared;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Ticker2, "system", {
    get: function() {
      if (!Ticker2._system) {
        var system = Ticker2._system = new Ticker2();
        system.autoStart = true;
        system._protected = true;
      }
      return Ticker2._system;
    },
    enumerable: false,
    configurable: true
  });
  return Ticker2;
}();
var TickerPlugin = function() {
  function TickerPlugin2() {
  }
  TickerPlugin2.init = function(options) {
    var _this = this;
    options = Object.assign({
      autoStart: true,
      sharedTicker: false
    }, options);
    Object.defineProperty(this, "ticker", {
      set: function(ticker) {
        if (this._ticker) {
          this._ticker.remove(this.render, this);
        }
        this._ticker = ticker;
        if (ticker) {
          ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
        }
      },
      get: function() {
        return this._ticker;
      }
    });
    this.stop = function() {
      _this._ticker.stop();
    };
    this.start = function() {
      _this._ticker.start();
    };
    this._ticker = null;
    this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
    if (options.autoStart) {
      this.start();
    }
  };
  TickerPlugin2.destroy = function() {
    if (this._ticker) {
      var oldTicker = this._ticker;
      this.ticker = null;
      oldTicker.destroy();
    }
  };
  return TickerPlugin2;
}();
/*!
 * @pixi/interaction - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/interaction is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var InteractionData = function() {
  function InteractionData2() {
    this.pressure = 0;
    this.rotationAngle = 0;
    this.twist = 0;
    this.tangentialPressure = 0;
    this.global = new Point();
    this.target = null;
    this.originalEvent = null;
    this.identifier = null;
    this.isPrimary = false;
    this.button = 0;
    this.buttons = 0;
    this.width = 0;
    this.height = 0;
    this.tiltX = 0;
    this.tiltY = 0;
    this.pointerType = null;
    this.pressure = 0;
    this.rotationAngle = 0;
    this.twist = 0;
    this.tangentialPressure = 0;
  }
  Object.defineProperty(InteractionData2.prototype, "pointerId", {
    get: function() {
      return this.identifier;
    },
    enumerable: false,
    configurable: true
  });
  InteractionData2.prototype.getLocalPosition = function(displayObject, point, globalPos) {
    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
  };
  InteractionData2.prototype.copyEvent = function(event) {
    if ("isPrimary" in event && event.isPrimary) {
      this.isPrimary = true;
    }
    this.button = "button" in event && event.button;
    var buttons = "buttons" in event && event.buttons;
    this.buttons = Number.isInteger(buttons) ? buttons : "which" in event && event.which;
    this.width = "width" in event && event.width;
    this.height = "height" in event && event.height;
    this.tiltX = "tiltX" in event && event.tiltX;
    this.tiltY = "tiltY" in event && event.tiltY;
    this.pointerType = "pointerType" in event && event.pointerType;
    this.pressure = "pressure" in event && event.pressure;
    this.rotationAngle = "rotationAngle" in event && event.rotationAngle;
    this.twist = "twist" in event && event.twist || 0;
    this.tangentialPressure = "tangentialPressure" in event && event.tangentialPressure || 0;
  };
  InteractionData2.prototype.reset = function() {
    this.isPrimary = false;
  };
  return InteractionData2;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$i = function(d, b) {
  extendStatics$i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$i(d, b);
};
function __extends$i(d, b) {
  extendStatics$i(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var InteractionEvent = function() {
  function InteractionEvent2() {
    this.stopped = false;
    this.stopsPropagatingAt = null;
    this.stopPropagationHint = false;
    this.target = null;
    this.currentTarget = null;
    this.type = null;
    this.data = null;
  }
  InteractionEvent2.prototype.stopPropagation = function() {
    this.stopped = true;
    this.stopPropagationHint = true;
    this.stopsPropagatingAt = this.currentTarget;
  };
  InteractionEvent2.prototype.reset = function() {
    this.stopped = false;
    this.stopsPropagatingAt = null;
    this.stopPropagationHint = false;
    this.currentTarget = null;
    this.target = null;
  };
  return InteractionEvent2;
}();
var InteractionTrackingData = function() {
  function InteractionTrackingData2(pointerId) {
    this._pointerId = pointerId;
    this._flags = InteractionTrackingData2.FLAGS.NONE;
  }
  InteractionTrackingData2.prototype._doSet = function(flag, yn) {
    if (yn) {
      this._flags = this._flags | flag;
    } else {
      this._flags = this._flags & ~flag;
    }
  };
  Object.defineProperty(InteractionTrackingData2.prototype, "pointerId", {
    get: function() {
      return this._pointerId;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "flags", {
    get: function() {
      return this._flags;
    },
    set: function(flags) {
      this._flags = flags;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "none", {
    get: function() {
      return this._flags === InteractionTrackingData2.FLAGS.NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "over", {
    get: function() {
      return (this._flags & InteractionTrackingData2.FLAGS.OVER) !== 0;
    },
    set: function(yn) {
      this._doSet(InteractionTrackingData2.FLAGS.OVER, yn);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "rightDown", {
    get: function() {
      return (this._flags & InteractionTrackingData2.FLAGS.RIGHT_DOWN) !== 0;
    },
    set: function(yn) {
      this._doSet(InteractionTrackingData2.FLAGS.RIGHT_DOWN, yn);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "leftDown", {
    get: function() {
      return (this._flags & InteractionTrackingData2.FLAGS.LEFT_DOWN) !== 0;
    },
    set: function(yn) {
      this._doSet(InteractionTrackingData2.FLAGS.LEFT_DOWN, yn);
    },
    enumerable: false,
    configurable: true
  });
  InteractionTrackingData2.FLAGS = Object.freeze({
    NONE: 0,
    OVER: 1 << 0,
    LEFT_DOWN: 1 << 1,
    RIGHT_DOWN: 1 << 2
  });
  return InteractionTrackingData2;
}();
var TreeSearch = function() {
  function TreeSearch2() {
    this._tempPoint = new Point();
  }
  TreeSearch2.prototype.recursiveFindHit = function(interactionEvent, displayObject, func, hitTest, interactive) {
    if (!displayObject || !displayObject.visible) {
      return false;
    }
    var point = interactionEvent.data.global;
    interactive = displayObject.interactive || interactive;
    var hit = false;
    var interactiveParent = interactive;
    var hitTestChildren = true;
    if (displayObject.hitArea) {
      if (hitTest) {
        displayObject.worldTransform.applyInverse(point, this._tempPoint);
        if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {
          hitTest = false;
          hitTestChildren = false;
        } else {
          hit = true;
        }
      }
      interactiveParent = false;
    } else if (displayObject._mask) {
      if (hitTest) {
        if (!(displayObject._mask.containsPoint && displayObject._mask.containsPoint(point))) {
          hitTest = false;
        }
      }
    }
    if (hitTestChildren && displayObject.interactiveChildren && displayObject.children) {
      var children = displayObject.children;
      for (var i = children.length - 1; i >= 0; i--) {
        var child = children[i];
        var childHit = this.recursiveFindHit(interactionEvent, child, func, hitTest, interactiveParent);
        if (childHit) {
          if (!child.parent) {
            continue;
          }
          interactiveParent = false;
          if (childHit) {
            if (interactionEvent.target) {
              hitTest = false;
            }
            hit = true;
          }
        }
      }
    }
    if (interactive) {
      if (hitTest && !interactionEvent.target) {
        if (!displayObject.hitArea && displayObject.containsPoint) {
          if (displayObject.containsPoint(point)) {
            hit = true;
          }
        }
      }
      if (displayObject.interactive) {
        if (hit && !interactionEvent.target) {
          interactionEvent.target = displayObject;
        }
        if (func) {
          func(interactionEvent, displayObject, !!hit);
        }
      }
    }
    return hit;
  };
  TreeSearch2.prototype.findHit = function(interactionEvent, displayObject, func, hitTest) {
    this.recursiveFindHit(interactionEvent, displayObject, func, hitTest, false);
  };
  return TreeSearch2;
}();
var interactiveTarget = {
  interactive: false,
  interactiveChildren: true,
  hitArea: null,
  get buttonMode() {
    return this.cursor === "pointer";
  },
  set buttonMode(value) {
    if (value) {
      this.cursor = "pointer";
    } else if (this.cursor === "pointer") {
      this.cursor = null;
    }
  },
  cursor: null,
  get trackedPointers() {
    if (this._trackedPointers === void 0) {
      this._trackedPointers = {};
    }
    return this._trackedPointers;
  },
  _trackedPointers: void 0
};
DisplayObject.mixin(interactiveTarget);
var MOUSE_POINTER_ID = 1;
var hitTestEvent = {
  target: null,
  data: {
    global: null
  }
};
var InteractionManager = function(_super) {
  __extends$i(InteractionManager2, _super);
  function InteractionManager2(renderer, options) {
    var _this = _super.call(this) || this;
    options = options || {};
    _this.renderer = renderer;
    _this.autoPreventDefault = options.autoPreventDefault !== void 0 ? options.autoPreventDefault : true;
    _this.interactionFrequency = options.interactionFrequency || 10;
    _this.mouse = new InteractionData();
    _this.mouse.identifier = MOUSE_POINTER_ID;
    _this.mouse.global.set(-999999);
    _this.activeInteractionData = {};
    _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;
    _this.interactionDataPool = [];
    _this.eventData = new InteractionEvent();
    _this.interactionDOMElement = null;
    _this.moveWhenInside = false;
    _this.eventsAdded = false;
    _this.tickerAdded = false;
    _this.mouseOverRenderer = !("PointerEvent" in self);
    _this.supportsTouchEvents = "ontouchstart" in self;
    _this.supportsPointerEvents = !!self.PointerEvent;
    _this.onPointerUp = _this.onPointerUp.bind(_this);
    _this.processPointerUp = _this.processPointerUp.bind(_this);
    _this.onPointerCancel = _this.onPointerCancel.bind(_this);
    _this.processPointerCancel = _this.processPointerCancel.bind(_this);
    _this.onPointerDown = _this.onPointerDown.bind(_this);
    _this.processPointerDown = _this.processPointerDown.bind(_this);
    _this.onPointerMove = _this.onPointerMove.bind(_this);
    _this.processPointerMove = _this.processPointerMove.bind(_this);
    _this.onPointerOut = _this.onPointerOut.bind(_this);
    _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);
    _this.onPointerOver = _this.onPointerOver.bind(_this);
    _this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    };
    _this.currentCursorMode = null;
    _this.cursor = null;
    _this.resolution = 1;
    _this.delayedEvents = [];
    _this.search = new TreeSearch();
    _this._tempDisplayObject = new TemporaryDisplayObject();
    _this._eventListenerOptions = { capture: true, passive: false };
    _this._useSystemTicker = options.useSystemTicker !== void 0 ? options.useSystemTicker : true;
    _this.setTargetElement(_this.renderer.view, _this.renderer.resolution);
    return _this;
  }
  Object.defineProperty(InteractionManager2.prototype, "useSystemTicker", {
    get: function() {
      return this._useSystemTicker;
    },
    set: function(useSystemTicker) {
      this._useSystemTicker = useSystemTicker;
      if (useSystemTicker) {
        this.addTickerListener();
      } else {
        this.removeTickerListener();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionManager2.prototype, "lastObjectRendered", {
    get: function() {
      return this.renderer._lastObjectRendered || this._tempDisplayObject;
    },
    enumerable: false,
    configurable: true
  });
  InteractionManager2.prototype.hitTest = function(globalPoint, root) {
    hitTestEvent.target = null;
    hitTestEvent.data.global = globalPoint;
    if (!root) {
      root = this.lastObjectRendered;
    }
    this.processInteractive(hitTestEvent, root, null, true);
    return hitTestEvent.target;
  };
  InteractionManager2.prototype.setTargetElement = function(element, resolution) {
    if (resolution === void 0) {
      resolution = 1;
    }
    this.removeTickerListener();
    this.removeEvents();
    this.interactionDOMElement = element;
    this.resolution = resolution;
    this.addEvents();
    this.addTickerListener();
  };
  InteractionManager2.prototype.addTickerListener = function() {
    if (this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker) {
      return;
    }
    Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
    this.tickerAdded = true;
  };
  InteractionManager2.prototype.removeTickerListener = function() {
    if (!this.tickerAdded) {
      return;
    }
    Ticker.system.remove(this.tickerUpdate, this);
    this.tickerAdded = false;
  };
  InteractionManager2.prototype.addEvents = function() {
    if (this.eventsAdded || !this.interactionDOMElement) {
      return;
    }
    var style = this.interactionDOMElement.style;
    if (self.navigator.msPointerEnabled) {
      style.msContentZooming = "none";
      style.msTouchAction = "none";
    } else if (this.supportsPointerEvents) {
      style.touchAction = "none";
    }
    if (this.supportsPointerEvents) {
      self.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions);
      self.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions);
      self.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions);
    } else {
      self.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions);
      self.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions);
    }
    if (this.supportsTouchEvents) {
      this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions);
    }
    this.eventsAdded = true;
  };
  InteractionManager2.prototype.removeEvents = function() {
    if (!this.eventsAdded || !this.interactionDOMElement) {
      return;
    }
    var style = this.interactionDOMElement.style;
    if (self.navigator.msPointerEnabled) {
      style.msContentZooming = "";
      style.msTouchAction = "";
    } else if (this.supportsPointerEvents) {
      style.touchAction = "";
    }
    if (this.supportsPointerEvents) {
      self.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions);
      self.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions);
      self.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions);
    } else {
      self.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions);
      self.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions);
    }
    if (this.supportsTouchEvents) {
      this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions);
    }
    this.interactionDOMElement = null;
    this.eventsAdded = false;
  };
  InteractionManager2.prototype.tickerUpdate = function(deltaTime) {
    this._deltaTime += deltaTime;
    if (this._deltaTime < this.interactionFrequency) {
      return;
    }
    this._deltaTime = 0;
    this.update();
  };
  InteractionManager2.prototype.update = function() {
    if (!this.interactionDOMElement) {
      return;
    }
    if (this._didMove) {
      this._didMove = false;
      return;
    }
    this.cursor = null;
    for (var k in this.activeInteractionData) {
      if (this.activeInteractionData.hasOwnProperty(k)) {
        var interactionData = this.activeInteractionData[k];
        if (interactionData.originalEvent && interactionData.pointerType !== "touch") {
          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
          this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, true);
        }
      }
    }
    this.setCursorMode(this.cursor);
  };
  InteractionManager2.prototype.setCursorMode = function(mode2) {
    mode2 = mode2 || "default";
    var applyStyles = true;
    if (self.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas) {
      applyStyles = false;
    }
    if (this.currentCursorMode === mode2) {
      return;
    }
    this.currentCursorMode = mode2;
    var style = this.cursorStyles[mode2];
    if (style) {
      switch (typeof style) {
        case "string":
          if (applyStyles) {
            this.interactionDOMElement.style.cursor = style;
          }
          break;
        case "function":
          style(mode2);
          break;
        case "object":
          if (applyStyles) {
            Object.assign(this.interactionDOMElement.style, style);
          }
          break;
      }
    } else if (applyStyles && typeof mode2 === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode2)) {
      this.interactionDOMElement.style.cursor = mode2;
    }
  };
  InteractionManager2.prototype.dispatchEvent = function(displayObject, eventString, eventData) {
    if (!eventData.stopPropagationHint || displayObject === eventData.stopsPropagatingAt) {
      eventData.currentTarget = displayObject;
      eventData.type = eventString;
      displayObject.emit(eventString, eventData);
      if (displayObject[eventString]) {
        displayObject[eventString](eventData);
      }
    }
  };
  InteractionManager2.prototype.delayDispatchEvent = function(displayObject, eventString, eventData) {
    this.delayedEvents.push({ displayObject, eventString, eventData });
  };
  InteractionManager2.prototype.mapPositionToPoint = function(point, x, y) {
    var rect;
    if (!this.interactionDOMElement.parentElement) {
      rect = {
        x: 0,
        y: 0,
        width: this.interactionDOMElement.width,
        height: this.interactionDOMElement.height,
        left: 0,
        top: 0
      };
    } else {
      rect = this.interactionDOMElement.getBoundingClientRect();
    }
    var resolutionMultiplier = 1 / this.resolution;
    point.x = (x - rect.left) * (this.interactionDOMElement.width / rect.width) * resolutionMultiplier;
    point.y = (y - rect.top) * (this.interactionDOMElement.height / rect.height) * resolutionMultiplier;
  };
  InteractionManager2.prototype.processInteractive = function(interactionEvent, displayObject, func, hitTest) {
    var hit = this.search.findHit(interactionEvent, displayObject, func, hitTest);
    var delayedEvents = this.delayedEvents;
    if (!delayedEvents.length) {
      return hit;
    }
    interactionEvent.stopPropagationHint = false;
    var delayedLen = delayedEvents.length;
    this.delayedEvents = [];
    for (var i = 0; i < delayedLen; i++) {
      var _a2 = delayedEvents[i], displayObject_1 = _a2.displayObject, eventString = _a2.eventString, eventData = _a2.eventData;
      if (eventData.stopsPropagatingAt === displayObject_1) {
        eventData.stopPropagationHint = true;
      }
      this.dispatchEvent(displayObject_1, eventString, eventData);
    }
    return hit;
  };
  InteractionManager2.prototype.onPointerDown = function(originalEvent) {
    if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
      return;
    }
    var events = this.normalizeToPointerData(originalEvent);
    if (this.autoPreventDefault && events[0].isNormalized) {
      var cancelable = originalEvent.cancelable || !("cancelable" in originalEvent);
      if (cancelable) {
        originalEvent.preventDefault();
      }
    }
    var eventLen = events.length;
    for (var i = 0; i < eventLen; i++) {
      var event = events[i];
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = originalEvent;
      this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerDown, true);
      this.emit("pointerdown", interactionEvent);
      if (event.pointerType === "touch") {
        this.emit("touchstart", interactionEvent);
      } else if (event.pointerType === "mouse" || event.pointerType === "pen") {
        var isRightButton = event.button === 2;
        this.emit(isRightButton ? "rightdown" : "mousedown", this.eventData);
      }
    }
  };
  InteractionManager2.prototype.processPointerDown = function(interactionEvent, displayObject, hit) {
    var data = interactionEvent.data;
    var id = interactionEvent.data.identifier;
    if (hit) {
      if (!displayObject.trackedPointers[id]) {
        displayObject.trackedPointers[id] = new InteractionTrackingData(id);
      }
      this.dispatchEvent(displayObject, "pointerdown", interactionEvent);
      if (data.pointerType === "touch") {
        this.dispatchEvent(displayObject, "touchstart", interactionEvent);
      } else if (data.pointerType === "mouse" || data.pointerType === "pen") {
        var isRightButton = data.button === 2;
        if (isRightButton) {
          displayObject.trackedPointers[id].rightDown = true;
        } else {
          displayObject.trackedPointers[id].leftDown = true;
        }
        this.dispatchEvent(displayObject, isRightButton ? "rightdown" : "mousedown", interactionEvent);
      }
    }
  };
  InteractionManager2.prototype.onPointerComplete = function(originalEvent, cancelled, func) {
    var events = this.normalizeToPointerData(originalEvent);
    var eventLen = events.length;
    var eventAppend = originalEvent.target !== this.interactionDOMElement ? "outside" : "";
    for (var i = 0; i < eventLen; i++) {
      var event = events[i];
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = originalEvent;
      this.processInteractive(interactionEvent, this.lastObjectRendered, func, cancelled || !eventAppend);
      this.emit(cancelled ? "pointercancel" : "pointerup" + eventAppend, interactionEvent);
      if (event.pointerType === "mouse" || event.pointerType === "pen") {
        var isRightButton = event.button === 2;
        this.emit(isRightButton ? "rightup" + eventAppend : "mouseup" + eventAppend, interactionEvent);
      } else if (event.pointerType === "touch") {
        this.emit(cancelled ? "touchcancel" : "touchend" + eventAppend, interactionEvent);
        this.releaseInteractionDataForPointerId(event.pointerId);
      }
    }
  };
  InteractionManager2.prototype.onPointerCancel = function(event) {
    if (this.supportsTouchEvents && event.pointerType === "touch") {
      return;
    }
    this.onPointerComplete(event, true, this.processPointerCancel);
  };
  InteractionManager2.prototype.processPointerCancel = function(interactionEvent, displayObject) {
    var data = interactionEvent.data;
    var id = interactionEvent.data.identifier;
    if (displayObject.trackedPointers[id] !== void 0) {
      delete displayObject.trackedPointers[id];
      this.dispatchEvent(displayObject, "pointercancel", interactionEvent);
      if (data.pointerType === "touch") {
        this.dispatchEvent(displayObject, "touchcancel", interactionEvent);
      }
    }
  };
  InteractionManager2.prototype.onPointerUp = function(event) {
    if (this.supportsTouchEvents && event.pointerType === "touch") {
      return;
    }
    this.onPointerComplete(event, false, this.processPointerUp);
  };
  InteractionManager2.prototype.processPointerUp = function(interactionEvent, displayObject, hit) {
    var data = interactionEvent.data;
    var id = interactionEvent.data.identifier;
    var trackingData = displayObject.trackedPointers[id];
    var isTouch = data.pointerType === "touch";
    var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
    var isMouseTap = false;
    if (isMouse) {
      var isRightButton = data.button === 2;
      var flags = InteractionTrackingData.FLAGS;
      var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
      var isDown = trackingData !== void 0 && trackingData.flags & test;
      if (hit) {
        this.dispatchEvent(displayObject, isRightButton ? "rightup" : "mouseup", interactionEvent);
        if (isDown) {
          this.dispatchEvent(displayObject, isRightButton ? "rightclick" : "click", interactionEvent);
          isMouseTap = true;
        }
      } else if (isDown) {
        this.dispatchEvent(displayObject, isRightButton ? "rightupoutside" : "mouseupoutside", interactionEvent);
      }
      if (trackingData) {
        if (isRightButton) {
          trackingData.rightDown = false;
        } else {
          trackingData.leftDown = false;
        }
      }
    }
    if (hit) {
      this.dispatchEvent(displayObject, "pointerup", interactionEvent);
      if (isTouch) {
        this.dispatchEvent(displayObject, "touchend", interactionEvent);
      }
      if (trackingData) {
        if (!isMouse || isMouseTap) {
          this.dispatchEvent(displayObject, "pointertap", interactionEvent);
        }
        if (isTouch) {
          this.dispatchEvent(displayObject, "tap", interactionEvent);
          trackingData.over = false;
        }
      }
    } else if (trackingData) {
      this.dispatchEvent(displayObject, "pointerupoutside", interactionEvent);
      if (isTouch) {
        this.dispatchEvent(displayObject, "touchendoutside", interactionEvent);
      }
    }
    if (trackingData && trackingData.none) {
      delete displayObject.trackedPointers[id];
    }
  };
  InteractionManager2.prototype.onPointerMove = function(originalEvent) {
    if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
      return;
    }
    var events = this.normalizeToPointerData(originalEvent);
    if (events[0].pointerType === "mouse" || events[0].pointerType === "pen") {
      this._didMove = true;
      this.cursor = null;
    }
    var eventLen = events.length;
    for (var i = 0; i < eventLen; i++) {
      var event = events[i];
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = originalEvent;
      this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerMove, true);
      this.emit("pointermove", interactionEvent);
      if (event.pointerType === "touch") {
        this.emit("touchmove", interactionEvent);
      }
      if (event.pointerType === "mouse" || event.pointerType === "pen") {
        this.emit("mousemove", interactionEvent);
      }
    }
    if (events[0].pointerType === "mouse") {
      this.setCursorMode(this.cursor);
    }
  };
  InteractionManager2.prototype.processPointerMove = function(interactionEvent, displayObject, hit) {
    var data = interactionEvent.data;
    var isTouch = data.pointerType === "touch";
    var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
    if (isMouse) {
      this.processPointerOverOut(interactionEvent, displayObject, hit);
    }
    if (!this.moveWhenInside || hit) {
      this.dispatchEvent(displayObject, "pointermove", interactionEvent);
      if (isTouch) {
        this.dispatchEvent(displayObject, "touchmove", interactionEvent);
      }
      if (isMouse) {
        this.dispatchEvent(displayObject, "mousemove", interactionEvent);
      }
    }
  };
  InteractionManager2.prototype.onPointerOut = function(originalEvent) {
    if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
      return;
    }
    var events = this.normalizeToPointerData(originalEvent);
    var event = events[0];
    if (event.pointerType === "mouse") {
      this.mouseOverRenderer = false;
      this.setCursorMode(null);
    }
    var interactionData = this.getInteractionDataForPointerId(event);
    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
    interactionEvent.data.originalEvent = event;
    this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, false);
    this.emit("pointerout", interactionEvent);
    if (event.pointerType === "mouse" || event.pointerType === "pen") {
      this.emit("mouseout", interactionEvent);
    } else {
      this.releaseInteractionDataForPointerId(interactionData.identifier);
    }
  };
  InteractionManager2.prototype.processPointerOverOut = function(interactionEvent, displayObject, hit) {
    var data = interactionEvent.data;
    var id = interactionEvent.data.identifier;
    var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
    var trackingData = displayObject.trackedPointers[id];
    if (hit && !trackingData) {
      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);
    }
    if (trackingData === void 0) {
      return;
    }
    if (hit && this.mouseOverRenderer) {
      if (!trackingData.over) {
        trackingData.over = true;
        this.delayDispatchEvent(displayObject, "pointerover", interactionEvent);
        if (isMouse) {
          this.delayDispatchEvent(displayObject, "mouseover", interactionEvent);
        }
      }
      if (isMouse && this.cursor === null) {
        this.cursor = displayObject.cursor;
      }
    } else if (trackingData.over) {
      trackingData.over = false;
      this.dispatchEvent(displayObject, "pointerout", this.eventData);
      if (isMouse) {
        this.dispatchEvent(displayObject, "mouseout", interactionEvent);
      }
      if (trackingData.none) {
        delete displayObject.trackedPointers[id];
      }
    }
  };
  InteractionManager2.prototype.onPointerOver = function(originalEvent) {
    var events = this.normalizeToPointerData(originalEvent);
    var event = events[0];
    var interactionData = this.getInteractionDataForPointerId(event);
    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
    interactionEvent.data.originalEvent = event;
    if (event.pointerType === "mouse") {
      this.mouseOverRenderer = true;
    }
    this.emit("pointerover", interactionEvent);
    if (event.pointerType === "mouse" || event.pointerType === "pen") {
      this.emit("mouseover", interactionEvent);
    }
  };
  InteractionManager2.prototype.getInteractionDataForPointerId = function(event) {
    var pointerId = event.pointerId;
    var interactionData;
    if (pointerId === MOUSE_POINTER_ID || event.pointerType === "mouse") {
      interactionData = this.mouse;
    } else if (this.activeInteractionData[pointerId]) {
      interactionData = this.activeInteractionData[pointerId];
    } else {
      interactionData = this.interactionDataPool.pop() || new InteractionData();
      interactionData.identifier = pointerId;
      this.activeInteractionData[pointerId] = interactionData;
    }
    interactionData.copyEvent(event);
    return interactionData;
  };
  InteractionManager2.prototype.releaseInteractionDataForPointerId = function(pointerId) {
    var interactionData = this.activeInteractionData[pointerId];
    if (interactionData) {
      delete this.activeInteractionData[pointerId];
      interactionData.reset();
      this.interactionDataPool.push(interactionData);
    }
  };
  InteractionManager2.prototype.configureInteractionEventForDOMEvent = function(interactionEvent, pointerEvent, interactionData) {
    interactionEvent.data = interactionData;
    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
    if (pointerEvent.pointerType === "touch") {
      pointerEvent.globalX = interactionData.global.x;
      pointerEvent.globalY = interactionData.global.y;
    }
    interactionData.originalEvent = pointerEvent;
    interactionEvent.reset();
    return interactionEvent;
  };
  InteractionManager2.prototype.normalizeToPointerData = function(event) {
    var normalizedEvents = [];
    if (this.supportsTouchEvents && event instanceof TouchEvent) {
      for (var i = 0, li = event.changedTouches.length; i < li; i++) {
        var touch = event.changedTouches[i];
        if (typeof touch.button === "undefined") {
          touch.button = event.touches.length ? 1 : 0;
        }
        if (typeof touch.buttons === "undefined") {
          touch.buttons = event.touches.length ? 1 : 0;
        }
        if (typeof touch.isPrimary === "undefined") {
          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
        }
        if (typeof touch.width === "undefined") {
          touch.width = touch.radiusX || 1;
        }
        if (typeof touch.height === "undefined") {
          touch.height = touch.radiusY || 1;
        }
        if (typeof touch.tiltX === "undefined") {
          touch.tiltX = 0;
        }
        if (typeof touch.tiltY === "undefined") {
          touch.tiltY = 0;
        }
        if (typeof touch.pointerType === "undefined") {
          touch.pointerType = "touch";
        }
        if (typeof touch.pointerId === "undefined") {
          touch.pointerId = touch.identifier || 0;
        }
        if (typeof touch.pressure === "undefined") {
          touch.pressure = touch.force || 0.5;
        }
        if (typeof touch.twist === "undefined") {
          touch.twist = 0;
        }
        if (typeof touch.tangentialPressure === "undefined") {
          touch.tangentialPressure = 0;
        }
        if (typeof touch.layerX === "undefined") {
          touch.layerX = touch.offsetX = touch.clientX;
        }
        if (typeof touch.layerY === "undefined") {
          touch.layerY = touch.offsetY = touch.clientY;
        }
        touch.isNormalized = true;
        normalizedEvents.push(touch);
      }
    } else if (!self.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof self.PointerEvent))) {
      var tempEvent = event;
      if (typeof tempEvent.isPrimary === "undefined") {
        tempEvent.isPrimary = true;
      }
      if (typeof tempEvent.width === "undefined") {
        tempEvent.width = 1;
      }
      if (typeof tempEvent.height === "undefined") {
        tempEvent.height = 1;
      }
      if (typeof tempEvent.tiltX === "undefined") {
        tempEvent.tiltX = 0;
      }
      if (typeof tempEvent.tiltY === "undefined") {
        tempEvent.tiltY = 0;
      }
      if (typeof tempEvent.pointerType === "undefined") {
        tempEvent.pointerType = "mouse";
      }
      if (typeof tempEvent.pointerId === "undefined") {
        tempEvent.pointerId = MOUSE_POINTER_ID;
      }
      if (typeof tempEvent.pressure === "undefined") {
        tempEvent.pressure = 0.5;
      }
      if (typeof tempEvent.twist === "undefined") {
        tempEvent.twist = 0;
      }
      if (typeof tempEvent.tangentialPressure === "undefined") {
        tempEvent.tangentialPressure = 0;
      }
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  };
  InteractionManager2.prototype.destroy = function() {
    this.removeEvents();
    this.removeTickerListener();
    this.removeAllListeners();
    this.renderer = null;
    this.mouse = null;
    this.eventData = null;
    this.interactionDOMElement = null;
    this.onPointerDown = null;
    this.processPointerDown = null;
    this.onPointerUp = null;
    this.processPointerUp = null;
    this.onPointerCancel = null;
    this.processPointerCancel = null;
    this.onPointerMove = null;
    this.processPointerMove = null;
    this.onPointerOut = null;
    this.processPointerOverOut = null;
    this.onPointerOver = null;
    this.search = null;
  };
  return InteractionManager2;
}(EventEmitter);
/*!
 * @pixi/runner - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/runner is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Runner = function() {
  function Runner2(name) {
    this.items = [];
    this._name = name;
    this._aliasCount = 0;
  }
  Runner2.prototype.emit = function(a0, a1, a2, a3, a4, a5, a6, a7) {
    if (arguments.length > 8) {
      throw new Error("max arguments reached");
    }
    var _a2 = this, name = _a2.name, items = _a2.items;
    this._aliasCount++;
    for (var i = 0, len = items.length; i < len; i++) {
      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
    }
    if (items === this.items) {
      this._aliasCount--;
    }
    return this;
  };
  Runner2.prototype.ensureNonAliasedItems = function() {
    if (this._aliasCount > 0 && this.items.length > 1) {
      this._aliasCount = 0;
      this.items = this.items.slice(0);
    }
  };
  Runner2.prototype.add = function(item) {
    if (item[this._name]) {
      this.ensureNonAliasedItems();
      this.remove(item);
      this.items.push(item);
    }
    return this;
  };
  Runner2.prototype.remove = function(item) {
    var index2 = this.items.indexOf(item);
    if (index2 !== -1) {
      this.ensureNonAliasedItems();
      this.items.splice(index2, 1);
    }
    return this;
  };
  Runner2.prototype.contains = function(item) {
    return this.items.indexOf(item) !== -1;
  };
  Runner2.prototype.removeAll = function() {
    this.ensureNonAliasedItems();
    this.items.length = 0;
    return this;
  };
  Runner2.prototype.destroy = function() {
    this.removeAll();
    this.items = null;
    this._name = null;
  };
  Object.defineProperty(Runner2.prototype, "empty", {
    get: function() {
      return this.items.length === 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Runner2.prototype, "name", {
    get: function() {
      return this._name;
    },
    enumerable: false,
    configurable: true
  });
  return Runner2;
}();
Object.defineProperties(Runner.prototype, {
  dispatch: { value: Runner.prototype.emit },
  run: { value: Runner.prototype.emit }
});
/*!
 * @pixi/core - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.PREFER_ENV = isMobile.any ? ENV$3.WEBGL : ENV$3.WEBGL2;
settings.STRICT_TEXTURE_CACHE = false;
var INSTALLED = [];
function autoDetectResource(source, options) {
  if (!source) {
    return null;
  }
  var extension = "";
  if (typeof source === "string") {
    var result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
    if (result) {
      extension = result[1].toLowerCase();
    }
  }
  for (var i = INSTALLED.length - 1; i >= 0; --i) {
    var ResourcePlugin = INSTALLED[i];
    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
      return new ResourcePlugin(source, options);
    }
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$h = function(d, b) {
  extendStatics$h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$h(d, b);
};
function __extends$h(d, b) {
  extendStatics$h(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    var arguments$1 = arguments;
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments$1[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) {
          t[p] = s[p];
        }
      }
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e2) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0) {
      t[p] = s[p];
    }
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") {
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0) {
        t[p[i]] = s[p[i]];
      }
    }
  }
  return t;
}
var Resource = function() {
  function Resource2(width, height) {
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    this._width = width;
    this._height = height;
    this.destroyed = false;
    this.internal = false;
    this.onResize = new Runner("setRealSize");
    this.onUpdate = new Runner("update");
    this.onError = new Runner("onError");
  }
  Resource2.prototype.bind = function(baseTexture) {
    this.onResize.add(baseTexture);
    this.onUpdate.add(baseTexture);
    this.onError.add(baseTexture);
    if (this._width || this._height) {
      this.onResize.emit(this._width, this._height);
    }
  };
  Resource2.prototype.unbind = function(baseTexture) {
    this.onResize.remove(baseTexture);
    this.onUpdate.remove(baseTexture);
    this.onError.remove(baseTexture);
  };
  Resource2.prototype.resize = function(width, height) {
    if (width !== this._width || height !== this._height) {
      this._width = width;
      this._height = height;
      this.onResize.emit(width, height);
    }
  };
  Object.defineProperty(Resource2.prototype, "valid", {
    get: function() {
      return !!this._width && !!this._height;
    },
    enumerable: false,
    configurable: true
  });
  Resource2.prototype.update = function() {
    if (!this.destroyed) {
      this.onUpdate.emit();
    }
  };
  Resource2.prototype.load = function() {
    return Promise.resolve(this);
  };
  Object.defineProperty(Resource2.prototype, "width", {
    get: function() {
      return this._width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Resource2.prototype, "height", {
    get: function() {
      return this._height;
    },
    enumerable: false,
    configurable: true
  });
  Resource2.prototype.style = function(_renderer, _baseTexture, _glTexture) {
    return false;
  };
  Resource2.prototype.dispose = function() {
  };
  Resource2.prototype.destroy = function() {
    if (!this.destroyed) {
      this.destroyed = true;
      this.dispose();
      this.onError.removeAll();
      this.onError = null;
      this.onResize.removeAll();
      this.onResize = null;
      this.onUpdate.removeAll();
      this.onUpdate = null;
    }
  };
  Resource2.test = function(_source, _extension) {
    return false;
  };
  return Resource2;
}();
var BufferResource = function(_super) {
  __extends$h(BufferResource2, _super);
  function BufferResource2(source, options) {
    var _this = this;
    var _a2 = options || {}, width = _a2.width, height = _a2.height;
    if (!width || !height) {
      throw new Error("BufferResource width or height invalid");
    }
    _this = _super.call(this, width, height) || this;
    _this.data = source;
    return _this;
  }
  BufferResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
    var gl = renderer.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES$3.UNPACK);
    var width = baseTexture.realWidth;
    var height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  };
  BufferResource2.prototype.dispose = function() {
    this.data = null;
  };
  BufferResource2.test = function(source) {
    return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
  };
  return BufferResource2;
}(Resource);
var defaultBufferOptions = {
  scaleMode: SCALE_MODES$3.NEAREST,
  format: FORMATS$3.RGBA,
  alphaMode: ALPHA_MODES$3.NPM
};
var BaseTexture = function(_super) {
  __extends$h(BaseTexture2, _super);
  function BaseTexture2(resource, options) {
    if (resource === void 0) {
      resource = null;
    }
    if (options === void 0) {
      options = null;
    }
    var _this = _super.call(this) || this;
    options = options || {};
    var alphaMode = options.alphaMode, mipmap = options.mipmap, anisotropicLevel = options.anisotropicLevel, scaleMode = options.scaleMode, width = options.width, height = options.height, wrapMode = options.wrapMode, format2 = options.format, type = options.type, target = options.target, resolution = options.resolution, resourceOptions = options.resourceOptions;
    if (resource && !(resource instanceof Resource)) {
      resource = autoDetectResource(resource, resourceOptions);
      resource.internal = true;
    }
    _this.resolution = resolution || settings.RESOLUTION;
    _this.width = Math.round((width || 0) * _this.resolution) / _this.resolution;
    _this.height = Math.round((height || 0) * _this.resolution) / _this.resolution;
    _this._mipmap = mipmap !== void 0 ? mipmap : settings.MIPMAP_TEXTURES;
    _this.anisotropicLevel = anisotropicLevel !== void 0 ? anisotropicLevel : settings.ANISOTROPIC_LEVEL;
    _this._wrapMode = wrapMode || settings.WRAP_MODE;
    _this._scaleMode = scaleMode !== void 0 ? scaleMode : settings.SCALE_MODE;
    _this.format = format2 || FORMATS$3.RGBA;
    _this.type = type || TYPES$3.UNSIGNED_BYTE;
    _this.target = target || TARGETS$3.TEXTURE_2D;
    _this.alphaMode = alphaMode !== void 0 ? alphaMode : ALPHA_MODES$3.UNPACK;
    _this.uid = uid();
    _this.touched = 0;
    _this.isPowerOfTwo = false;
    _this._refreshPOT();
    _this._glTextures = {};
    _this.dirtyId = 0;
    _this.dirtyStyleId = 0;
    _this.cacheId = null;
    _this.valid = width > 0 && height > 0;
    _this.textureCacheIds = [];
    _this.destroyed = false;
    _this.resource = null;
    _this._batchEnabled = 0;
    _this._batchLocation = 0;
    _this.parentTextureArray = null;
    _this.setResource(resource);
    return _this;
  }
  Object.defineProperty(BaseTexture2.prototype, "realWidth", {
    get: function() {
      return Math.round(this.width * this.resolution);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "realHeight", {
    get: function() {
      return Math.round(this.height * this.resolution);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "mipmap", {
    get: function() {
      return this._mipmap;
    },
    set: function(value) {
      if (this._mipmap !== value) {
        this._mipmap = value;
        this.dirtyStyleId++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "scaleMode", {
    get: function() {
      return this._scaleMode;
    },
    set: function(value) {
      if (this._scaleMode !== value) {
        this._scaleMode = value;
        this.dirtyStyleId++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "wrapMode", {
    get: function() {
      return this._wrapMode;
    },
    set: function(value) {
      if (this._wrapMode !== value) {
        this._wrapMode = value;
        this.dirtyStyleId++;
      }
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype.setStyle = function(scaleMode, mipmap) {
    var dirty;
    if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
      this.scaleMode = scaleMode;
      dirty = true;
    }
    if (mipmap !== void 0 && mipmap !== this.mipmap) {
      this.mipmap = mipmap;
      dirty = true;
    }
    if (dirty) {
      this.dirtyStyleId++;
    }
    return this;
  };
  BaseTexture2.prototype.setSize = function(desiredWidth, desiredHeight, resolution) {
    resolution = resolution || this.resolution;
    return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
  };
  BaseTexture2.prototype.setRealSize = function(realWidth, realHeight, resolution) {
    this.resolution = resolution || this.resolution;
    this.width = Math.round(realWidth) / this.resolution;
    this.height = Math.round(realHeight) / this.resolution;
    this._refreshPOT();
    this.update();
    return this;
  };
  BaseTexture2.prototype._refreshPOT = function() {
    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
  };
  BaseTexture2.prototype.setResolution = function(resolution) {
    var oldResolution = this.resolution;
    if (oldResolution === resolution) {
      return this;
    }
    this.resolution = resolution;
    if (this.valid) {
      this.width = Math.round(this.width * oldResolution) / resolution;
      this.height = Math.round(this.height * oldResolution) / resolution;
      this.emit("update", this);
    }
    this._refreshPOT();
    return this;
  };
  BaseTexture2.prototype.setResource = function(resource) {
    if (this.resource === resource) {
      return this;
    }
    if (this.resource) {
      throw new Error("Resource can be set only once");
    }
    resource.bind(this);
    this.resource = resource;
    return this;
  };
  BaseTexture2.prototype.update = function() {
    if (!this.valid) {
      if (this.width > 0 && this.height > 0) {
        this.valid = true;
        this.emit("loaded", this);
        this.emit("update", this);
      }
    } else {
      this.dirtyId++;
      this.dirtyStyleId++;
      this.emit("update", this);
    }
  };
  BaseTexture2.prototype.onError = function(event) {
    this.emit("error", this, event);
  };
  BaseTexture2.prototype.destroy = function() {
    if (this.resource) {
      this.resource.unbind(this);
      if (this.resource.internal) {
        this.resource.destroy();
      }
      this.resource = null;
    }
    if (this.cacheId) {
      delete BaseTextureCache[this.cacheId];
      delete TextureCache[this.cacheId];
      this.cacheId = null;
    }
    this.dispose();
    BaseTexture2.removeFromCache(this);
    this.textureCacheIds = null;
    this.destroyed = true;
  };
  BaseTexture2.prototype.dispose = function() {
    this.emit("dispose", this);
  };
  BaseTexture2.prototype.castToBaseTexture = function() {
    return this;
  };
  BaseTexture2.from = function(source, options, strict) {
    if (strict === void 0) {
      strict = settings.STRICT_TEXTURE_CACHE;
    }
    var isFrame = typeof source === "string";
    var cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else {
      if (!source._pixiId) {
        var prefix = options && options.pixiIdPrefix || "pixiid";
        source._pixiId = prefix + "_" + uid();
      }
      cacheId = source._pixiId;
    }
    var baseTexture = BaseTextureCache[cacheId];
    if (isFrame && strict && !baseTexture) {
      throw new Error('The cacheId "' + cacheId + '" does not exist in BaseTextureCache.');
    }
    if (!baseTexture) {
      baseTexture = new BaseTexture2(source, options);
      baseTexture.cacheId = cacheId;
      BaseTexture2.addToCache(baseTexture, cacheId);
    }
    return baseTexture;
  };
  BaseTexture2.fromBuffer = function(buffer2, width, height, options) {
    buffer2 = buffer2 || new Float32Array(width * height * 4);
    var resource = new BufferResource(buffer2, { width, height });
    var type = buffer2 instanceof Float32Array ? TYPES$3.FLOAT : TYPES$3.UNSIGNED_BYTE;
    return new BaseTexture2(resource, Object.assign(defaultBufferOptions, options || { width, height, type }));
  };
  BaseTexture2.addToCache = function(baseTexture, id) {
    if (id) {
      if (baseTexture.textureCacheIds.indexOf(id) === -1) {
        baseTexture.textureCacheIds.push(id);
      }
      if (BaseTextureCache[id]) {
        console.warn("BaseTexture added to the cache with an id [" + id + "] that already had an entry");
      }
      BaseTextureCache[id] = baseTexture;
    }
  };
  BaseTexture2.removeFromCache = function(baseTexture) {
    if (typeof baseTexture === "string") {
      var baseTextureFromCache = BaseTextureCache[baseTexture];
      if (baseTextureFromCache) {
        var index2 = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
        if (index2 > -1) {
          baseTextureFromCache.textureCacheIds.splice(index2, 1);
        }
        delete BaseTextureCache[baseTexture];
        return baseTextureFromCache;
      }
    } else if (baseTexture && baseTexture.textureCacheIds) {
      for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) {
        delete BaseTextureCache[baseTexture.textureCacheIds[i]];
      }
      baseTexture.textureCacheIds.length = 0;
      return baseTexture;
    }
    return null;
  };
  BaseTexture2._globalBatch = 0;
  return BaseTexture2;
}(EventEmitter);
var AbstractMultiResource = function(_super) {
  __extends$h(AbstractMultiResource2, _super);
  function AbstractMultiResource2(length, options) {
    var _this = this;
    var _a2 = options || {}, width = _a2.width, height = _a2.height;
    _this = _super.call(this, width, height) || this;
    _this.items = [];
    _this.itemDirtyIds = [];
    for (var i = 0; i < length; i++) {
      var partTexture = new BaseTexture();
      _this.items.push(partTexture);
      _this.itemDirtyIds.push(-2);
    }
    _this.length = length;
    _this._load = null;
    _this.baseTexture = null;
    return _this;
  }
  AbstractMultiResource2.prototype.initFromArray = function(resources2, options) {
    for (var i = 0; i < this.length; i++) {
      if (!resources2[i]) {
        continue;
      }
      if (resources2[i].castToBaseTexture) {
        this.addBaseTextureAt(resources2[i].castToBaseTexture(), i);
      } else if (resources2[i] instanceof Resource) {
        this.addResourceAt(resources2[i], i);
      } else {
        this.addResourceAt(autoDetectResource(resources2[i], options), i);
      }
    }
  };
  AbstractMultiResource2.prototype.dispose = function() {
    for (var i = 0, len = this.length; i < len; i++) {
      this.items[i].destroy();
    }
    this.items = null;
    this.itemDirtyIds = null;
    this._load = null;
  };
  AbstractMultiResource2.prototype.addResourceAt = function(resource, index2) {
    if (!this.items[index2]) {
      throw new Error("Index " + index2 + " is out of bounds");
    }
    if (resource.valid && !this.valid) {
      this.resize(resource.width, resource.height);
    }
    this.items[index2].setResource(resource);
    return this;
  };
  AbstractMultiResource2.prototype.bind = function(baseTexture) {
    if (this.baseTexture !== null) {
      throw new Error("Only one base texture per TextureArray is allowed");
    }
    _super.prototype.bind.call(this, baseTexture);
    for (var i = 0; i < this.length; i++) {
      this.items[i].parentTextureArray = baseTexture;
      this.items[i].on("update", baseTexture.update, baseTexture);
    }
  };
  AbstractMultiResource2.prototype.unbind = function(baseTexture) {
    _super.prototype.unbind.call(this, baseTexture);
    for (var i = 0; i < this.length; i++) {
      this.items[i].parentTextureArray = null;
      this.items[i].off("update", baseTexture.update, baseTexture);
    }
  };
  AbstractMultiResource2.prototype.load = function() {
    var _this = this;
    if (this._load) {
      return this._load;
    }
    var resources2 = this.items.map(function(item) {
      return item.resource;
    }).filter(function(item) {
      return item;
    });
    var promises = resources2.map(function(item) {
      return item.load();
    });
    this._load = Promise.all(promises).then(function() {
      var _a2 = _this.items[0], realWidth = _a2.realWidth, realHeight = _a2.realHeight;
      _this.resize(realWidth, realHeight);
      return Promise.resolve(_this);
    });
    return this._load;
  };
  return AbstractMultiResource2;
}(Resource);
var ArrayResource = function(_super) {
  __extends$h(ArrayResource2, _super);
  function ArrayResource2(source, options) {
    var _this = this;
    var _a2 = options || {}, width = _a2.width, height = _a2.height;
    var urls;
    var length;
    if (Array.isArray(source)) {
      urls = source;
      length = source.length;
    } else {
      length = source;
    }
    _this = _super.call(this, length, { width, height }) || this;
    if (urls) {
      _this.initFromArray(urls, options);
    }
    return _this;
  }
  ArrayResource2.prototype.addBaseTextureAt = function(baseTexture, index2) {
    if (baseTexture.resource) {
      this.addResourceAt(baseTexture.resource, index2);
    } else {
      throw new Error("ArrayResource does not support RenderTexture");
    }
    return this;
  };
  ArrayResource2.prototype.bind = function(baseTexture) {
    _super.prototype.bind.call(this, baseTexture);
    baseTexture.target = TARGETS$3.TEXTURE_2D_ARRAY;
  };
  ArrayResource2.prototype.upload = function(renderer, texture, glTexture) {
    var _a2 = this, length = _a2.length, itemDirtyIds = _a2.itemDirtyIds, items = _a2.items;
    var gl = renderer.gl;
    if (glTexture.dirtyId < 0) {
      gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);
    }
    for (var i = 0; i < length; i++) {
      var item = items[i];
      if (itemDirtyIds[i] < item.dirtyId) {
        itemDirtyIds[i] = item.dirtyId;
        if (item.valid) {
          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i, item.resource.width, item.resource.height, 1, texture.format, glTexture.type, item.resource.source);
        }
      }
    }
    return true;
  };
  return ArrayResource2;
}(AbstractMultiResource);
var BaseImageResource = function(_super) {
  __extends$h(BaseImageResource2, _super);
  function BaseImageResource2(source) {
    var _this = this;
    var sourceAny = source;
    var width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
    var height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
    _this = _super.call(this, width, height) || this;
    _this.source = source;
    _this.noSubImage = false;
    return _this;
  }
  BaseImageResource2.crossOrigin = function(element, url2, crossorigin) {
    if (crossorigin === void 0 && url2.indexOf("data:") !== 0) {
      element.crossOrigin = determineCrossOrigin(url2);
    } else if (crossorigin !== false) {
      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
    }
  };
  BaseImageResource2.prototype.upload = function(renderer, baseTexture, glTexture, source) {
    var gl = renderer.gl;
    var width = baseTexture.realWidth;
    var height = baseTexture.realHeight;
    source = source || this.source;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES$3.UNPACK);
    if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);
    }
    return true;
  };
  BaseImageResource2.prototype.update = function() {
    if (this.destroyed) {
      return;
    }
    var source = this.source;
    var width = source.naturalWidth || source.videoWidth || source.width;
    var height = source.naturalHeight || source.videoHeight || source.height;
    this.resize(width, height);
    _super.prototype.update.call(this);
  };
  BaseImageResource2.prototype.dispose = function() {
    this.source = null;
  };
  return BaseImageResource2;
}(Resource);
var CanvasResource = function(_super) {
  __extends$h(CanvasResource2, _super);
  function CanvasResource2(source) {
    return _super.call(this, source) || this;
  }
  CanvasResource2.test = function(source) {
    var OffscreenCanvas2 = self.OffscreenCanvas;
    if (OffscreenCanvas2 && source instanceof OffscreenCanvas2) {
      return true;
    }
    return self.HTMLCanvasElement && source instanceof HTMLCanvasElement;
  };
  return CanvasResource2;
}(BaseImageResource);
var CubeResource = function(_super) {
  __extends$h(CubeResource2, _super);
  function CubeResource2(source, options) {
    var _this = this;
    var _a2 = options || {}, width = _a2.width, height = _a2.height, autoLoad = _a2.autoLoad, linkBaseTexture = _a2.linkBaseTexture;
    if (source && source.length !== CubeResource2.SIDES) {
      throw new Error("Invalid length. Got " + source.length + ", expected 6");
    }
    _this = _super.call(this, 6, { width, height }) || this;
    for (var i = 0; i < CubeResource2.SIDES; i++) {
      _this.items[i].target = TARGETS$3.TEXTURE_CUBE_MAP_POSITIVE_X + i;
    }
    _this.linkBaseTexture = linkBaseTexture !== false;
    if (source) {
      _this.initFromArray(source, options);
    }
    if (autoLoad !== false) {
      _this.load();
    }
    return _this;
  }
  CubeResource2.prototype.bind = function(baseTexture) {
    _super.prototype.bind.call(this, baseTexture);
    baseTexture.target = TARGETS$3.TEXTURE_CUBE_MAP;
  };
  CubeResource2.prototype.addBaseTextureAt = function(baseTexture, index2, linkBaseTexture) {
    if (!this.items[index2]) {
      throw new Error("Index " + index2 + " is out of bounds");
    }
    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
      if (baseTexture.resource) {
        this.addResourceAt(baseTexture.resource, index2);
      } else {
        throw new Error("CubeResource does not support copying of renderTexture.");
      }
    } else {
      baseTexture.target = TARGETS$3.TEXTURE_CUBE_MAP_POSITIVE_X + index2;
      baseTexture.parentTextureArray = this.baseTexture;
      this.items[index2] = baseTexture;
    }
    if (baseTexture.valid && !this.valid) {
      this.resize(baseTexture.realWidth, baseTexture.realHeight);
    }
    this.items[index2] = baseTexture;
    return this;
  };
  CubeResource2.prototype.upload = function(renderer, _baseTexture, glTexture) {
    var dirty = this.itemDirtyIds;
    for (var i = 0; i < CubeResource2.SIDES; i++) {
      var side = this.items[i];
      if (dirty[i] < side.dirtyId) {
        if (side.valid && side.resource) {
          side.resource.upload(renderer, side, glTexture);
          dirty[i] = side.dirtyId;
        } else if (dirty[i] < -1) {
          renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
          dirty[i] = -1;
        }
      }
    }
    return true;
  };
  CubeResource2.test = function(source) {
    return Array.isArray(source) && source.length === CubeResource2.SIDES;
  };
  CubeResource2.SIDES = 6;
  return CubeResource2;
}(AbstractMultiResource);
var ImageResource = function(_super) {
  __extends$h(ImageResource2, _super);
  function ImageResource2(source, options) {
    var _this = this;
    options = options || {};
    if (!(source instanceof HTMLImageElement)) {
      var imageElement = new Image();
      BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
      imageElement.src = source;
      source = imageElement;
    }
    _this = _super.call(this, source) || this;
    if (!source.complete && !!_this._width && !!_this._height) {
      _this._width = 0;
      _this._height = 0;
    }
    _this.url = source.src;
    _this._process = null;
    _this.preserveBitmap = false;
    _this.createBitmap = (options.createBitmap !== void 0 ? options.createBitmap : settings.CREATE_IMAGE_BITMAP) && !!self.createImageBitmap;
    _this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
    _this.bitmap = null;
    _this._load = null;
    if (options.autoLoad !== false) {
      _this.load();
    }
    return _this;
  }
  ImageResource2.prototype.load = function(createBitmap) {
    var _this = this;
    if (this._load) {
      return this._load;
    }
    if (createBitmap !== void 0) {
      this.createBitmap = createBitmap;
    }
    this._load = new Promise(function(resolve2, reject2) {
      var source = _this.source;
      _this.url = source.src;
      var completed = function() {
        if (_this.destroyed) {
          return;
        }
        source.onload = null;
        source.onerror = null;
        _this.resize(source.width, source.height);
        _this._load = null;
        if (_this.createBitmap) {
          resolve2(_this.process());
        } else {
          resolve2(_this);
        }
      };
      if (source.complete && source.src) {
        completed();
      } else {
        source.onload = completed;
        source.onerror = function(event) {
          reject2(event);
          _this.onError.emit(event);
        };
      }
    });
    return this._load;
  };
  ImageResource2.prototype.process = function() {
    var _this = this;
    var source = this.source;
    if (this._process !== null) {
      return this._process;
    }
    if (this.bitmap !== null || !self.createImageBitmap) {
      return Promise.resolve(this);
    }
    var createImageBitmap = self.createImageBitmap;
    var cors = !source.crossOrigin || source.crossOrigin === "anonymous";
    this._process = fetch(source.src, {
      mode: cors ? "cors" : "no-cors"
    }).then(function(r) {
      return r.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, 0, 0, source.width, source.height, {
        premultiplyAlpha: _this.alphaMode === ALPHA_MODES$3.UNPACK ? "premultiply" : "none"
      });
    }).then(function(bitmap) {
      if (_this.destroyed) {
        return Promise.reject();
      }
      _this.bitmap = bitmap;
      _this.update();
      _this._process = null;
      return Promise.resolve(_this);
    });
    return this._process;
  };
  ImageResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
    if (typeof this.alphaMode === "number") {
      baseTexture.alphaMode = this.alphaMode;
    }
    if (!this.createBitmap) {
      return _super.prototype.upload.call(this, renderer, baseTexture, glTexture);
    }
    if (!this.bitmap) {
      this.process();
      if (!this.bitmap) {
        return false;
      }
    }
    _super.prototype.upload.call(this, renderer, baseTexture, glTexture, this.bitmap);
    if (!this.preserveBitmap) {
      var flag = true;
      var glTextures = baseTexture._glTextures;
      for (var key in glTextures) {
        var otherTex = glTextures[key];
        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
          flag = false;
          break;
        }
      }
      if (flag) {
        if (this.bitmap.close) {
          this.bitmap.close();
        }
        this.bitmap = null;
      }
    }
    return true;
  };
  ImageResource2.prototype.dispose = function() {
    this.source.onload = null;
    this.source.onerror = null;
    _super.prototype.dispose.call(this);
    if (this.bitmap) {
      this.bitmap.close();
      this.bitmap = null;
    }
    this._process = null;
    this._load = null;
  };
  ImageResource2.test = function(source) {
    return typeof source === "string" || source instanceof HTMLImageElement;
  };
  return ImageResource2;
}(BaseImageResource);
var SVGResource = function(_super) {
  __extends$h(SVGResource2, _super);
  function SVGResource2(sourceBase64, options) {
    var _this = this;
    options = options || {};
    _this = _super.call(this, document.createElement("canvas")) || this;
    _this._width = 0;
    _this._height = 0;
    _this.svg = sourceBase64;
    _this.scale = options.scale || 1;
    _this._overrideWidth = options.width;
    _this._overrideHeight = options.height;
    _this._resolve = null;
    _this._crossorigin = options.crossorigin;
    _this._load = null;
    if (options.autoLoad !== false) {
      _this.load();
    }
    return _this;
  }
  SVGResource2.prototype.load = function() {
    var _this = this;
    if (this._load) {
      return this._load;
    }
    this._load = new Promise(function(resolve2) {
      _this._resolve = function() {
        _this.resize(_this.source.width, _this.source.height);
        resolve2(_this);
      };
      if (SVGResource2.SVG_XML.test(_this.svg.trim())) {
        if (!btoa) {
          throw new Error("Your browser doesn't support base64 conversions.");
        }
        _this.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(_this.svg)));
      }
      _this._loadSvg();
    });
    return this._load;
  };
  SVGResource2.prototype._loadSvg = function() {
    var _this = this;
    var tempImage = new Image();
    BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
    tempImage.src = this.svg;
    tempImage.onerror = function(event) {
      if (!_this._resolve) {
        return;
      }
      tempImage.onerror = null;
      _this.onError.emit(event);
    };
    tempImage.onload = function() {
      if (!_this._resolve) {
        return;
      }
      var svgWidth = tempImage.width;
      var svgHeight = tempImage.height;
      if (!svgWidth || !svgHeight) {
        throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
      }
      var width = svgWidth * _this.scale;
      var height = svgHeight * _this.scale;
      if (_this._overrideWidth || _this._overrideHeight) {
        width = _this._overrideWidth || _this._overrideHeight / svgHeight * svgWidth;
        height = _this._overrideHeight || _this._overrideWidth / svgWidth * svgHeight;
      }
      width = Math.round(width);
      height = Math.round(height);
      var canvas2 = _this.source;
      canvas2.width = width;
      canvas2.height = height;
      canvas2._pixiId = "canvas_" + uid();
      canvas2.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
      _this._resolve();
      _this._resolve = null;
    };
  };
  SVGResource2.getSize = function(svgString) {
    var sizeMatch = SVGResource2.SVG_SIZE.exec(svgString);
    var size = {};
    if (sizeMatch) {
      size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
      size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
    }
    return size;
  };
  SVGResource2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this._resolve = null;
    this._crossorigin = null;
  };
  SVGResource2.test = function(source, extension) {
    return extension === "svg" || typeof source === "string" && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(source) || typeof source === "string" && SVGResource2.SVG_XML.test(source);
  };
  SVGResource2.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
  SVGResource2.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
  return SVGResource2;
}(BaseImageResource);
var VideoResource = function(_super) {
  __extends$h(VideoResource2, _super);
  function VideoResource2(source, options) {
    var _this = this;
    options = options || {};
    if (!(source instanceof HTMLVideoElement)) {
      var videoElement = document.createElement("video");
      videoElement.setAttribute("preload", "auto");
      videoElement.setAttribute("webkit-playsinline", "");
      videoElement.setAttribute("playsinline", "");
      if (typeof source === "string") {
        source = [source];
      }
      var firstSrc = source[0].src || source[0];
      BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
      for (var i = 0; i < source.length; ++i) {
        var sourceElement = document.createElement("source");
        var _a2 = source[i], src = _a2.src, mime = _a2.mime;
        src = src || source[i];
        var baseSrc = src.split("?").shift().toLowerCase();
        var ext = baseSrc.substr(baseSrc.lastIndexOf(".") + 1);
        mime = mime || VideoResource2.MIME_TYPES[ext] || "video/" + ext;
        sourceElement.src = src;
        sourceElement.type = mime;
        videoElement.appendChild(sourceElement);
      }
      source = videoElement;
    }
    _this = _super.call(this, source) || this;
    _this.noSubImage = true;
    _this._autoUpdate = true;
    _this._isConnectedToTicker = false;
    _this._updateFPS = options.updateFPS || 0;
    _this._msToNextUpdate = 0;
    _this.autoPlay = options.autoPlay !== false;
    _this._load = null;
    _this._resolve = null;
    _this._onCanPlay = _this._onCanPlay.bind(_this);
    _this._onError = _this._onError.bind(_this);
    if (options.autoLoad !== false) {
      _this.load();
    }
    return _this;
  }
  VideoResource2.prototype.update = function(_deltaTime) {
    if (!this.destroyed) {
      var elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;
      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
      if (!this._updateFPS || this._msToNextUpdate <= 0) {
        _super.prototype.update.call(this);
        this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
      }
    }
  };
  VideoResource2.prototype.load = function() {
    var _this = this;
    if (this._load) {
      return this._load;
    }
    var source = this.source;
    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
      source.complete = true;
    }
    source.addEventListener("play", this._onPlayStart.bind(this));
    source.addEventListener("pause", this._onPlayStop.bind(this));
    if (!this._isSourceReady()) {
      source.addEventListener("canplay", this._onCanPlay);
      source.addEventListener("canplaythrough", this._onCanPlay);
      source.addEventListener("error", this._onError, true);
    } else {
      this._onCanPlay();
    }
    this._load = new Promise(function(resolve2) {
      if (_this.valid) {
        resolve2(_this);
      } else {
        _this._resolve = resolve2;
        source.load();
      }
    });
    return this._load;
  };
  VideoResource2.prototype._onError = function(event) {
    this.source.removeEventListener("error", this._onError, true);
    this.onError.emit(event);
  };
  VideoResource2.prototype._isSourcePlaying = function() {
    var source = this.source;
    return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;
  };
  VideoResource2.prototype._isSourceReady = function() {
    var source = this.source;
    return source.readyState === 3 || source.readyState === 4;
  };
  VideoResource2.prototype._onPlayStart = function() {
    if (!this.valid) {
      this._onCanPlay();
    }
    if (this.autoUpdate && !this._isConnectedToTicker) {
      Ticker.shared.add(this.update, this);
      this._isConnectedToTicker = true;
    }
  };
  VideoResource2.prototype._onPlayStop = function() {
    if (this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  };
  VideoResource2.prototype._onCanPlay = function() {
    var source = this.source;
    source.removeEventListener("canplay", this._onCanPlay);
    source.removeEventListener("canplaythrough", this._onCanPlay);
    var valid = this.valid;
    this.resize(source.videoWidth, source.videoHeight);
    if (!valid && this._resolve) {
      this._resolve(this);
      this._resolve = null;
    }
    if (this._isSourcePlaying()) {
      this._onPlayStart();
    } else if (this.autoPlay) {
      source.play();
    }
  };
  VideoResource2.prototype.dispose = function() {
    if (this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
    var source = this.source;
    if (source) {
      source.removeEventListener("error", this._onError, true);
      source.pause();
      source.src = "";
      source.load();
    }
    _super.prototype.dispose.call(this);
  };
  Object.defineProperty(VideoResource2.prototype, "autoUpdate", {
    get: function() {
      return this._autoUpdate;
    },
    set: function(value) {
      if (value !== this._autoUpdate) {
        this._autoUpdate = value;
        if (!this._autoUpdate && this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
          Ticker.shared.add(this.update, this);
          this._isConnectedToTicker = true;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VideoResource2.prototype, "updateFPS", {
    get: function() {
      return this._updateFPS;
    },
    set: function(value) {
      if (value !== this._updateFPS) {
        this._updateFPS = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  VideoResource2.test = function(source, extension) {
    return self.HTMLVideoElement && source instanceof HTMLVideoElement || VideoResource2.TYPES.indexOf(extension) > -1;
  };
  VideoResource2.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
  VideoResource2.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
  };
  return VideoResource2;
}(BaseImageResource);
var ImageBitmapResource = function(_super) {
  __extends$h(ImageBitmapResource2, _super);
  function ImageBitmapResource2(source) {
    return _super.call(this, source) || this;
  }
  ImageBitmapResource2.test = function(source) {
    return !!self.createImageBitmap && source instanceof ImageBitmap;
  };
  return ImageBitmapResource2;
}(BaseImageResource);
INSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
var _resources = {
  __proto__: null,
  Resource,
  BaseImageResource,
  INSTALLED,
  autoDetectResource,
  AbstractMultiResource,
  ArrayResource,
  BufferResource,
  CanvasResource,
  CubeResource,
  ImageResource,
  SVGResource,
  VideoResource,
  ImageBitmapResource
};
var DepthResource = function(_super) {
  __extends$h(DepthResource2, _super);
  function DepthResource2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DepthResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
    var gl = renderer.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES$3.UNPACK);
    var width = baseTexture.realWidth;
    var height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  };
  return DepthResource2;
}(BufferResource);
var Framebuffer = function() {
  function Framebuffer2(width, height) {
    this.width = Math.round(width || 100);
    this.height = Math.round(height || 100);
    this.stencil = false;
    this.depth = false;
    this.dirtyId = 0;
    this.dirtyFormat = 0;
    this.dirtySize = 0;
    this.depthTexture = null;
    this.colorTextures = [];
    this.glFramebuffers = {};
    this.disposeRunner = new Runner("disposeFramebuffer");
    this.multisample = MSAA_QUALITY$3.NONE;
  }
  Object.defineProperty(Framebuffer2.prototype, "colorTexture", {
    get: function() {
      return this.colorTextures[0];
    },
    enumerable: false,
    configurable: true
  });
  Framebuffer2.prototype.addColorTexture = function(index2, texture) {
    if (index2 === void 0) {
      index2 = 0;
    }
    this.colorTextures[index2] = texture || new BaseTexture(null, {
      scaleMode: SCALE_MODES$3.NEAREST,
      resolution: 1,
      mipmap: MIPMAP_MODES$3.OFF,
      width: this.width,
      height: this.height
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  };
  Framebuffer2.prototype.addDepthTexture = function(texture) {
    this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
      scaleMode: SCALE_MODES$3.NEAREST,
      resolution: 1,
      width: this.width,
      height: this.height,
      mipmap: MIPMAP_MODES$3.OFF,
      format: FORMATS$3.DEPTH_COMPONENT,
      type: TYPES$3.UNSIGNED_SHORT
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  };
  Framebuffer2.prototype.enableDepth = function() {
    this.depth = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  };
  Framebuffer2.prototype.enableStencil = function() {
    this.stencil = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  };
  Framebuffer2.prototype.resize = function(width, height) {
    width = Math.round(width);
    height = Math.round(height);
    if (width === this.width && height === this.height) {
      return;
    }
    this.width = width;
    this.height = height;
    this.dirtyId++;
    this.dirtySize++;
    for (var i = 0; i < this.colorTextures.length; i++) {
      var texture = this.colorTextures[i];
      var resolution = texture.resolution;
      texture.setSize(width / resolution, height / resolution);
    }
    if (this.depthTexture) {
      var resolution = this.depthTexture.resolution;
      this.depthTexture.setSize(width / resolution, height / resolution);
    }
  };
  Framebuffer2.prototype.dispose = function() {
    this.disposeRunner.emit(this, false);
  };
  Framebuffer2.prototype.destroyDepthTexture = function() {
    if (this.depthTexture) {
      this.depthTexture.destroy();
      this.depthTexture = null;
      ++this.dirtyId;
      ++this.dirtyFormat;
    }
  };
  return Framebuffer2;
}();
var BaseRenderTexture = function(_super) {
  __extends$h(BaseRenderTexture2, _super);
  function BaseRenderTexture2(options) {
    var _this = this;
    if (typeof options === "number") {
      var width = arguments[0];
      var height = arguments[1];
      var scaleMode = arguments[2];
      var resolution = arguments[3];
      options = { width, height, scaleMode, resolution };
    }
    options.width = options.width || 100;
    options.height = options.height || 100;
    options.multisample = options.multisample !== void 0 ? options.multisample : MSAA_QUALITY$3.NONE;
    _this = _super.call(this, null, options) || this;
    _this.mipmap = MIPMAP_MODES$3.OFF;
    _this.valid = true;
    _this.clearColor = [0, 0, 0, 0];
    _this.framebuffer = new Framebuffer(_this.realWidth, _this.realHeight).addColorTexture(0, _this);
    _this.framebuffer.multisample = options.multisample;
    _this.maskStack = [];
    _this.filterStack = [{}];
    return _this;
  }
  BaseRenderTexture2.prototype.resize = function(desiredWidth, desiredHeight) {
    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);
    this.setRealSize(this.framebuffer.width, this.framebuffer.height);
  };
  BaseRenderTexture2.prototype.dispose = function() {
    this.framebuffer.dispose();
    _super.prototype.dispose.call(this);
  };
  BaseRenderTexture2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.framebuffer.destroyDepthTexture();
    this.framebuffer = null;
  };
  return BaseRenderTexture2;
}(BaseTexture);
var TextureUvs = function() {
  function TextureUvs2() {
    this.x0 = 0;
    this.y0 = 0;
    this.x1 = 1;
    this.y1 = 0;
    this.x2 = 1;
    this.y2 = 1;
    this.x3 = 0;
    this.y3 = 1;
    this.uvsFloat32 = new Float32Array(8);
  }
  TextureUvs2.prototype.set = function(frame, baseFrame, rotate) {
    var tw = baseFrame.width;
    var th = baseFrame.height;
    if (rotate) {
      var w2 = frame.width / 2 / tw;
      var h2 = frame.height / 2 / th;
      var cX = frame.x / tw + w2;
      var cY = frame.y / th + h2;
      rotate = groupD8.add(rotate, groupD8.NW);
      this.x0 = cX + w2 * groupD8.uX(rotate);
      this.y0 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      this.x1 = cX + w2 * groupD8.uX(rotate);
      this.y1 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      this.x2 = cX + w2 * groupD8.uX(rotate);
      this.y2 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      this.x3 = cX + w2 * groupD8.uX(rotate);
      this.y3 = cY + h2 * groupD8.uY(rotate);
    } else {
      this.x0 = frame.x / tw;
      this.y0 = frame.y / th;
      this.x1 = (frame.x + frame.width) / tw;
      this.y1 = frame.y / th;
      this.x2 = (frame.x + frame.width) / tw;
      this.y2 = (frame.y + frame.height) / th;
      this.x3 = frame.x / tw;
      this.y3 = (frame.y + frame.height) / th;
    }
    this.uvsFloat32[0] = this.x0;
    this.uvsFloat32[1] = this.y0;
    this.uvsFloat32[2] = this.x1;
    this.uvsFloat32[3] = this.y1;
    this.uvsFloat32[4] = this.x2;
    this.uvsFloat32[5] = this.y2;
    this.uvsFloat32[6] = this.x3;
    this.uvsFloat32[7] = this.y3;
  };
  TextureUvs2.prototype.toString = function() {
    return "[@pixi/core:TextureUvs " + ("x0=" + this.x0 + " y0=" + this.y0 + " ") + ("x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " ") + ("y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3) + "]";
  };
  return TextureUvs2;
}();
var DEFAULT_UVS = new TextureUvs();
var Texture = function(_super) {
  __extends$h(Texture2, _super);
  function Texture2(baseTexture, frame, orig, trim, rotate, anchor) {
    var _this = _super.call(this) || this;
    _this.noFrame = false;
    if (!frame) {
      _this.noFrame = true;
      frame = new Rectangle(0, 0, 1, 1);
    }
    if (baseTexture instanceof Texture2) {
      baseTexture = baseTexture.baseTexture;
    }
    _this.baseTexture = baseTexture;
    _this._frame = frame;
    _this.trim = trim;
    _this.valid = false;
    _this._uvs = DEFAULT_UVS;
    _this.uvMatrix = null;
    _this.orig = orig || frame;
    _this._rotate = Number(rotate || 0);
    if (rotate === true) {
      _this._rotate = 2;
    } else if (_this._rotate % 2 !== 0) {
      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
    }
    _this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);
    _this._updateID = 0;
    _this.textureCacheIds = [];
    if (!baseTexture.valid) {
      baseTexture.once("loaded", _this.onBaseTextureUpdated, _this);
    } else if (_this.noFrame) {
      if (baseTexture.valid) {
        _this.onBaseTextureUpdated(baseTexture);
      }
    } else {
      _this.frame = frame;
    }
    if (_this.noFrame) {
      baseTexture.on("update", _this.onBaseTextureUpdated, _this);
    }
    return _this;
  }
  Texture2.prototype.update = function() {
    if (this.baseTexture.resource) {
      this.baseTexture.resource.update();
    }
  };
  Texture2.prototype.onBaseTextureUpdated = function(baseTexture) {
    if (this.noFrame) {
      if (!this.baseTexture.valid) {
        return;
      }
      this._frame.width = baseTexture.width;
      this._frame.height = baseTexture.height;
      this.valid = true;
      this.updateUvs();
    } else {
      this.frame = this._frame;
    }
    this.emit("update", this);
  };
  Texture2.prototype.destroy = function(destroyBase) {
    if (this.baseTexture) {
      if (destroyBase) {
        var resource = this.baseTexture.resource;
        if (resource && resource.url && TextureCache[resource.url]) {
          Texture2.removeFromCache(resource.url);
        }
        this.baseTexture.destroy();
      }
      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
      this.baseTexture.off("update", this.onBaseTextureUpdated, this);
      this.baseTexture = null;
    }
    this._frame = null;
    this._uvs = null;
    this.trim = null;
    this.orig = null;
    this.valid = false;
    Texture2.removeFromCache(this);
    this.textureCacheIds = null;
  };
  Texture2.prototype.clone = function() {
    var clonedFrame = this._frame.clone();
    var clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
    var clonedTexture = new Texture2(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
    if (this.noFrame) {
      clonedTexture._frame = clonedFrame;
    }
    return clonedTexture;
  };
  Texture2.prototype.updateUvs = function() {
    if (this._uvs === DEFAULT_UVS) {
      this._uvs = new TextureUvs();
    }
    this._uvs.set(this._frame, this.baseTexture, this.rotate);
    this._updateID++;
  };
  Texture2.from = function(source, options, strict) {
    if (options === void 0) {
      options = {};
    }
    if (strict === void 0) {
      strict = settings.STRICT_TEXTURE_CACHE;
    }
    var isFrame = typeof source === "string";
    var cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else if (source instanceof BaseTexture) {
      if (!source.cacheId) {
        var prefix = options && options.pixiIdPrefix || "pixiid";
        source.cacheId = prefix + "-" + uid();
        BaseTexture.addToCache(source, source.cacheId);
      }
      cacheId = source.cacheId;
    } else {
      if (!source._pixiId) {
        var prefix = options && options.pixiIdPrefix || "pixiid";
        source._pixiId = prefix + "_" + uid();
      }
      cacheId = source._pixiId;
    }
    var texture = TextureCache[cacheId];
    if (isFrame && strict && !texture) {
      throw new Error('The cacheId "' + cacheId + '" does not exist in TextureCache.');
    }
    if (!texture && !(source instanceof BaseTexture)) {
      if (!options.resolution) {
        options.resolution = getResolutionOfUrl(source);
      }
      texture = new Texture2(new BaseTexture(source, options));
      texture.baseTexture.cacheId = cacheId;
      BaseTexture.addToCache(texture.baseTexture, cacheId);
      Texture2.addToCache(texture, cacheId);
    } else if (!texture && source instanceof BaseTexture) {
      texture = new Texture2(source);
      Texture2.addToCache(texture, cacheId);
    }
    return texture;
  };
  Texture2.fromURL = function(url2, options) {
    var resourceOptions = Object.assign({ autoLoad: false }, options === null || options === void 0 ? void 0 : options.resourceOptions);
    var texture = Texture2.from(url2, Object.assign({ resourceOptions }, options), false);
    var resource = texture.baseTexture.resource;
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return resource.load().then(function() {
      return Promise.resolve(texture);
    });
  };
  Texture2.fromBuffer = function(buffer2, width, height, options) {
    return new Texture2(BaseTexture.fromBuffer(buffer2, width, height, options));
  };
  Texture2.fromLoader = function(source, imageUrl, name, options) {
    var baseTexture = new BaseTexture(source, Object.assign({
      scaleMode: settings.SCALE_MODE,
      resolution: getResolutionOfUrl(imageUrl)
    }, options));
    var resource = baseTexture.resource;
    if (resource instanceof ImageResource) {
      resource.url = imageUrl;
    }
    var texture = new Texture2(baseTexture);
    if (!name) {
      name = imageUrl;
    }
    BaseTexture.addToCache(texture.baseTexture, name);
    Texture2.addToCache(texture, name);
    if (name !== imageUrl) {
      BaseTexture.addToCache(texture.baseTexture, imageUrl);
      Texture2.addToCache(texture, imageUrl);
    }
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return new Promise(function(resolve2) {
      texture.baseTexture.once("loaded", function() {
        return resolve2(texture);
      });
    });
  };
  Texture2.addToCache = function(texture, id) {
    if (id) {
      if (texture.textureCacheIds.indexOf(id) === -1) {
        texture.textureCacheIds.push(id);
      }
      if (TextureCache[id]) {
        console.warn("Texture added to the cache with an id [" + id + "] that already had an entry");
      }
      TextureCache[id] = texture;
    }
  };
  Texture2.removeFromCache = function(texture) {
    if (typeof texture === "string") {
      var textureFromCache = TextureCache[texture];
      if (textureFromCache) {
        var index2 = textureFromCache.textureCacheIds.indexOf(texture);
        if (index2 > -1) {
          textureFromCache.textureCacheIds.splice(index2, 1);
        }
        delete TextureCache[texture];
        return textureFromCache;
      }
    } else if (texture && texture.textureCacheIds) {
      for (var i = 0; i < texture.textureCacheIds.length; ++i) {
        if (TextureCache[texture.textureCacheIds[i]] === texture) {
          delete TextureCache[texture.textureCacheIds[i]];
        }
      }
      texture.textureCacheIds.length = 0;
      return texture;
    }
    return null;
  };
  Object.defineProperty(Texture2.prototype, "resolution", {
    get: function() {
      return this.baseTexture.resolution;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "frame", {
    get: function() {
      return this._frame;
    },
    set: function(frame) {
      this._frame = frame;
      this.noFrame = false;
      var x = frame.x, y = frame.y, width = frame.width, height = frame.height;
      var xNotFit = x + width > this.baseTexture.width;
      var yNotFit = y + height > this.baseTexture.height;
      if (xNotFit || yNotFit) {
        var relationship = xNotFit && yNotFit ? "and" : "or";
        var errorX = "X: " + x + " + " + width + " = " + (x + width) + " > " + this.baseTexture.width;
        var errorY = "Y: " + y + " + " + height + " = " + (y + height) + " > " + this.baseTexture.height;
        throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (errorX + " " + relationship + " " + errorY));
      }
      this.valid = width && height && this.baseTexture.valid;
      if (!this.trim && !this.rotate) {
        this.orig = frame;
      }
      if (this.valid) {
        this.updateUvs();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "rotate", {
    get: function() {
      return this._rotate;
    },
    set: function(rotate) {
      this._rotate = rotate;
      if (this.valid) {
        this.updateUvs();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "width", {
    get: function() {
      return this.orig.width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "height", {
    get: function() {
      return this.orig.height;
    },
    enumerable: false,
    configurable: true
  });
  Texture2.prototype.castToBaseTexture = function() {
    return this.baseTexture;
  };
  return Texture2;
}(EventEmitter);
function createWhiteTexture() {
  var canvas2 = document.createElement("canvas");
  canvas2.width = 16;
  canvas2.height = 16;
  var context2 = canvas2.getContext("2d");
  context2.fillStyle = "white";
  context2.fillRect(0, 0, 16, 16);
  return new Texture(new BaseTexture(new CanvasResource(canvas2)));
}
function removeAllHandlers(tex) {
  tex.destroy = function _emptyDestroy() {
  };
  tex.on = function _emptyOn() {
  };
  tex.once = function _emptyOnce() {
  };
  tex.emit = function _emptyEmit() {
  };
}
Texture.EMPTY = new Texture(new BaseTexture());
removeAllHandlers(Texture.EMPTY);
removeAllHandlers(Texture.EMPTY.baseTexture);
Texture.WHITE = createWhiteTexture();
removeAllHandlers(Texture.WHITE);
removeAllHandlers(Texture.WHITE.baseTexture);
var RenderTexture = function(_super) {
  __extends$h(RenderTexture2, _super);
  function RenderTexture2(baseRenderTexture, frame) {
    var _this = _super.call(this, baseRenderTexture, frame) || this;
    _this.valid = true;
    _this.filterFrame = null;
    _this.filterPoolKey = null;
    _this.updateUvs();
    return _this;
  }
  Object.defineProperty(RenderTexture2.prototype, "framebuffer", {
    get: function() {
      return this.baseTexture.framebuffer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTexture2.prototype, "multisample", {
    get: function() {
      return this.framebuffer.multisample;
    },
    set: function(value) {
      this.framebuffer.multisample = value;
    },
    enumerable: false,
    configurable: true
  });
  RenderTexture2.prototype.resize = function(desiredWidth, desiredHeight, resizeBaseTexture) {
    if (resizeBaseTexture === void 0) {
      resizeBaseTexture = true;
    }
    var resolution = this.baseTexture.resolution;
    var width = Math.round(desiredWidth * resolution) / resolution;
    var height = Math.round(desiredHeight * resolution) / resolution;
    this.valid = width > 0 && height > 0;
    this._frame.width = this.orig.width = width;
    this._frame.height = this.orig.height = height;
    if (resizeBaseTexture) {
      this.baseTexture.resize(width, height);
    }
    this.updateUvs();
  };
  RenderTexture2.prototype.setResolution = function(resolution) {
    var baseTexture = this.baseTexture;
    if (baseTexture.resolution === resolution) {
      return;
    }
    baseTexture.setResolution(resolution);
    this.resize(baseTexture.width, baseTexture.height, false);
  };
  RenderTexture2.create = function(options) {
    var arguments$1 = arguments;
    var rest = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      rest[_i - 1] = arguments$1[_i];
    }
    if (typeof options === "number") {
      deprecation("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated.");
      options = {
        width: options,
        height: rest[0],
        scaleMode: rest[1],
        resolution: rest[2]
      };
    }
    return new RenderTexture2(new BaseRenderTexture(options));
  };
  return RenderTexture2;
}(Texture);
var RenderTexturePool = function() {
  function RenderTexturePool2(textureOptions) {
    this.texturePool = {};
    this.textureOptions = textureOptions || {};
    this.enableFullScreen = false;
    this._pixelsWidth = 0;
    this._pixelsHeight = 0;
  }
  RenderTexturePool2.prototype.createTexture = function(realWidth, realHeight, multisample) {
    if (multisample === void 0) {
      multisample = MSAA_QUALITY$3.NONE;
    }
    var baseRenderTexture = new BaseRenderTexture(Object.assign({
      width: realWidth,
      height: realHeight,
      resolution: 1,
      multisample
    }, this.textureOptions));
    return new RenderTexture(baseRenderTexture);
  };
  RenderTexturePool2.prototype.getOptimalTexture = function(minWidth, minHeight, resolution, multisample) {
    if (resolution === void 0) {
      resolution = 1;
    }
    if (multisample === void 0) {
      multisample = MSAA_QUALITY$3.NONE;
    }
    var key;
    minWidth = Math.ceil(minWidth * resolution);
    minHeight = Math.ceil(minHeight * resolution);
    if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
      minWidth = nextPow2(minWidth);
      minHeight = nextPow2(minHeight);
      key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;
      if (multisample > 1) {
        key += multisample * 4294967296;
      }
    } else {
      key = multisample > 1 ? -multisample : -1;
    }
    if (!this.texturePool[key]) {
      this.texturePool[key] = [];
    }
    var renderTexture = this.texturePool[key].pop();
    if (!renderTexture) {
      renderTexture = this.createTexture(minWidth, minHeight, multisample);
    }
    renderTexture.filterPoolKey = key;
    renderTexture.setResolution(resolution);
    return renderTexture;
  };
  RenderTexturePool2.prototype.getFilterTexture = function(input, resolution, multisample) {
    var filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY$3.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  };
  RenderTexturePool2.prototype.returnTexture = function(renderTexture) {
    var key = renderTexture.filterPoolKey;
    renderTexture.filterFrame = null;
    this.texturePool[key].push(renderTexture);
  };
  RenderTexturePool2.prototype.returnFilterTexture = function(renderTexture) {
    this.returnTexture(renderTexture);
  };
  RenderTexturePool2.prototype.clear = function(destroyTextures) {
    destroyTextures = destroyTextures !== false;
    if (destroyTextures) {
      for (var i in this.texturePool) {
        var textures = this.texturePool[i];
        if (textures) {
          for (var j = 0; j < textures.length; j++) {
            textures[j].destroy(true);
          }
        }
      }
    }
    this.texturePool = {};
  };
  RenderTexturePool2.prototype.setScreenSize = function(size) {
    if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {
      return;
    }
    this.enableFullScreen = size.width > 0 && size.height > 0;
    for (var i in this.texturePool) {
      if (!(Number(i) < 0)) {
        continue;
      }
      var textures = this.texturePool[i];
      if (textures) {
        for (var j = 0; j < textures.length; j++) {
          textures[j].destroy(true);
        }
      }
      this.texturePool[i] = [];
    }
    this._pixelsWidth = size.width;
    this._pixelsHeight = size.height;
  };
  RenderTexturePool2.SCREEN_KEY = -1;
  return RenderTexturePool2;
}();
var Attribute = function() {
  function Attribute2(buffer2, size, normalized, type, stride, start, instance) {
    if (size === void 0) {
      size = 0;
    }
    if (normalized === void 0) {
      normalized = false;
    }
    if (type === void 0) {
      type = TYPES$3.FLOAT;
    }
    this.buffer = buffer2;
    this.size = size;
    this.normalized = normalized;
    this.type = type;
    this.stride = stride;
    this.start = start;
    this.instance = instance;
  }
  Attribute2.prototype.destroy = function() {
    this.buffer = null;
  };
  Attribute2.from = function(buffer2, size, normalized, type, stride) {
    return new Attribute2(buffer2, size, normalized, type, stride);
  };
  return Attribute2;
}();
var UID = 0;
var Buffer$1 = function() {
  function Buffer3(data, _static, index2) {
    if (_static === void 0) {
      _static = true;
    }
    if (index2 === void 0) {
      index2 = false;
    }
    this.data = data || new Float32Array(1);
    this._glBuffers = {};
    this._updateID = 0;
    this.index = index2;
    this.static = _static;
    this.id = UID++;
    this.disposeRunner = new Runner("disposeBuffer");
  }
  Buffer3.prototype.update = function(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    this.data = data || this.data;
    this._updateID++;
  };
  Buffer3.prototype.dispose = function() {
    this.disposeRunner.emit(this, false);
  };
  Buffer3.prototype.destroy = function() {
    this.dispose();
    this.data = null;
  };
  Object.defineProperty(Buffer3.prototype, "index", {
    get: function() {
      return this.type === BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER;
    },
    set: function(value) {
      this.type = value ? BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE$3.ARRAY_BUFFER;
    },
    enumerable: false,
    configurable: true
  });
  Buffer3.from = function(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    return new Buffer3(data);
  };
  return Buffer3;
}();
var map = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(arrays, sizes) {
  var outSize = 0;
  var stride = 0;
  var views = {};
  for (var i = 0; i < arrays.length; i++) {
    stride += sizes[i];
    outSize += arrays[i].length;
  }
  var buffer2 = new ArrayBuffer(outSize * 4);
  var out = null;
  var littleOffset = 0;
  for (var i = 0; i < arrays.length; i++) {
    var size = sizes[i];
    var array = arrays[i];
    var type = getBufferType(array);
    if (!views[type]) {
      views[type] = new map[type](buffer2);
    }
    out = views[type];
    for (var j = 0; j < array.length; j++) {
      var indexStart = (j / size | 0) * stride + littleOffset;
      var index2 = j % size;
      out[indexStart + index2] = array[j];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer2);
}
var byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
var UID$1 = 0;
var map$1 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
};
var Geometry = function() {
  function Geometry2(buffers, attributes) {
    if (buffers === void 0) {
      buffers = [];
    }
    if (attributes === void 0) {
      attributes = {};
    }
    this.buffers = buffers;
    this.indexBuffer = null;
    this.attributes = attributes;
    this.glVertexArrayObjects = {};
    this.id = UID$1++;
    this.instanced = false;
    this.instanceCount = 1;
    this.disposeRunner = new Runner("disposeGeometry");
    this.refCount = 0;
  }
  Geometry2.prototype.addAttribute = function(id, buffer2, size, normalized, type, stride, start, instance) {
    if (size === void 0) {
      size = 0;
    }
    if (normalized === void 0) {
      normalized = false;
    }
    if (instance === void 0) {
      instance = false;
    }
    if (!buffer2) {
      throw new Error("You must pass a buffer when creating an attribute");
    }
    if (!(buffer2 instanceof Buffer$1)) {
      if (buffer2 instanceof Array) {
        buffer2 = new Float32Array(buffer2);
      }
      buffer2 = new Buffer$1(buffer2);
    }
    var ids = id.split("|");
    if (ids.length > 1) {
      for (var i = 0; i < ids.length; i++) {
        this.addAttribute(ids[i], buffer2, size, normalized, type);
      }
      return this;
    }
    var bufferIndex = this.buffers.indexOf(buffer2);
    if (bufferIndex === -1) {
      this.buffers.push(buffer2);
      bufferIndex = this.buffers.length - 1;
    }
    this.attributes[id] = new Attribute(bufferIndex, size, normalized, type, stride, start, instance);
    this.instanced = this.instanced || instance;
    return this;
  };
  Geometry2.prototype.getAttribute = function(id) {
    return this.attributes[id];
  };
  Geometry2.prototype.getBuffer = function(id) {
    return this.buffers[this.getAttribute(id).buffer];
  };
  Geometry2.prototype.addIndex = function(buffer2) {
    if (!(buffer2 instanceof Buffer$1)) {
      if (buffer2 instanceof Array) {
        buffer2 = new Uint16Array(buffer2);
      }
      buffer2 = new Buffer$1(buffer2);
    }
    buffer2.type = BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER;
    this.indexBuffer = buffer2;
    if (this.buffers.indexOf(buffer2) === -1) {
      this.buffers.push(buffer2);
    }
    return this;
  };
  Geometry2.prototype.getIndex = function() {
    return this.indexBuffer;
  };
  Geometry2.prototype.interleave = function() {
    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) {
      return this;
    }
    var arrays = [];
    var sizes = [];
    var interleavedBuffer = new Buffer$1();
    var i;
    for (i in this.attributes) {
      var attribute = this.attributes[i];
      var buffer2 = this.buffers[attribute.buffer];
      arrays.push(buffer2.data);
      sizes.push(attribute.size * byteSizeMap[attribute.type] / 4);
      attribute.buffer = 0;
    }
    interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);
    for (i = 0; i < this.buffers.length; i++) {
      if (this.buffers[i] !== this.indexBuffer) {
        this.buffers[i].destroy();
      }
    }
    this.buffers = [interleavedBuffer];
    if (this.indexBuffer) {
      this.buffers.push(this.indexBuffer);
    }
    return this;
  };
  Geometry2.prototype.getSize = function() {
    for (var i in this.attributes) {
      var attribute = this.attributes[i];
      var buffer2 = this.buffers[attribute.buffer];
      return buffer2.data.length / (attribute.stride / 4 || attribute.size);
    }
    return 0;
  };
  Geometry2.prototype.dispose = function() {
    this.disposeRunner.emit(this, false);
  };
  Geometry2.prototype.destroy = function() {
    this.dispose();
    this.buffers = null;
    this.indexBuffer = null;
    this.attributes = null;
  };
  Geometry2.prototype.clone = function() {
    var geometry = new Geometry2();
    for (var i = 0; i < this.buffers.length; i++) {
      geometry.buffers[i] = new Buffer$1(this.buffers[i].data.slice(0));
    }
    for (var i in this.attributes) {
      var attrib = this.attributes[i];
      geometry.attributes[i] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
    }
    if (this.indexBuffer) {
      geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
      geometry.indexBuffer.type = BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER;
    }
    return geometry;
  };
  Geometry2.merge = function(geometries) {
    var geometryOut = new Geometry2();
    var arrays = [];
    var sizes = [];
    var offsets = [];
    var geometry;
    for (var i = 0; i < geometries.length; i++) {
      geometry = geometries[i];
      for (var j = 0; j < geometry.buffers.length; j++) {
        sizes[j] = sizes[j] || 0;
        sizes[j] += geometry.buffers[j].data.length;
        offsets[j] = 0;
      }
    }
    for (var i = 0; i < geometry.buffers.length; i++) {
      arrays[i] = new map$1[getBufferType(geometry.buffers[i].data)](sizes[i]);
      geometryOut.buffers[i] = new Buffer$1(arrays[i]);
    }
    for (var i = 0; i < geometries.length; i++) {
      geometry = geometries[i];
      for (var j = 0; j < geometry.buffers.length; j++) {
        arrays[j].set(geometry.buffers[j].data, offsets[j]);
        offsets[j] += geometry.buffers[j].data.length;
      }
    }
    geometryOut.attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
      geometryOut.indexBuffer.type = BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER;
      var offset = 0;
      var stride = 0;
      var offset2 = 0;
      var bufferIndexToCount = 0;
      for (var i = 0; i < geometry.buffers.length; i++) {
        if (geometry.buffers[i] !== geometry.indexBuffer) {
          bufferIndexToCount = i;
          break;
        }
      }
      for (var i in geometry.attributes) {
        var attribute = geometry.attributes[i];
        if ((attribute.buffer | 0) === bufferIndexToCount) {
          stride += attribute.size * byteSizeMap[attribute.type] / 4;
        }
      }
      for (var i = 0; i < geometries.length; i++) {
        var indexBufferData = geometries[i].indexBuffer.data;
        for (var j = 0; j < indexBufferData.length; j++) {
          geometryOut.indexBuffer.data[j + offset2] += offset;
        }
        offset += geometries[i].buffers[bufferIndexToCount].data.length / stride;
        offset2 += indexBufferData.length;
      }
    }
    return geometryOut;
  };
  return Geometry2;
}();
var Quad = function(_super) {
  __extends$h(Quad2, _super);
  function Quad2() {
    var _this = _super.call(this) || this;
    _this.addAttribute("aVertexPosition", new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ])).addIndex([0, 1, 3, 2]);
    return _this;
  }
  return Quad2;
}(Geometry);
var QuadUv = function(_super) {
  __extends$h(QuadUv2, _super);
  function QuadUv2() {
    var _this = _super.call(this) || this;
    _this.vertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1
    ]);
    _this.uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]);
    _this.vertexBuffer = new Buffer$1(_this.vertices);
    _this.uvBuffer = new Buffer$1(_this.uvs);
    _this.addAttribute("aVertexPosition", _this.vertexBuffer).addAttribute("aTextureCoord", _this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
    return _this;
  }
  QuadUv2.prototype.map = function(targetTextureFrame, destinationFrame) {
    var x = 0;
    var y = 0;
    this.uvs[0] = x;
    this.uvs[1] = y;
    this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;
    this.uvs[3] = y;
    this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;
    this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height;
    this.uvs[6] = x;
    this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height;
    x = destinationFrame.x;
    y = destinationFrame.y;
    this.vertices[0] = x;
    this.vertices[1] = y;
    this.vertices[2] = x + destinationFrame.width;
    this.vertices[3] = y;
    this.vertices[4] = x + destinationFrame.width;
    this.vertices[5] = y + destinationFrame.height;
    this.vertices[6] = x;
    this.vertices[7] = y + destinationFrame.height;
    this.invalidate();
    return this;
  };
  QuadUv2.prototype.invalidate = function() {
    this.vertexBuffer._updateID++;
    this.uvBuffer._updateID++;
    return this;
  };
  return QuadUv2;
}(Geometry);
var UID$2 = 0;
var UniformGroup = function() {
  function UniformGroup2(uniforms, isStatic, isUbo) {
    this.group = true;
    this.syncUniforms = {};
    this.dirtyId = 0;
    this.id = UID$2++;
    this.static = !!isStatic;
    this.ubo = !!isUbo;
    if (uniforms instanceof Buffer$1) {
      this.buffer = uniforms;
      this.buffer.type = BUFFER_TYPE$3.UNIFORM_BUFFER;
      this.autoManage = false;
      this.ubo = true;
    } else {
      this.uniforms = uniforms;
      if (this.ubo) {
        this.buffer = new Buffer$1(new Float32Array(1));
        this.buffer.type = BUFFER_TYPE$3.UNIFORM_BUFFER;
        this.autoManage = true;
      }
    }
  }
  UniformGroup2.prototype.update = function() {
    this.dirtyId++;
    if (!this.autoManage && this.buffer) {
      this.buffer.update();
    }
  };
  UniformGroup2.prototype.add = function(name, uniforms, _static) {
    if (!this.ubo) {
      this.uniforms[name] = new UniformGroup2(uniforms, _static);
    } else {
      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
    }
  };
  UniformGroup2.from = function(uniforms, _static, _ubo) {
    return new UniformGroup2(uniforms, _static, _ubo);
  };
  UniformGroup2.uboFrom = function(uniforms, _static) {
    return new UniformGroup2(uniforms, _static !== null && _static !== void 0 ? _static : true, true);
  };
  return UniformGroup2;
}();
var FilterState = function() {
  function FilterState2() {
    this.renderTexture = null;
    this.target = null;
    this.legacy = false;
    this.resolution = 1;
    this.multisample = MSAA_QUALITY$3.NONE;
    this.sourceFrame = new Rectangle();
    this.destinationFrame = new Rectangle();
    this.bindingSourceFrame = new Rectangle();
    this.bindingDestinationFrame = new Rectangle();
    this.filters = [];
    this.transform = null;
  }
  FilterState2.prototype.clear = function() {
    this.target = null;
    this.filters = null;
    this.renderTexture = null;
  };
  return FilterState2;
}();
var tempPoints = [new Point(), new Point(), new Point(), new Point()];
var tempMatrix = new Matrix();
var FilterSystem = function() {
  function FilterSystem2(renderer) {
    this.renderer = renderer;
    this.defaultFilterStack = [{}];
    this.texturePool = new RenderTexturePool();
    this.texturePool.setScreenSize(renderer.view);
    this.statePool = [];
    this.quad = new Quad();
    this.quadUv = new QuadUv();
    this.tempRect = new Rectangle();
    this.activeState = {};
    this.globalUniforms = new UniformGroup({
      outputFrame: new Rectangle(),
      inputSize: new Float32Array(4),
      inputPixel: new Float32Array(4),
      inputClamp: new Float32Array(4),
      resolution: 1,
      filterArea: new Float32Array(4),
      filterClamp: new Float32Array(4)
    }, true);
    this.forceClear = false;
    this.useMaxPadding = false;
  }
  FilterSystem2.prototype.push = function(target, filters) {
    var _a2, _b2;
    var renderer = this.renderer;
    var filterStack = this.defaultFilterStack;
    var state = this.statePool.pop() || new FilterState();
    var renderTextureSystem = this.renderer.renderTexture;
    var resolution = filters[0].resolution;
    var multisample = filters[0].multisample;
    var padding = filters[0].padding;
    var autoFit = filters[0].autoFit;
    var legacy = (_a2 = filters[0].legacy) !== null && _a2 !== void 0 ? _a2 : true;
    for (var i = 1; i < filters.length; i++) {
      var filter = filters[i];
      resolution = Math.min(resolution, filter.resolution);
      multisample = Math.min(multisample, filter.multisample);
      padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;
      autoFit = autoFit && filter.autoFit;
      legacy = legacy || ((_b2 = filter.legacy) !== null && _b2 !== void 0 ? _b2 : true);
    }
    if (filterStack.length === 1) {
      this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;
    }
    filterStack.push(state);
    state.resolution = resolution;
    state.multisample = multisample;
    state.legacy = legacy;
    state.target = target;
    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
    state.sourceFrame.pad(padding);
    if (autoFit) {
      var sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
      if (renderer.projection.transform) {
        this.transformAABB(tempMatrix.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);
      }
      state.sourceFrame.fit(sourceFrameProjected);
    }
    this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);
    state.filters = filters;
    state.destinationFrame.width = state.renderTexture.width;
    state.destinationFrame.height = state.renderTexture.height;
    var destinationFrame = this.tempRect;
    destinationFrame.x = 0;
    destinationFrame.y = 0;
    destinationFrame.width = state.sourceFrame.width;
    destinationFrame.height = state.sourceFrame.height;
    state.renderTexture.filterFrame = state.sourceFrame;
    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
    state.transform = renderer.projection.transform;
    renderer.projection.transform = null;
    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);
    renderer.framebuffer.clear(0, 0, 0, 0);
  };
  FilterSystem2.prototype.pop = function() {
    var filterStack = this.defaultFilterStack;
    var state = filterStack.pop();
    var filters = state.filters;
    this.activeState = state;
    var globalUniforms = this.globalUniforms.uniforms;
    globalUniforms.outputFrame = state.sourceFrame;
    globalUniforms.resolution = state.resolution;
    var inputSize = globalUniforms.inputSize;
    var inputPixel = globalUniforms.inputPixel;
    var inputClamp = globalUniforms.inputClamp;
    inputSize[0] = state.destinationFrame.width;
    inputSize[1] = state.destinationFrame.height;
    inputSize[2] = 1 / inputSize[0];
    inputSize[3] = 1 / inputSize[1];
    inputPixel[0] = Math.round(inputSize[0] * state.resolution);
    inputPixel[1] = Math.round(inputSize[1] * state.resolution);
    inputPixel[2] = 1 / inputPixel[0];
    inputPixel[3] = 1 / inputPixel[1];
    inputClamp[0] = 0.5 * inputPixel[2];
    inputClamp[1] = 0.5 * inputPixel[3];
    inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
    inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
    if (state.legacy) {
      var filterArea = globalUniforms.filterArea;
      filterArea[0] = state.destinationFrame.width;
      filterArea[1] = state.destinationFrame.height;
      filterArea[2] = state.sourceFrame.x;
      filterArea[3] = state.sourceFrame.y;
      globalUniforms.filterClamp = globalUniforms.inputClamp;
    }
    this.globalUniforms.update();
    var lastState = filterStack[filterStack.length - 1];
    this.renderer.framebuffer.blit();
    if (filters.length === 1) {
      filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES$3.BLEND, state);
      this.returnFilterTexture(state.renderTexture);
    } else {
      var flip = state.renderTexture;
      var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
      flop.filterFrame = flip.filterFrame;
      var i = 0;
      for (i = 0; i < filters.length - 1; ++i) {
        if (i === 1 && state.multisample > 1) {
          flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
          flop.filterFrame = flip.filterFrame;
        }
        filters[i].apply(this, flip, flop, CLEAR_MODES$3.CLEAR, state);
        var t = flip;
        flip = flop;
        flop = t;
      }
      filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES$3.BLEND, state);
      if (i > 1 && state.multisample > 1) {
        this.returnFilterTexture(state.renderTexture);
      }
      this.returnFilterTexture(flip);
      this.returnFilterTexture(flop);
    }
    state.clear();
    this.statePool.push(state);
  };
  FilterSystem2.prototype.bindAndClear = function(filterTexture, clearMode) {
    if (clearMode === void 0) {
      clearMode = CLEAR_MODES$3.CLEAR;
    }
    var _a2 = this.renderer, renderTextureSystem = _a2.renderTexture, stateSystem = _a2.state;
    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      this.renderer.projection.transform = this.activeState.transform;
    } else {
      this.renderer.projection.transform = null;
    }
    if (filterTexture && filterTexture.filterFrame) {
      var destinationFrame = this.tempRect;
      destinationFrame.x = 0;
      destinationFrame.y = 0;
      destinationFrame.width = filterTexture.filterFrame.width;
      destinationFrame.height = filterTexture.filterFrame.height;
      renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
    } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      renderTextureSystem.bind(filterTexture);
    } else {
      this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
    }
    var autoClear = stateSystem.stateId & 1 || this.forceClear;
    if (clearMode === CLEAR_MODES$3.CLEAR || clearMode === CLEAR_MODES$3.BLIT && autoClear) {
      this.renderer.framebuffer.clear(0, 0, 0, 0);
    }
  };
  FilterSystem2.prototype.applyFilter = function(filter, input, output, clearMode) {
    var renderer = this.renderer;
    renderer.state.set(filter.state);
    this.bindAndClear(output, clearMode);
    filter.uniforms.uSampler = input;
    filter.uniforms.filterGlobals = this.globalUniforms;
    renderer.shader.bind(filter);
    filter.legacy = !!filter.program.attributeData.aTextureCoord;
    if (filter.legacy) {
      this.quadUv.map(input._frame, input.filterFrame);
      renderer.geometry.bind(this.quadUv);
      renderer.geometry.draw(DRAW_MODES$3.TRIANGLES);
    } else {
      renderer.geometry.bind(this.quad);
      renderer.geometry.draw(DRAW_MODES$3.TRIANGLE_STRIP);
    }
  };
  FilterSystem2.prototype.calculateSpriteMatrix = function(outputMatrix, sprite) {
    var _a2 = this.activeState, sourceFrame = _a2.sourceFrame, destinationFrame = _a2.destinationFrame;
    var orig = sprite._texture.orig;
    var mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
    var worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);
    worldTransform.invert();
    mappedMatrix.prepend(worldTransform);
    mappedMatrix.scale(1 / orig.width, 1 / orig.height);
    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
    return mappedMatrix;
  };
  FilterSystem2.prototype.destroy = function() {
    this.renderer = null;
    this.texturePool.clear(false);
  };
  FilterSystem2.prototype.getOptimalFilterTexture = function(minWidth, minHeight, resolution, multisample) {
    if (resolution === void 0) {
      resolution = 1;
    }
    if (multisample === void 0) {
      multisample = MSAA_QUALITY$3.NONE;
    }
    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
  };
  FilterSystem2.prototype.getFilterTexture = function(input, resolution, multisample) {
    if (typeof input === "number") {
      var swap = input;
      input = resolution;
      resolution = swap;
    }
    input = input || this.activeState.renderTexture;
    var filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY$3.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  };
  FilterSystem2.prototype.returnFilterTexture = function(renderTexture) {
    this.texturePool.returnTexture(renderTexture);
  };
  FilterSystem2.prototype.emptyPool = function() {
    this.texturePool.clear(true);
  };
  FilterSystem2.prototype.resize = function() {
    this.texturePool.setScreenSize(this.renderer.view);
  };
  FilterSystem2.prototype.transformAABB = function(matrix, rect) {
    var lt = tempPoints[0];
    var lb = tempPoints[1];
    var rt = tempPoints[2];
    var rb = tempPoints[3];
    lt.set(rect.left, rect.top);
    lb.set(rect.left, rect.bottom);
    rt.set(rect.right, rect.top);
    rb.set(rect.right, rect.bottom);
    matrix.apply(lt, lt);
    matrix.apply(lb, lb);
    matrix.apply(rt, rt);
    matrix.apply(rb, rb);
    var x0 = Math.min(lt.x, lb.x, rt.x, rb.x);
    var y0 = Math.min(lt.y, lb.y, rt.y, rb.y);
    var x1 = Math.max(lt.x, lb.x, rt.x, rb.x);
    var y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
    rect.x = x0;
    rect.y = y0;
    rect.width = x1 - x0;
    rect.height = y1 - y0;
  };
  FilterSystem2.prototype.roundFrame = function(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {
      return;
    }
    if (transform) {
      var a = transform.a, b = transform.b, c = transform.c, d = transform.d;
      if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4)) {
        return;
      }
    }
    transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.transformAABB(transform, frame);
    frame.ceil(resolution);
    this.transformAABB(transform.invert(), frame);
  };
  return FilterSystem2;
}();
var ObjectRenderer = function() {
  function ObjectRenderer2(renderer) {
    this.renderer = renderer;
  }
  ObjectRenderer2.prototype.flush = function() {
  };
  ObjectRenderer2.prototype.destroy = function() {
    this.renderer = null;
  };
  ObjectRenderer2.prototype.start = function() {
  };
  ObjectRenderer2.prototype.stop = function() {
    this.flush();
  };
  ObjectRenderer2.prototype.render = function(_object) {
  };
  return ObjectRenderer2;
}();
var BatchSystem = function() {
  function BatchSystem2(renderer) {
    this.renderer = renderer;
    this.emptyRenderer = new ObjectRenderer(renderer);
    this.currentRenderer = this.emptyRenderer;
  }
  BatchSystem2.prototype.setObjectRenderer = function(objectRenderer) {
    if (this.currentRenderer === objectRenderer) {
      return;
    }
    this.currentRenderer.stop();
    this.currentRenderer = objectRenderer;
    this.currentRenderer.start();
  };
  BatchSystem2.prototype.flush = function() {
    this.setObjectRenderer(this.emptyRenderer);
  };
  BatchSystem2.prototype.reset = function() {
    this.setObjectRenderer(this.emptyRenderer);
  };
  BatchSystem2.prototype.copyBoundTextures = function(arr, maxTextures) {
    var boundTextures = this.renderer.texture.boundTextures;
    for (var i = maxTextures - 1; i >= 0; --i) {
      arr[i] = boundTextures[i] || null;
      if (arr[i]) {
        arr[i]._batchLocation = i;
      }
    }
  };
  BatchSystem2.prototype.boundArray = function(texArray, boundTextures, batchId, maxTextures) {
    var elements = texArray.elements, ids = texArray.ids, count = texArray.count;
    var j = 0;
    for (var i = 0; i < count; i++) {
      var tex = elements[i];
      var loc = tex._batchLocation;
      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
        ids[i] = loc;
        continue;
      }
      while (j < maxTextures) {
        var bound = boundTextures[j];
        if (bound && bound._batchEnabled === batchId && bound._batchLocation === j) {
          j++;
          continue;
        }
        ids[i] = j;
        tex._batchLocation = j;
        boundTextures[j] = tex;
        break;
      }
    }
  };
  BatchSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return BatchSystem2;
}();
var CONTEXT_UID_COUNTER = 0;
var ContextSystem = function() {
  function ContextSystem2(renderer) {
    this.renderer = renderer;
    this.webGLVersion = 1;
    this.extensions = {};
    this.supports = {
      uint32Indices: false
    };
    this.handleContextLost = this.handleContextLost.bind(this);
    this.handleContextRestored = this.handleContextRestored.bind(this);
    renderer.view.addEventListener("webglcontextlost", this.handleContextLost, false);
    renderer.view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
  }
  Object.defineProperty(ContextSystem2.prototype, "isLost", {
    get: function() {
      return !this.gl || this.gl.isContextLost();
    },
    enumerable: false,
    configurable: true
  });
  ContextSystem2.prototype.contextChange = function(gl) {
    this.gl = gl;
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    if (gl.isContextLost() && gl.getExtension("WEBGL_lose_context")) {
      gl.getExtension("WEBGL_lose_context").restoreContext();
    }
  };
  ContextSystem2.prototype.initFromContext = function(gl) {
    this.gl = gl;
    this.validateContext(gl);
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    this.renderer.runners.contextChange.emit(gl);
  };
  ContextSystem2.prototype.initFromOptions = function(options) {
    var gl = this.createContext(this.renderer.view, options);
    this.initFromContext(gl);
  };
  ContextSystem2.prototype.createContext = function(canvas2, options) {
    var gl;
    if (settings.PREFER_ENV >= ENV$3.WEBGL2) {
      gl = canvas2.getContext("webgl2", options);
    }
    if (gl) {
      this.webGLVersion = 2;
    } else {
      this.webGLVersion = 1;
      gl = canvas2.getContext("webgl", options) || canvas2.getContext("experimental-webgl", options);
      if (!gl) {
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      }
    }
    this.gl = gl;
    this.getExtensions();
    return this.gl;
  };
  ContextSystem2.prototype.getExtensions = function() {
    var gl = this.gl;
    var common = {
      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: gl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl.getExtension("WEBGL_compressed_texture_astc")
    };
    if (this.webGLVersion === 1) {
      Object.assign(this.extensions, common, {
        drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
        depthTexture: gl.getExtension("WEBGL_depth_texture"),
        loseContext: gl.getExtension("WEBGL_lose_context"),
        vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
        floatTexture: gl.getExtension("OES_texture_float"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        textureHalfFloat: gl.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
      });
    } else if (this.webGLVersion === 2) {
      Object.assign(this.extensions, common, {
        colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
      });
    }
  };
  ContextSystem2.prototype.handleContextLost = function(event) {
    event.preventDefault();
  };
  ContextSystem2.prototype.handleContextRestored = function() {
    this.renderer.runners.contextChange.emit(this.gl);
  };
  ContextSystem2.prototype.destroy = function() {
    var view = this.renderer.view;
    this.renderer = null;
    view.removeEventListener("webglcontextlost", this.handleContextLost);
    view.removeEventListener("webglcontextrestored", this.handleContextRestored);
    this.gl.useProgram(null);
    if (this.extensions.loseContext) {
      this.extensions.loseContext.loseContext();
    }
  };
  ContextSystem2.prototype.postrender = function() {
    if (this.renderer.renderingToScreen) {
      this.gl.flush();
    }
  };
  ContextSystem2.prototype.validateContext = function(gl) {
    var attributes = gl.getContextAttributes();
    var isWebGl2 = "WebGL2RenderingContext" in self && gl instanceof self.WebGL2RenderingContext;
    if (isWebGl2) {
      this.webGLVersion = 2;
    }
    if (!attributes.stencil) {
      console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    }
    var hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
    this.supports.uint32Indices = hasuint32;
    if (!hasuint32) {
      console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }
  };
  return ContextSystem2;
}();
var GLFramebuffer = function() {
  function GLFramebuffer2(framebuffer) {
    this.framebuffer = framebuffer;
    this.stencil = null;
    this.dirtyId = -1;
    this.dirtyFormat = -1;
    this.dirtySize = -1;
    this.multisample = MSAA_QUALITY$3.NONE;
    this.msaaBuffer = null;
    this.blitFramebuffer = null;
    this.mipLevel = 0;
  }
  return GLFramebuffer2;
}();
var tempRectangle = new Rectangle();
var FramebufferSystem = function() {
  function FramebufferSystem2(renderer) {
    this.renderer = renderer;
    this.managedFramebuffers = [];
    this.unknownFramebuffer = new Framebuffer(10, 10);
    this.msaaSamples = null;
  }
  FramebufferSystem2.prototype.contextChange = function() {
    var gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.current = this.unknownFramebuffer;
    this.viewport = new Rectangle();
    this.hasMRT = true;
    this.writeDepthTexture = true;
    this.disposeAll(true);
    if (this.renderer.context.webGLVersion === 1) {
      var nativeDrawBuffersExtension_1 = this.renderer.context.extensions.drawBuffers;
      var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
      if (settings.PREFER_ENV === ENV$3.WEBGL_LEGACY) {
        nativeDrawBuffersExtension_1 = null;
        nativeDepthTextureExtension = null;
      }
      if (nativeDrawBuffersExtension_1) {
        gl.drawBuffers = function(activeTextures) {
          return nativeDrawBuffersExtension_1.drawBuffersWEBGL(activeTextures);
        };
      } else {
        this.hasMRT = false;
        gl.drawBuffers = function() {
        };
      }
      if (!nativeDepthTextureExtension) {
        this.writeDepthTexture = false;
      }
    } else {
      this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
    }
  };
  FramebufferSystem2.prototype.bind = function(framebuffer, frame, mipLevel) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    var gl = this.gl;
    if (framebuffer) {
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
      if (this.current !== framebuffer) {
        this.current = framebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
      }
      if (fbo.mipLevel !== mipLevel) {
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
        fbo.mipLevel = mipLevel;
      }
      if (fbo.dirtyId !== framebuffer.dirtyId) {
        fbo.dirtyId = framebuffer.dirtyId;
        if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
          fbo.dirtyFormat = framebuffer.dirtyFormat;
          fbo.dirtySize = framebuffer.dirtySize;
          this.updateFramebuffer(framebuffer, mipLevel);
        } else if (fbo.dirtySize !== framebuffer.dirtySize) {
          fbo.dirtySize = framebuffer.dirtySize;
          this.resizeFramebuffer(framebuffer);
        }
      }
      for (var i = 0; i < framebuffer.colorTextures.length; i++) {
        var tex = framebuffer.colorTextures[i];
        this.renderer.texture.unbind(tex.parentTextureArray || tex);
      }
      if (framebuffer.depthTexture) {
        this.renderer.texture.unbind(framebuffer.depthTexture);
      }
      if (frame) {
        var mipWidth = frame.width >> mipLevel;
        var mipHeight = frame.height >> mipLevel;
        var scale = mipWidth / frame.width;
        this.setViewport(frame.x * scale, frame.y * scale, mipWidth, mipHeight);
      } else {
        var mipWidth = framebuffer.width >> mipLevel;
        var mipHeight = framebuffer.height >> mipLevel;
        this.setViewport(0, 0, mipWidth, mipHeight);
      }
    } else {
      if (this.current) {
        this.current = null;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      if (frame) {
        this.setViewport(frame.x, frame.y, frame.width, frame.height);
      } else {
        this.setViewport(0, 0, this.renderer.width, this.renderer.height);
      }
    }
  };
  FramebufferSystem2.prototype.setViewport = function(x, y, width, height) {
    var v = this.viewport;
    x = Math.round(x);
    y = Math.round(y);
    width = Math.round(width);
    height = Math.round(height);
    if (v.width !== width || v.height !== height || v.x !== x || v.y !== y) {
      v.x = x;
      v.y = y;
      v.width = width;
      v.height = height;
      this.gl.viewport(x, y, width, height);
    }
  };
  Object.defineProperty(FramebufferSystem2.prototype, "size", {
    get: function() {
      if (this.current) {
        return { x: 0, y: 0, width: this.current.width, height: this.current.height };
      }
      return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
    },
    enumerable: false,
    configurable: true
  });
  FramebufferSystem2.prototype.clear = function(r, g, b, a, mask) {
    if (mask === void 0) {
      mask = BUFFER_BITS$3.COLOR | BUFFER_BITS$3.DEPTH;
    }
    var gl = this.gl;
    gl.clearColor(r, g, b, a);
    gl.clear(mask);
  };
  FramebufferSystem2.prototype.initFramebuffer = function(framebuffer) {
    var gl = this.gl;
    var fbo = new GLFramebuffer(gl.createFramebuffer());
    fbo.multisample = this.detectSamples(framebuffer.multisample);
    framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
    this.managedFramebuffers.push(framebuffer);
    framebuffer.disposeRunner.add(this);
    return fbo;
  };
  FramebufferSystem2.prototype.resizeFramebuffer = function(framebuffer) {
    var gl = this.gl;
    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (fbo.msaaBuffer) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
    }
    if (fbo.stencil) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
    }
    var colorTextures = framebuffer.colorTextures;
    var count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    for (var i = 0; i < count; i++) {
      var texture = colorTextures[i];
      var parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
    }
    if (framebuffer.depthTexture && this.writeDepthTexture) {
      this.renderer.texture.bind(framebuffer.depthTexture, 0);
    }
  };
  FramebufferSystem2.prototype.updateFramebuffer = function(framebuffer, mipLevel) {
    var gl = this.gl;
    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    var colorTextures = framebuffer.colorTextures;
    var count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {
      fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
    } else if (fbo.msaaBuffer) {
      gl.deleteRenderbuffer(fbo.msaaBuffer);
      fbo.msaaBuffer = null;
      if (fbo.blitFramebuffer) {
        fbo.blitFramebuffer.dispose();
        fbo.blitFramebuffer = null;
      }
    }
    var activeTextures = [];
    for (var i = 0; i < count; i++) {
      var texture = colorTextures[i];
      var parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
      if (i === 0 && fbo.msaaBuffer) {
        continue;
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
      activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
    }
    if (activeTextures.length > 1) {
      gl.drawBuffers(activeTextures);
    }
    if (framebuffer.depthTexture) {
      var writeDepthTexture = this.writeDepthTexture;
      if (writeDepthTexture) {
        var depthTexture = framebuffer.depthTexture;
        this.renderer.texture.bind(depthTexture, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
      }
    }
    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
      fbo.stencil = fbo.stencil || gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
    } else if (fbo.stencil) {
      gl.deleteRenderbuffer(fbo.stencil);
      fbo.stencil = null;
    }
  };
  FramebufferSystem2.prototype.canMultisampleFramebuffer = function(framebuffer) {
    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
  };
  FramebufferSystem2.prototype.detectSamples = function(samples) {
    var msaaSamples = this.msaaSamples;
    var res = MSAA_QUALITY$3.NONE;
    if (samples <= 1 || msaaSamples === null) {
      return res;
    }
    for (var i = 0; i < msaaSamples.length; i++) {
      if (msaaSamples[i] <= samples) {
        res = msaaSamples[i];
        break;
      }
    }
    if (res === 1) {
      res = MSAA_QUALITY$3.NONE;
    }
    return res;
  };
  FramebufferSystem2.prototype.blit = function(framebuffer, sourcePixels, destPixels) {
    var _a2 = this, current = _a2.current, renderer = _a2.renderer, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
    if (renderer.context.webGLVersion !== 2) {
      return;
    }
    if (!current) {
      return;
    }
    var fbo = current.glFramebuffers[CONTEXT_UID];
    if (!fbo) {
      return;
    }
    if (!framebuffer) {
      if (!fbo.msaaBuffer) {
        return;
      }
      var colorTexture = current.colorTextures[0];
      if (!colorTexture) {
        return;
      }
      if (!fbo.blitFramebuffer) {
        fbo.blitFramebuffer = new Framebuffer(current.width, current.height);
        fbo.blitFramebuffer.addColorTexture(0, colorTexture);
      }
      framebuffer = fbo.blitFramebuffer;
      if (framebuffer.colorTextures[0] !== colorTexture) {
        framebuffer.colorTextures[0] = colorTexture;
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
      }
      if (framebuffer.width !== current.width || framebuffer.height !== current.height) {
        framebuffer.width = current.width;
        framebuffer.height = current.height;
        framebuffer.dirtyId++;
        framebuffer.dirtySize++;
      }
    }
    if (!sourcePixels) {
      sourcePixels = tempRectangle;
      sourcePixels.width = current.width;
      sourcePixels.height = current.height;
    }
    if (!destPixels) {
      destPixels = sourcePixels;
    }
    var sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
    this.bind(framebuffer);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
    gl.blitFramebuffer(sourcePixels.x, sourcePixels.y, sourcePixels.width, sourcePixels.height, destPixels.x, destPixels.y, destPixels.width, destPixels.height, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
  };
  FramebufferSystem2.prototype.disposeFramebuffer = function(framebuffer, contextLost) {
    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    var gl = this.gl;
    if (!fbo) {
      return;
    }
    delete framebuffer.glFramebuffers[this.CONTEXT_UID];
    var index2 = this.managedFramebuffers.indexOf(framebuffer);
    if (index2 >= 0) {
      this.managedFramebuffers.splice(index2, 1);
    }
    framebuffer.disposeRunner.remove(this);
    if (!contextLost) {
      gl.deleteFramebuffer(fbo.framebuffer);
      if (fbo.msaaBuffer) {
        gl.deleteRenderbuffer(fbo.msaaBuffer);
      }
      if (fbo.stencil) {
        gl.deleteRenderbuffer(fbo.stencil);
      }
    }
    if (fbo.blitFramebuffer) {
      fbo.blitFramebuffer.dispose();
    }
  };
  FramebufferSystem2.prototype.disposeAll = function(contextLost) {
    var list = this.managedFramebuffers;
    this.managedFramebuffers = [];
    for (var i = 0; i < list.length; i++) {
      this.disposeFramebuffer(list[i], contextLost);
    }
  };
  FramebufferSystem2.prototype.forceStencil = function() {
    var framebuffer = this.current;
    if (!framebuffer) {
      return;
    }
    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (!fbo || fbo.stencil) {
      return;
    }
    framebuffer.stencil = true;
    var w = framebuffer.width;
    var h = framebuffer.height;
    var gl = this.gl;
    var stencil = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
    if (fbo.msaaBuffer) {
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w, h);
    } else {
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w, h);
    }
    fbo.stencil = stencil;
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
  };
  FramebufferSystem2.prototype.reset = function() {
    this.current = this.unknownFramebuffer;
    this.viewport = new Rectangle();
  };
  FramebufferSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return FramebufferSystem2;
}();
var byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };
var GeometrySystem = function() {
  function GeometrySystem2(renderer) {
    this.renderer = renderer;
    this._activeGeometry = null;
    this._activeVao = null;
    this.hasVao = true;
    this.hasInstance = true;
    this.canUseUInt32ElementIndex = false;
    this.managedGeometries = {};
  }
  GeometrySystem2.prototype.contextChange = function() {
    this.disposeAll(true);
    var gl = this.gl = this.renderer.gl;
    var context2 = this.renderer.context;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    if (context2.webGLVersion !== 2) {
      var nativeVaoExtension_1 = this.renderer.context.extensions.vertexArrayObject;
      if (settings.PREFER_ENV === ENV$3.WEBGL_LEGACY) {
        nativeVaoExtension_1 = null;
      }
      if (nativeVaoExtension_1) {
        gl.createVertexArray = function() {
          return nativeVaoExtension_1.createVertexArrayOES();
        };
        gl.bindVertexArray = function(vao) {
          return nativeVaoExtension_1.bindVertexArrayOES(vao);
        };
        gl.deleteVertexArray = function(vao) {
          return nativeVaoExtension_1.deleteVertexArrayOES(vao);
        };
      } else {
        this.hasVao = false;
        gl.createVertexArray = function() {
          return null;
        };
        gl.bindVertexArray = function() {
          return null;
        };
        gl.deleteVertexArray = function() {
          return null;
        };
      }
    }
    if (context2.webGLVersion !== 2) {
      var instanceExt_1 = gl.getExtension("ANGLE_instanced_arrays");
      if (instanceExt_1) {
        gl.vertexAttribDivisor = function(a, b) {
          return instanceExt_1.vertexAttribDivisorANGLE(a, b);
        };
        gl.drawElementsInstanced = function(a, b, c, d, e2) {
          return instanceExt_1.drawElementsInstancedANGLE(a, b, c, d, e2);
        };
        gl.drawArraysInstanced = function(a, b, c, d) {
          return instanceExt_1.drawArraysInstancedANGLE(a, b, c, d);
        };
      } else {
        this.hasInstance = false;
      }
    }
    this.canUseUInt32ElementIndex = context2.webGLVersion === 2 || !!context2.extensions.uint32ElementIndex;
  };
  GeometrySystem2.prototype.bind = function(geometry, shader) {
    shader = shader || this.renderer.shader.shader;
    var gl = this.gl;
    var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    var incRefCount = false;
    if (!vaos) {
      this.managedGeometries[geometry.id] = geometry;
      geometry.disposeRunner.add(this);
      geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
      incRefCount = true;
    }
    var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
    this._activeGeometry = geometry;
    if (this._activeVao !== vao) {
      this._activeVao = vao;
      if (this.hasVao) {
        gl.bindVertexArray(vao);
      } else {
        this.activateVao(geometry, shader.program);
      }
    }
    this.updateBuffers();
  };
  GeometrySystem2.prototype.reset = function() {
    this.unbind();
  };
  GeometrySystem2.prototype.updateBuffers = function() {
    var geometry = this._activeGeometry;
    var bufferSystem = this.renderer.buffer;
    for (var i = 0; i < geometry.buffers.length; i++) {
      var buffer2 = geometry.buffers[i];
      bufferSystem.update(buffer2);
    }
  };
  GeometrySystem2.prototype.checkCompatibility = function(geometry, program) {
    var geometryAttributes = geometry.attributes;
    var shaderAttributes = program.attributeData;
    for (var j in shaderAttributes) {
      if (!geometryAttributes[j]) {
        throw new Error('shader and geometry incompatible, geometry missing the "' + j + '" attribute');
      }
    }
  };
  GeometrySystem2.prototype.getSignature = function(geometry, program) {
    var attribs = geometry.attributes;
    var shaderAttributes = program.attributeData;
    var strings = ["g", geometry.id];
    for (var i in attribs) {
      if (shaderAttributes[i]) {
        strings.push(i, shaderAttributes[i].location);
      }
    }
    return strings.join("-");
  };
  GeometrySystem2.prototype.initGeometryVao = function(geometry, shader, incRefCount) {
    if (incRefCount === void 0) {
      incRefCount = true;
    }
    var gl = this.gl;
    var CONTEXT_UID = this.CONTEXT_UID;
    var bufferSystem = this.renderer.buffer;
    var program = shader.program;
    if (!program.glPrograms[CONTEXT_UID]) {
      this.renderer.shader.generateProgram(shader);
    }
    this.checkCompatibility(geometry, program);
    var signature = this.getSignature(geometry, program);
    var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    var vao = vaoObjectHash[signature];
    if (vao) {
      vaoObjectHash[program.id] = vao;
      return vao;
    }
    var buffers = geometry.buffers;
    var attributes = geometry.attributes;
    var tempStride = {};
    var tempStart = {};
    for (var j in buffers) {
      tempStride[j] = 0;
      tempStart[j] = 0;
    }
    for (var j in attributes) {
      if (!attributes[j].size && program.attributeData[j]) {
        attributes[j].size = program.attributeData[j].size;
      } else if (!attributes[j].size) {
        console.warn("PIXI Geometry attribute '" + j + "' size cannot be determined (likely the bound shader does not have the attribute)");
      }
      tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap$1[attributes[j].type];
    }
    for (var j in attributes) {
      var attribute = attributes[j];
      var attribSize = attribute.size;
      if (attribute.stride === void 0) {
        if (tempStride[attribute.buffer] === attribSize * byteSizeMap$1[attribute.type]) {
          attribute.stride = 0;
        } else {
          attribute.stride = tempStride[attribute.buffer];
        }
      }
      if (attribute.start === void 0) {
        attribute.start = tempStart[attribute.buffer];
        tempStart[attribute.buffer] += attribSize * byteSizeMap$1[attribute.type];
      }
    }
    vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    for (var i = 0; i < buffers.length; i++) {
      var buffer2 = buffers[i];
      bufferSystem.bind(buffer2);
      if (incRefCount) {
        buffer2._glBuffers[CONTEXT_UID].refCount++;
      }
    }
    this.activateVao(geometry, program);
    this._activeVao = vao;
    vaoObjectHash[program.id] = vao;
    vaoObjectHash[signature] = vao;
    return vao;
  };
  GeometrySystem2.prototype.disposeGeometry = function(geometry, contextLost) {
    var _a2;
    if (!this.managedGeometries[geometry.id]) {
      return;
    }
    delete this.managedGeometries[geometry.id];
    var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    var gl = this.gl;
    var buffers = geometry.buffers;
    var bufferSystem = (_a2 = this.renderer) === null || _a2 === void 0 ? void 0 : _a2.buffer;
    geometry.disposeRunner.remove(this);
    if (!vaos) {
      return;
    }
    if (bufferSystem) {
      for (var i = 0; i < buffers.length; i++) {
        var buf = buffers[i]._glBuffers[this.CONTEXT_UID];
        if (buf) {
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            bufferSystem.dispose(buffers[i], contextLost);
          }
        }
      }
    }
    if (!contextLost) {
      for (var vaoId in vaos) {
        if (vaoId[0] === "g") {
          var vao = vaos[vaoId];
          if (this._activeVao === vao) {
            this.unbind();
          }
          gl.deleteVertexArray(vao);
        }
      }
    }
    delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
  };
  GeometrySystem2.prototype.disposeAll = function(contextLost) {
    var all = Object.keys(this.managedGeometries);
    for (var i = 0; i < all.length; i++) {
      this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
    }
  };
  GeometrySystem2.prototype.activateVao = function(geometry, program) {
    var gl = this.gl;
    var CONTEXT_UID = this.CONTEXT_UID;
    var bufferSystem = this.renderer.buffer;
    var buffers = geometry.buffers;
    var attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      bufferSystem.bind(geometry.indexBuffer);
    }
    var lastBuffer = null;
    for (var j in attributes) {
      var attribute = attributes[j];
      var buffer2 = buffers[attribute.buffer];
      var glBuffer = buffer2._glBuffers[CONTEXT_UID];
      if (program.attributeData[j]) {
        if (lastBuffer !== glBuffer) {
          bufferSystem.bind(buffer2);
          lastBuffer = glBuffer;
        }
        var location = program.attributeData[j].location;
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
        if (attribute.instance) {
          if (this.hasInstance) {
            gl.vertexAttribDivisor(location, 1);
          } else {
            throw new Error("geometry error, GPU Instancing is not supported on this device");
          }
        }
      }
    }
  };
  GeometrySystem2.prototype.draw = function(type, size, start, instanceCount) {
    var gl = this.gl;
    var geometry = this._activeGeometry;
    if (geometry.indexBuffer) {
      var byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
      var glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
      if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
        if (geometry.instanced) {
          gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
        } else {
          gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
        }
      } else {
        console.warn("unsupported index buffer type: uint32");
      }
    } else if (geometry.instanced) {
      gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);
    } else {
      gl.drawArrays(type, start, size || geometry.getSize());
    }
    return this;
  };
  GeometrySystem2.prototype.unbind = function() {
    this.gl.bindVertexArray(null);
    this._activeVao = null;
    this._activeGeometry = null;
  };
  GeometrySystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return GeometrySystem2;
}();
var MaskData = function() {
  function MaskData2(maskObject) {
    if (maskObject === void 0) {
      maskObject = null;
    }
    this.type = MASK_TYPES$3.NONE;
    this.autoDetect = true;
    this.maskObject = maskObject || null;
    this.pooled = false;
    this.isMaskData = true;
    this.resolution = null;
    this.multisample = settings.FILTER_MULTISAMPLE;
    this.enabled = true;
    this._filters = null;
    this._stencilCounter = 0;
    this._scissorCounter = 0;
    this._scissorRect = null;
    this._scissorRectLocal = null;
    this._target = null;
  }
  Object.defineProperty(MaskData2.prototype, "filter", {
    get: function() {
      return this._filters ? this._filters[0] : null;
    },
    set: function(value) {
      if (value) {
        if (this._filters) {
          this._filters[0] = value;
        } else {
          this._filters = [value];
        }
      } else {
        this._filters = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  MaskData2.prototype.reset = function() {
    if (this.pooled) {
      this.maskObject = null;
      this.type = MASK_TYPES$3.NONE;
      this.autoDetect = true;
    }
    this._target = null;
    this._scissorRectLocal = null;
  };
  MaskData2.prototype.copyCountersOrReset = function(maskAbove) {
    if (maskAbove) {
      this._stencilCounter = maskAbove._stencilCounter;
      this._scissorCounter = maskAbove._scissorCounter;
      this._scissorRect = maskAbove._scissorRect;
    } else {
      this._stencilCounter = 0;
      this._scissorCounter = 0;
      this._scissorRect = null;
    }
  };
  return MaskData2;
}();
function compileShader(gl, type, src) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}
function logPrettyShaderError(gl, shader) {
  var shaderSrc = gl.getShaderSource(shader).split("\n").map(function(line, index2) {
    return index2 + ": " + line;
  });
  var shaderLog = gl.getShaderInfoLog(shader);
  var splitShader = shaderLog.split("\n");
  var dedupe = {};
  var lineNumbers = splitShader.map(function(line) {
    return parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
  }).filter(function(n) {
    if (n && !dedupe[n]) {
      dedupe[n] = true;
      return true;
    }
    return false;
  });
  var logArgs = [""];
  lineNumbers.forEach(function(number) {
    shaderSrc[number - 1] = "%c" + shaderSrc[number - 1] + "%c";
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  var fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn.apply(console, logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}
function booleanArray(size) {
  var array = new Array(size);
  for (var i = 0; i < array.length; i++) {
    array[i] = false;
  }
  return array;
}
function defaultValue(type, size) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "uvec2":
      return new Uint32Array(2 * size);
    case "uvec3":
      return new Uint32Array(3 * size);
    case "uvec4":
      return new Uint32Array(4 * size);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size);
    case "bvec3":
      return booleanArray(3 * size);
    case "bvec4":
      return booleanArray(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var unknownContext = {};
var context = unknownContext;
function getTestContext() {
  if (context === unknownContext || context && context.isContextLost()) {
    var canvas2 = document.createElement("canvas");
    var gl = void 0;
    if (settings.PREFER_ENV >= ENV$3.WEBGL2) {
      gl = canvas2.getContext("webgl2", {});
    }
    if (!gl) {
      gl = canvas2.getContext("webgl", {}) || canvas2.getContext("experimental-webgl", {});
      if (!gl) {
        gl = null;
      } else {
        gl.getExtension("WEBGL_draw_buffers");
      }
    }
    context = gl;
  }
  return context;
}
var maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = PRECISION$3.MEDIUM;
    var gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        var shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? PRECISION$3.HIGH : PRECISION$3.MEDIUM;
      }
    }
  }
  return maxFragmentPrecision;
}
function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
  if (src.substring(0, 9) !== "precision") {
    var precision = requestedPrecision;
    if (requestedPrecision === PRECISION$3.HIGH && maxSupportedPrecision !== PRECISION$3.HIGH) {
      precision = PRECISION$3.MEDIUM;
    }
    return "precision " + precision + " float;\n" + src;
  } else if (maxSupportedPrecision !== PRECISION$3.HIGH && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
var GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(type) {
  return GLSL_TO_SIZE[type];
}
var GL_TABLE = null;
var GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(gl, type) {
  if (!GL_TABLE) {
    var typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (var i = 0; i < typeNames.length; ++i) {
      var tn = typeNames[i];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}
var uniformParsers = [
  {
    test: function(data) {
      return data.type === "float" && data.size === 1;
    },
    code: function(name) {
      return '\n            if(uv["' + name + '"] !== ud["' + name + '"].value)\n            {\n                ud["' + name + '"].value = uv["' + name + '"]\n                gl.uniform1f(ud["' + name + '"].location, uv["' + name + '"])\n            }\n            ';
    }
  },
  {
    test: function(data) {
      return (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray;
    },
    code: function(name) {
      return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + name + '"], t);\n\n            if(ud["' + name + '"].value !== t)\n            {\n                ud["' + name + '"].value = t;\n                gl.uniform1i(ud["' + name + '"].location, t);\n; // eslint-disable-line max-len\n            }';
    }
  },
  {
    test: function(data, uniform) {
      return data.type === "mat3" && data.size === 1 && uniform.a !== void 0;
    },
    code: function(name) {
      return '\n            gl.uniformMatrix3fv(ud["' + name + '"].location, false, uv["' + name + '"].toArray(true));\n            ';
    },
    codeUbo: function(name) {
      return "\n                var " + name + "_matrix = uv." + name + ".toArray(true);\n\n                data[offset] = " + name + "_matrix[0];\n                data[offset+1] = " + name + "_matrix[1];\n                data[offset+2] = " + name + "_matrix[2];\n        \n                data[offset + 4] = " + name + "_matrix[3];\n                data[offset + 5] = " + name + "_matrix[4];\n                data[offset + 6] = " + name + "_matrix[5];\n        \n                data[offset + 8] = " + name + "_matrix[6];\n                data[offset + 9] = " + name + "_matrix[7];\n                data[offset + 10] = " + name + "_matrix[8];\n            ";
    }
  },
  {
    test: function(data, uniform) {
      return data.type === "vec2" && data.size === 1 && uniform.x !== void 0;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + name + '"].location, v.x, v.y);\n                }';
    },
    codeUbo: function(name) {
      return "\n                v = uv." + name + ";\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            ";
    }
  },
  {
    test: function(data) {
      return data.type === "vec2" && data.size === 1;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + name + '"].location, v[0], v[1]);\n                }\n            ';
    }
  },
  {
    test: function(data, uniform) {
      return data.type === "vec4" && data.size === 1 && uniform.width !== void 0;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + name + '"].location, v.x, v.y, v.width, v.height)\n                }';
    },
    codeUbo: function(name) {
      return "\n                    v = uv." + name + ";\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                ";
    }
  },
  {
    test: function(data) {
      return data.type === "vec4" && data.size === 1;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + name + '"].location, v[0], v[1], v[2], v[3])\n                }';
    }
  }
];
var GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }",
  vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }",
  vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
  vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }",
  int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
  ivec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
  ivec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
  ivec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
  uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }",
  uvec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }",
  uvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }",
  uvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }",
  bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }",
  bvec2: "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
  bvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
  bvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: "gl.uniform1i(location, v)",
  samplerCube: "gl.uniform1i(location, v)",
  sampler2DArray: "gl.uniform1i(location, v)"
};
var GLSL_TO_ARRAY_SETTERS = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(group, uniformData) {
  var _a2;
  var funcFragments = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "];
  for (var i in group.uniforms) {
    var data = uniformData[i];
    if (!data) {
      if ((_a2 = group.uniforms[i]) === null || _a2 === void 0 ? void 0 : _a2.group) {
        if (group.uniforms[i].ubo) {
          funcFragments.push("\n                        renderer.shader.syncUniformBufferGroup(uv." + i + ", '" + i + "');\n                    ");
        } else {
          funcFragments.push("\n                        renderer.shader.syncUniformGroup(uv." + i + ", syncData);\n                    ");
        }
      }
      continue;
    }
    var uniform = group.uniforms[i];
    var parsed = false;
    for (var j = 0; j < uniformParsers.length; j++) {
      if (uniformParsers[j].test(data, uniform)) {
        funcFragments.push(uniformParsers[j].code(i, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      var templateType = data.size === 1 ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
      var template = templateType[data.type].replace("location", 'ud["' + i + '"].location');
      funcFragments.push('\n            cu = ud["' + i + '"];\n            cv = cu.value;\n            v = uv["' + i + '"];\n            ' + template + ";");
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}
var fragTemplate$1 = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join("\n");
function generateIfTestSrc(maxIfs) {
  var src = "";
  for (var i = 0; i < maxIfs; ++i) {
    if (i > 0) {
      src += "\nelse ";
    }
    if (i < maxIfs - 1) {
      src += "if(test == " + i + ".0){}";
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  var shader = gl.createShader(gl.FRAGMENT_SHADER);
  while (true) {
    var fragmentSrc = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
    gl.shaderSource(shader, fragmentSrc);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      maxIfs = maxIfs / 2 | 0;
    } else {
      break;
    }
  }
  return maxIfs;
}
var unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    var func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (e2) {
    unsafeEval = false;
  }
  return unsafeEval;
}
var defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
var defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
var UID$3 = 0;
var nameCache = {};
var Program = function() {
  function Program2(vertexSrc, fragmentSrc, name) {
    if (name === void 0) {
      name = "pixi-shader";
    }
    this.id = UID$3++;
    this.vertexSrc = vertexSrc || Program2.defaultVertexSrc;
    this.fragmentSrc = fragmentSrc || Program2.defaultFragmentSrc;
    this.vertexSrc = this.vertexSrc.trim();
    this.fragmentSrc = this.fragmentSrc.trim();
    if (this.vertexSrc.substring(0, 8) !== "#version") {
      name = name.replace(/\s+/g, "-");
      if (nameCache[name]) {
        nameCache[name]++;
        name += "-" + nameCache[name];
      } else {
        nameCache[name] = 1;
      }
      this.vertexSrc = "#define SHADER_NAME " + name + "\n" + this.vertexSrc;
      this.fragmentSrc = "#define SHADER_NAME " + name + "\n" + this.fragmentSrc;
      this.vertexSrc = setPrecision(this.vertexSrc, settings.PRECISION_VERTEX, PRECISION$3.HIGH);
      this.fragmentSrc = setPrecision(this.fragmentSrc, settings.PRECISION_FRAGMENT, getMaxFragmentPrecision());
    }
    this.glPrograms = {};
    this.syncUniforms = null;
  }
  Object.defineProperty(Program2, "defaultVertexSrc", {
    get: function() {
      return defaultVertex;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Program2, "defaultFragmentSrc", {
    get: function() {
      return defaultFragment;
    },
    enumerable: false,
    configurable: true
  });
  Program2.from = function(vertexSrc, fragmentSrc, name) {
    var key = vertexSrc + fragmentSrc;
    var program = ProgramCache[key];
    if (!program) {
      ProgramCache[key] = program = new Program2(vertexSrc, fragmentSrc, name);
    }
    return program;
  };
  return Program2;
}();
var Shader = function() {
  function Shader2(program, uniforms) {
    this.uniformBindCount = 0;
    this.program = program;
    if (uniforms) {
      if (uniforms instanceof UniformGroup) {
        this.uniformGroup = uniforms;
      } else {
        this.uniformGroup = new UniformGroup(uniforms);
      }
    } else {
      this.uniformGroup = new UniformGroup({});
    }
  }
  Shader2.prototype.checkUniformExists = function(name, group) {
    if (group.uniforms[name]) {
      return true;
    }
    for (var i in group.uniforms) {
      var uniform = group.uniforms[i];
      if (uniform.group) {
        if (this.checkUniformExists(name, uniform)) {
          return true;
        }
      }
    }
    return false;
  };
  Shader2.prototype.destroy = function() {
    this.uniformGroup = null;
  };
  Object.defineProperty(Shader2.prototype, "uniforms", {
    get: function() {
      return this.uniformGroup.uniforms;
    },
    enumerable: false,
    configurable: true
  });
  Shader2.from = function(vertexSrc, fragmentSrc, uniforms) {
    var program = Program.from(vertexSrc, fragmentSrc);
    return new Shader2(program, uniforms);
  };
  return Shader2;
}();
var BLEND = 0;
var OFFSET = 1;
var CULLING = 2;
var DEPTH_TEST = 3;
var WINDING = 4;
var DEPTH_MASK = 5;
var State = function() {
  function State2() {
    this.data = 0;
    this.blendMode = BLEND_MODES$3.NORMAL;
    this.polygonOffset = 0;
    this.blend = true;
    this.depthMask = true;
  }
  Object.defineProperty(State2.prototype, "blend", {
    get: function() {
      return !!(this.data & 1 << BLEND);
    },
    set: function(value) {
      if (!!(this.data & 1 << BLEND) !== value) {
        this.data ^= 1 << BLEND;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "offsets", {
    get: function() {
      return !!(this.data & 1 << OFFSET);
    },
    set: function(value) {
      if (!!(this.data & 1 << OFFSET) !== value) {
        this.data ^= 1 << OFFSET;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "culling", {
    get: function() {
      return !!(this.data & 1 << CULLING);
    },
    set: function(value) {
      if (!!(this.data & 1 << CULLING) !== value) {
        this.data ^= 1 << CULLING;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "depthTest", {
    get: function() {
      return !!(this.data & 1 << DEPTH_TEST);
    },
    set: function(value) {
      if (!!(this.data & 1 << DEPTH_TEST) !== value) {
        this.data ^= 1 << DEPTH_TEST;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "depthMask", {
    get: function() {
      return !!(this.data & 1 << DEPTH_MASK);
    },
    set: function(value) {
      if (!!(this.data & 1 << DEPTH_MASK) !== value) {
        this.data ^= 1 << DEPTH_MASK;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "clockwiseFrontFace", {
    get: function() {
      return !!(this.data & 1 << WINDING);
    },
    set: function(value) {
      if (!!(this.data & 1 << WINDING) !== value) {
        this.data ^= 1 << WINDING;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "blendMode", {
    get: function() {
      return this._blendMode;
    },
    set: function(value) {
      this.blend = value !== BLEND_MODES$3.NONE;
      this._blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "polygonOffset", {
    get: function() {
      return this._polygonOffset;
    },
    set: function(value) {
      this.offsets = !!value;
      this._polygonOffset = value;
    },
    enumerable: false,
    configurable: true
  });
  State2.prototype.toString = function() {
    return "[@pixi/core:State " + ("blendMode=" + this.blendMode + " ") + ("clockwiseFrontFace=" + this.clockwiseFrontFace + " ") + ("culling=" + this.culling + " ") + ("depthMask=" + this.depthMask + " ") + ("polygonOffset=" + this.polygonOffset) + "]";
  };
  State2.for2d = function() {
    var state = new State2();
    state.depthTest = false;
    state.blend = true;
    return state;
  };
  return State2;
}();
var defaultVertex$1 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
var defaultFragment$1 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
var Filter = function(_super) {
  __extends$h(Filter2, _super);
  function Filter2(vertexSrc, fragmentSrc, uniforms) {
    var _this = this;
    var program = Program.from(vertexSrc || Filter2.defaultVertexSrc, fragmentSrc || Filter2.defaultFragmentSrc);
    _this = _super.call(this, program, uniforms) || this;
    _this.padding = 0;
    _this.resolution = settings.FILTER_RESOLUTION;
    _this.multisample = settings.FILTER_MULTISAMPLE;
    _this.enabled = true;
    _this.autoFit = true;
    _this.state = new State();
    return _this;
  }
  Filter2.prototype.apply = function(filterManager, input, output, clearMode, _currentState) {
    filterManager.applyFilter(this, input, output, clearMode);
  };
  Object.defineProperty(Filter2.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    set: function(value) {
      this.state.blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Filter2.prototype, "resolution", {
    get: function() {
      return this._resolution;
    },
    set: function(value) {
      this._resolution = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Filter2, "defaultVertexSrc", {
    get: function() {
      return defaultVertex$1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Filter2, "defaultFragmentSrc", {
    get: function() {
      return defaultFragment$1;
    },
    enumerable: false,
    configurable: true
  });
  return Filter2;
}(Shader);
var vertex$4 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";
var fragment$7 = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";
var tempMat$1 = new Matrix();
var TextureMatrix = function() {
  function TextureMatrix2(texture, clampMargin) {
    this._texture = texture;
    this.mapCoord = new Matrix();
    this.uClampFrame = new Float32Array(4);
    this.uClampOffset = new Float32Array(2);
    this._textureID = -1;
    this._updateID = 0;
    this.clampOffset = 0;
    this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
    this.isSimple = false;
  }
  Object.defineProperty(TextureMatrix2.prototype, "texture", {
    get: function() {
      return this._texture;
    },
    set: function(value) {
      this._texture = value;
      this._textureID = -1;
    },
    enumerable: false,
    configurable: true
  });
  TextureMatrix2.prototype.multiplyUvs = function(uvs, out) {
    if (out === void 0) {
      out = uvs;
    }
    var mat = this.mapCoord;
    for (var i = 0; i < uvs.length; i += 2) {
      var x = uvs[i];
      var y = uvs[i + 1];
      out[i] = x * mat.a + y * mat.c + mat.tx;
      out[i + 1] = x * mat.b + y * mat.d + mat.ty;
    }
    return out;
  };
  TextureMatrix2.prototype.update = function(forceUpdate) {
    var tex = this._texture;
    if (!tex || !tex.valid) {
      return false;
    }
    if (!forceUpdate && this._textureID === tex._updateID) {
      return false;
    }
    this._textureID = tex._updateID;
    this._updateID++;
    var uvs = tex._uvs;
    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    var orig = tex.orig;
    var trim = tex.trim;
    if (trim) {
      tempMat$1.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
      this.mapCoord.append(tempMat$1);
    }
    var texBase = tex.baseTexture;
    var frame = this.uClampFrame;
    var margin = this.clampMargin / texBase.resolution;
    var offset = this.clampOffset;
    frame[0] = (tex._frame.x + margin + offset) / texBase.width;
    frame[1] = (tex._frame.y + margin + offset) / texBase.height;
    frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
    frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
    this.uClampOffset[0] = offset / texBase.realWidth;
    this.uClampOffset[1] = offset / texBase.realHeight;
    this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
    return true;
  };
  return TextureMatrix2;
}();
var SpriteMaskFilter = function(_super) {
  __extends$h(SpriteMaskFilter2, _super);
  function SpriteMaskFilter2(vertexSrc, fragmentSrc, uniforms) {
    var _this = this;
    var sprite = null;
    if (typeof vertexSrc !== "string" && fragmentSrc === void 0 && uniforms === void 0) {
      sprite = vertexSrc;
      vertexSrc = void 0;
      fragmentSrc = void 0;
      uniforms = void 0;
    }
    _this = _super.call(this, vertexSrc || vertex$4, fragmentSrc || fragment$7, uniforms) || this;
    _this.maskSprite = sprite;
    _this.maskMatrix = new Matrix();
    return _this;
  }
  Object.defineProperty(SpriteMaskFilter2.prototype, "maskSprite", {
    get: function() {
      return this._maskSprite;
    },
    set: function(value) {
      this._maskSprite = value;
      if (this._maskSprite) {
        this._maskSprite.renderable = false;
      }
    },
    enumerable: false,
    configurable: true
  });
  SpriteMaskFilter2.prototype.apply = function(filterManager, input, output, clearMode) {
    var maskSprite = this._maskSprite;
    var tex = maskSprite._texture;
    if (!tex.valid) {
      return;
    }
    if (!tex.uvMatrix) {
      tex.uvMatrix = new TextureMatrix(tex, 0);
    }
    tex.uvMatrix.update();
    this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
    this.uniforms.mask = tex;
    this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
    this.uniforms.alpha = maskSprite.worldAlpha;
    this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
    filterManager.applyFilter(this, input, output, clearMode);
  };
  return SpriteMaskFilter2;
}(Filter);
var MaskSystem = function() {
  function MaskSystem2(renderer) {
    this.renderer = renderer;
    this.enableScissor = true;
    this.alphaMaskPool = [];
    this.maskDataPool = [];
    this.maskStack = [];
    this.alphaMaskIndex = 0;
  }
  MaskSystem2.prototype.setMaskStack = function(maskStack) {
    this.maskStack = maskStack;
    this.renderer.scissor.setMaskStack(maskStack);
    this.renderer.stencil.setMaskStack(maskStack);
  };
  MaskSystem2.prototype.push = function(target, maskDataOrTarget) {
    var maskData = maskDataOrTarget;
    if (!maskData.isMaskData) {
      var d = this.maskDataPool.pop() || new MaskData();
      d.pooled = true;
      d.maskObject = maskDataOrTarget;
      maskData = d;
    }
    var maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
    maskData.copyCountersOrReset(maskAbove);
    if (maskData.autoDetect) {
      this.detect(maskData);
    }
    maskData._target = target;
    if (maskData.type !== MASK_TYPES$3.SPRITE) {
      this.maskStack.push(maskData);
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case MASK_TYPES$3.SCISSOR:
          this.renderer.scissor.push(maskData);
          break;
        case MASK_TYPES$3.STENCIL:
          this.renderer.stencil.push(maskData);
          break;
        case MASK_TYPES$3.SPRITE:
          maskData.copyCountersOrReset(null);
          this.pushSpriteMask(maskData);
          break;
      }
    }
    if (maskData.type === MASK_TYPES$3.SPRITE) {
      this.maskStack.push(maskData);
    }
  };
  MaskSystem2.prototype.pop = function(target) {
    var maskData = this.maskStack.pop();
    if (!maskData || maskData._target !== target) {
      return;
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case MASK_TYPES$3.SCISSOR:
          this.renderer.scissor.pop();
          break;
        case MASK_TYPES$3.STENCIL:
          this.renderer.stencil.pop(maskData.maskObject);
          break;
        case MASK_TYPES$3.SPRITE:
          this.popSpriteMask(maskData);
          break;
      }
    }
    maskData.reset();
    if (maskData.pooled) {
      this.maskDataPool.push(maskData);
    }
    if (this.maskStack.length !== 0) {
      var maskCurrent = this.maskStack[this.maskStack.length - 1];
      if (maskCurrent.type === MASK_TYPES$3.SPRITE && maskCurrent._filters) {
        maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;
      }
    }
  };
  MaskSystem2.prototype.detect = function(maskData) {
    var maskObject = maskData.maskObject;
    if (maskObject.isSprite) {
      maskData.type = MASK_TYPES$3.SPRITE;
    } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {
      maskData.type = MASK_TYPES$3.SCISSOR;
    } else {
      maskData.type = MASK_TYPES$3.STENCIL;
    }
  };
  MaskSystem2.prototype.pushSpriteMask = function(maskData) {
    var _a2, _b2;
    var maskObject = maskData.maskObject;
    var target = maskData._target;
    var alphaMaskFilter = maskData._filters;
    if (!alphaMaskFilter) {
      alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
      if (!alphaMaskFilter) {
        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];
      }
    }
    var renderer = this.renderer;
    var renderTextureSystem = renderer.renderTexture;
    var resolution;
    var multisample;
    if (renderTextureSystem.current) {
      var renderTexture = renderTextureSystem.current;
      resolution = maskData.resolution || renderTexture.resolution;
      multisample = (_a2 = maskData.multisample) !== null && _a2 !== void 0 ? _a2 : renderTexture.multisample;
    } else {
      resolution = maskData.resolution || renderer.resolution;
      multisample = (_b2 = maskData.multisample) !== null && _b2 !== void 0 ? _b2 : renderer.multisample;
    }
    alphaMaskFilter[0].resolution = resolution;
    alphaMaskFilter[0].multisample = multisample;
    alphaMaskFilter[0].maskSprite = maskObject;
    var stashFilterArea = target.filterArea;
    target.filterArea = maskObject.getBounds(true);
    renderer.filter.push(target, alphaMaskFilter);
    target.filterArea = stashFilterArea;
    if (!maskData._filters) {
      this.alphaMaskIndex++;
    }
  };
  MaskSystem2.prototype.popSpriteMask = function(maskData) {
    this.renderer.filter.pop();
    if (maskData._filters) {
      maskData._filters[0].maskSprite = null;
    } else {
      this.alphaMaskIndex--;
      this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;
    }
  };
  MaskSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return MaskSystem2;
}();
var AbstractMaskSystem = function() {
  function AbstractMaskSystem2(renderer) {
    this.renderer = renderer;
    this.maskStack = [];
    this.glConst = 0;
  }
  AbstractMaskSystem2.prototype.getStackLength = function() {
    return this.maskStack.length;
  };
  AbstractMaskSystem2.prototype.setMaskStack = function(maskStack) {
    var gl = this.renderer.gl;
    var curStackLen = this.getStackLength();
    this.maskStack = maskStack;
    var newStackLen = this.getStackLength();
    if (newStackLen !== curStackLen) {
      if (newStackLen === 0) {
        gl.disable(this.glConst);
      } else {
        gl.enable(this.glConst);
        this._useCurrent();
      }
    }
  };
  AbstractMaskSystem2.prototype._useCurrent = function() {
  };
  AbstractMaskSystem2.prototype.destroy = function() {
    this.renderer = null;
    this.maskStack = null;
  };
  return AbstractMaskSystem2;
}();
var tempMatrix$1 = new Matrix();
var ScissorSystem = function(_super) {
  __extends$h(ScissorSystem2, _super);
  function ScissorSystem2(renderer) {
    var _this = _super.call(this, renderer) || this;
    _this.glConst = WebGLRenderingContext.SCISSOR_TEST;
    return _this;
  }
  ScissorSystem2.prototype.getStackLength = function() {
    var maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._scissorCounter;
    }
    return 0;
  };
  ScissorSystem2.prototype.calcScissorRect = function(maskData) {
    if (maskData._scissorRectLocal) {
      return;
    }
    var prevData = maskData._scissorRect;
    var maskObject = maskData.maskObject;
    var renderer = this.renderer;
    var renderTextureSystem = renderer.renderTexture;
    maskObject.renderable = true;
    var rect = maskObject.getBounds();
    this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
    maskObject.renderable = false;
    if (prevData) {
      rect.fit(prevData);
    }
    maskData._scissorRectLocal = rect;
  };
  ScissorSystem2.isMatrixRotated = function(matrix) {
    if (!matrix) {
      return false;
    }
    var a = matrix.a, b = matrix.b, c = matrix.c, d = matrix.d;
    return (Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4);
  };
  ScissorSystem2.prototype.testScissor = function(maskData) {
    var maskObject = maskData.maskObject;
    if (!maskObject.isFastRect || !maskObject.isFastRect()) {
      return false;
    }
    if (ScissorSystem2.isMatrixRotated(maskObject.worldTransform)) {
      return false;
    }
    if (ScissorSystem2.isMatrixRotated(this.renderer.projection.transform)) {
      return false;
    }
    this.calcScissorRect(maskData);
    var rect = maskData._scissorRectLocal;
    return rect.width > 0 && rect.height > 0;
  };
  ScissorSystem2.prototype.roundFrameToPixels = function(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (ScissorSystem2.isMatrixRotated(transform)) {
      return;
    }
    transform = transform ? tempMatrix$1.copyFrom(transform) : tempMatrix$1.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.renderer.filter.transformAABB(transform, frame);
    frame.fit(bindingDestinationFrame);
    frame.x = Math.round(frame.x * resolution);
    frame.y = Math.round(frame.y * resolution);
    frame.width = Math.round(frame.width * resolution);
    frame.height = Math.round(frame.height * resolution);
  };
  ScissorSystem2.prototype.push = function(maskData) {
    if (!maskData._scissorRectLocal) {
      this.calcScissorRect(maskData);
    }
    var gl = this.renderer.gl;
    if (!maskData._scissorRect) {
      gl.enable(gl.SCISSOR_TEST);
    }
    maskData._scissorCounter++;
    maskData._scissorRect = maskData._scissorRectLocal;
    this._useCurrent();
  };
  ScissorSystem2.prototype.pop = function() {
    var gl = this.renderer.gl;
    if (this.getStackLength() > 0) {
      this._useCurrent();
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }
  };
  ScissorSystem2.prototype._useCurrent = function() {
    var rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
    var y;
    if (this.renderer.renderTexture.current) {
      y = rect.y;
    } else {
      y = this.renderer.height - rect.height - rect.y;
    }
    this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);
  };
  return ScissorSystem2;
}(AbstractMaskSystem);
var StencilSystem = function(_super) {
  __extends$h(StencilSystem2, _super);
  function StencilSystem2(renderer) {
    var _this = _super.call(this, renderer) || this;
    _this.glConst = WebGLRenderingContext.STENCIL_TEST;
    return _this;
  }
  StencilSystem2.prototype.getStackLength = function() {
    var maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._stencilCounter;
    }
    return 0;
  };
  StencilSystem2.prototype.push = function(maskData) {
    var maskObject = maskData.maskObject;
    var gl = this.renderer.gl;
    var prevMaskCount = maskData._stencilCounter;
    if (prevMaskCount === 0) {
      this.renderer.framebuffer.forceStencil();
      gl.clearStencil(0);
      gl.clear(gl.STENCIL_BUFFER_BIT);
      gl.enable(gl.STENCIL_TEST);
    }
    maskData._stencilCounter++;
    gl.colorMask(false, false, false, false);
    gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
    maskObject.renderable = true;
    maskObject.render(this.renderer);
    this.renderer.batch.flush();
    maskObject.renderable = false;
    this._useCurrent();
  };
  StencilSystem2.prototype.pop = function(maskObject) {
    var gl = this.renderer.gl;
    if (this.getStackLength() === 0) {
      gl.disable(gl.STENCIL_TEST);
    } else {
      gl.colorMask(false, false, false, false);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
      maskObject.renderable = true;
      maskObject.render(this.renderer);
      this.renderer.batch.flush();
      maskObject.renderable = false;
      this._useCurrent();
    }
  };
  StencilSystem2.prototype._useCurrent = function() {
    var gl = this.renderer.gl;
    gl.colorMask(true, true, true, true);
    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
  };
  return StencilSystem2;
}(AbstractMaskSystem);
var ProjectionSystem = function() {
  function ProjectionSystem2(renderer) {
    this.renderer = renderer;
    this.destinationFrame = null;
    this.sourceFrame = null;
    this.defaultFrame = null;
    this.projectionMatrix = new Matrix();
    this.transform = null;
  }
  ProjectionSystem2.prototype.update = function(destinationFrame, sourceFrame, resolution, root) {
    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
    this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
    this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);
    if (this.transform) {
      this.projectionMatrix.append(this.transform);
    }
    var renderer = this.renderer;
    renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
    renderer.globalUniforms.update();
    if (renderer.shader.shader) {
      renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
    }
  };
  ProjectionSystem2.prototype.calculateProjection = function(_destinationFrame, sourceFrame, _resolution, root) {
    var pm = this.projectionMatrix;
    var sign2 = !root ? 1 : -1;
    pm.identity();
    pm.a = 1 / sourceFrame.width * 2;
    pm.d = sign2 * (1 / sourceFrame.height * 2);
    pm.tx = -1 - sourceFrame.x * pm.a;
    pm.ty = -sign2 - sourceFrame.y * pm.d;
  };
  ProjectionSystem2.prototype.setTransform = function(_matrix) {
  };
  ProjectionSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return ProjectionSystem2;
}();
var tempRect = new Rectangle();
var tempRect2 = new Rectangle();
var RenderTextureSystem = function() {
  function RenderTextureSystem2(renderer) {
    this.renderer = renderer;
    this.clearColor = renderer._backgroundColorRgba;
    this.defaultMaskStack = [];
    this.current = null;
    this.sourceFrame = new Rectangle();
    this.destinationFrame = new Rectangle();
    this.viewportFrame = new Rectangle();
  }
  RenderTextureSystem2.prototype.bind = function(renderTexture, sourceFrame, destinationFrame) {
    if (renderTexture === void 0) {
      renderTexture = null;
    }
    var renderer = this.renderer;
    this.current = renderTexture;
    var baseTexture;
    var framebuffer;
    var resolution;
    if (renderTexture) {
      baseTexture = renderTexture.baseTexture;
      resolution = baseTexture.resolution;
      if (!sourceFrame) {
        tempRect.width = renderTexture.frame.width;
        tempRect.height = renderTexture.frame.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        tempRect2.x = renderTexture.frame.x;
        tempRect2.y = renderTexture.frame.y;
        tempRect2.width = sourceFrame.width;
        tempRect2.height = sourceFrame.height;
        destinationFrame = tempRect2;
      }
      framebuffer = baseTexture.framebuffer;
    } else {
      resolution = renderer.resolution;
      if (!sourceFrame) {
        tempRect.width = renderer.screen.width;
        tempRect.height = renderer.screen.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        destinationFrame = tempRect;
        destinationFrame.width = sourceFrame.width;
        destinationFrame.height = sourceFrame.height;
      }
    }
    var viewportFrame = this.viewportFrame;
    viewportFrame.x = destinationFrame.x * resolution;
    viewportFrame.y = destinationFrame.y * resolution;
    viewportFrame.width = destinationFrame.width * resolution;
    viewportFrame.height = destinationFrame.height * resolution;
    if (!renderTexture) {
      viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);
    }
    viewportFrame.ceil();
    this.renderer.framebuffer.bind(framebuffer, viewportFrame);
    this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
    if (renderTexture) {
      this.renderer.mask.setMaskStack(baseTexture.maskStack);
    } else {
      this.renderer.mask.setMaskStack(this.defaultMaskStack);
    }
    this.sourceFrame.copyFrom(sourceFrame);
    this.destinationFrame.copyFrom(destinationFrame);
  };
  RenderTextureSystem2.prototype.clear = function(clearColor, mask) {
    if (this.current) {
      clearColor = clearColor || this.current.baseTexture.clearColor;
    } else {
      clearColor = clearColor || this.clearColor;
    }
    var destinationFrame = this.destinationFrame;
    var baseFrame = this.current ? this.current.baseTexture : this.renderer.screen;
    var clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
    if (clearMask) {
      var _a2 = this.viewportFrame, x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
      x = Math.round(x);
      y = Math.round(y);
      width = Math.round(width);
      height = Math.round(height);
      this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
      this.renderer.gl.scissor(x, y, width, height);
    }
    this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3], mask);
    if (clearMask) {
      this.renderer.scissor.pop();
    }
  };
  RenderTextureSystem2.prototype.resize = function() {
    this.bind(null);
  };
  RenderTextureSystem2.prototype.reset = function() {
    this.bind(null);
  };
  RenderTextureSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return RenderTextureSystem2;
}();
function uboUpdate(_ud, _uv, _renderer, _syncData, buffer2) {
  _renderer.buffer.update(buffer2);
}
var UBO_TO_SINGLE_SETTERS = {
  float: "\n        data[offset] = v;\n    ",
  vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ",
  vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ",
  vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ",
  mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ",
  mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ",
  mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    "
};
var GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(uniformData) {
  var uboElements = uniformData.map(function(data) {
    return {
      data,
      offset: 0,
      dataLen: 0,
      dirty: 0
    };
  });
  var size = 0;
  var chunkSize = 0;
  var offset = 0;
  for (var i = 0; i < uboElements.length; i++) {
    var uboElement = uboElements[i];
    size = GLSL_TO_STD40_SIZE[uboElement.data.type];
    if (uboElement.data.size > 1) {
      size = Math.max(size, 16) * uboElement.data.size;
    }
    uboElement.dataLen = size;
    if (chunkSize % size !== 0 && chunkSize < 16) {
      var lineUpValue = chunkSize % size % 16;
      chunkSize += lineUpValue;
      offset += lineUpValue;
    }
    if (chunkSize + size > 16) {
      offset = Math.ceil(offset / 16) * 16;
      uboElement.offset = offset;
      offset += size;
      chunkSize = size;
    } else {
      uboElement.offset = offset;
      chunkSize += size;
      offset += size;
    }
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
function getUBOData(uniforms, uniformData) {
  var usedUniformDatas = [];
  for (var i in uniforms) {
    if (uniformData[i]) {
      usedUniformDatas.push(uniformData[i]);
    }
  }
  usedUniformDatas.sort(function(a, b) {
    return a.index - b.index;
  });
  return usedUniformDatas;
}
function generateUniformBufferSync(group, uniformData) {
  if (!group.autoManage) {
    return { size: 0, syncFunc: uboUpdate };
  }
  var usedUniformDatas = getUBOData(group.uniforms, uniformData);
  var _a2 = createUBOElements(usedUniformDatas), uboElements = _a2.uboElements, size = _a2.size;
  var funcFragments = ["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "];
  for (var i = 0; i < uboElements.length; i++) {
    var uboElement = uboElements[i];
    var uniform = group.uniforms[uboElement.data.name];
    var name = uboElement.data.name;
    var parsed = false;
    for (var j = 0; j < uniformParsers.length; j++) {
      var uniformParser = uniformParsers[j];
      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
        funcFragments.push("offset = " + uboElement.offset / 4 + ";", uniformParsers[j].codeUbo(uboElement.data.name, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        var size_1 = mapSize(uboElement.data.type);
        var rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
        var elementSize = size_1 / rowSize;
        var remainder = (4 - elementSize % 4) % 4;
        funcFragments.push("\n                cv = ud." + name + ".value;\n                v = uv." + name + ";\n                offset = " + uboElement.offset / 4 + ";\n\n                t = 0;\n\n                for(var i=0; i < " + uboElement.data.size * rowSize + "; i++)\n                {\n                    for(var j = 0; j < " + elementSize + "; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += " + remainder + ";\n                }\n\n                ");
      } else {
        var template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
        funcFragments.push("\n                cv = ud." + name + ".value;\n                v = uv." + name + ";\n                offset = " + uboElement.offset / 4 + ";\n                " + template + ";\n                ");
      }
    }
  }
  funcFragments.push("\n       renderer.buffer.update(buffer);\n    ");
  return {
    size,
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\n"))
  };
}
var GLProgram = function() {
  function GLProgram2(program, uniformData) {
    this.program = program;
    this.uniformData = uniformData;
    this.uniformGroups = {};
    this.uniformDirtyGroups = {};
    this.uniformBufferBindings = {};
  }
  GLProgram2.prototype.destroy = function() {
    this.uniformData = null;
    this.uniformGroups = null;
    this.uniformDirtyGroups = null;
    this.uniformBufferBindings = null;
    this.program = null;
  };
  return GLProgram2;
}();
function getAttributeData(program, gl) {
  var attributes = {};
  var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (var i = 0; i < totalAttributes; i++) {
    var attribData = gl.getActiveAttrib(program, i);
    if (attribData.name.indexOf("gl_") === 0) {
      continue;
    }
    var type = mapType(gl, attribData.type);
    var data = {
      type,
      name: attribData.name,
      size: mapSize(type),
      location: gl.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data;
  }
  return attributes;
}
function getUniformData(program, gl) {
  var uniforms = {};
  var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (var i = 0; i < totalUniforms; i++) {
    var uniformData = gl.getActiveUniform(program, i);
    var name = uniformData.name.replace(/\[.*?\]$/, "");
    var isArray2 = !!uniformData.name.match(/\[.*?\]$/);
    var type = mapType(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i,
      type,
      size: uniformData.size,
      isArray: isArray2,
      value: defaultValue(type, uniformData.size)
    };
  }
  return uniforms;
}
function generateProgram(gl, program) {
  var glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);
  var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);
  var webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program.attributeData = getAttributeData(webGLProgram, gl);
  program.uniformData = getUniformData(webGLProgram, gl);
  if (!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
    var keys = Object.keys(program.attributeData);
    keys.sort(function(a, b) {
      return a > b ? 1 : -1;
    });
    for (var i = 0; i < keys.length; i++) {
      program.attributeData[keys[i]].location = i;
      gl.bindAttribLocation(webGLProgram, i, keys[i]);
    }
    gl.linkProgram(webGLProgram);
  }
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  var uniformData = {};
  for (var i in program.uniformData) {
    var data = program.uniformData[i];
    uniformData[i] = {
      location: gl.getUniformLocation(webGLProgram, i),
      value: defaultValue(data.type, data.size)
    };
  }
  var glProgram = new GLProgram(webGLProgram, uniformData);
  return glProgram;
}
var UID$4 = 0;
var defaultSyncData = { textureCount: 0, uboCount: 0 };
var ShaderSystem = function() {
  function ShaderSystem2(renderer) {
    this.destroyed = false;
    this.renderer = renderer;
    this.systemCheck();
    this.gl = null;
    this.shader = null;
    this.program = null;
    this.cache = {};
    this._uboCache = {};
    this.id = UID$4++;
  }
  ShaderSystem2.prototype.systemCheck = function() {
    if (!unsafeEvalSupported()) {
      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }
  };
  ShaderSystem2.prototype.contextChange = function(gl) {
    this.gl = gl;
    this.reset();
  };
  ShaderSystem2.prototype.bind = function(shader, dontSync) {
    shader.uniforms.globals = this.renderer.globalUniforms;
    var program = shader.program;
    var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
    this.shader = shader;
    if (this.program !== program) {
      this.program = program;
      this.gl.useProgram(glProgram.program);
    }
    if (!dontSync) {
      defaultSyncData.textureCount = 0;
      defaultSyncData.uboCount = 0;
      this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
    }
    return glProgram;
  };
  ShaderSystem2.prototype.setUniforms = function(uniforms) {
    var shader = this.shader.program;
    var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
  };
  ShaderSystem2.prototype.syncUniformGroup = function(group, syncData) {
    var glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {
      glProgram.uniformDirtyGroups[group.id] = group.dirtyId;
      this.syncUniforms(group, glProgram, syncData);
    }
  };
  ShaderSystem2.prototype.syncUniforms = function(group, glProgram, syncData) {
    var syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
    syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
  };
  ShaderSystem2.prototype.createSyncGroups = function(group) {
    var id = this.getSignature(group, this.shader.program.uniformData, "u");
    if (!this.cache[id]) {
      this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData);
    }
    group.syncUniforms[this.shader.program.id] = this.cache[id];
    return group.syncUniforms[this.shader.program.id];
  };
  ShaderSystem2.prototype.syncUniformBufferGroup = function(group, name) {
    var glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
      group.dirtyId = 0;
      var syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);
      group.buffer.update();
      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);
    }
    this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);
  };
  ShaderSystem2.prototype.createSyncBufferGroup = function(group, glProgram, name) {
    var gl = this.renderer.gl;
    this.renderer.buffer.bind(group.buffer);
    var uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);
    glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;
    gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);
    this.shader.uniformBindCount++;
    var id = this.getSignature(group, this.shader.program.uniformData, "ubo");
    var uboData = this._uboCache[id];
    if (!uboData) {
      uboData = this._uboCache[id] = generateUniformBufferSync(group, this.shader.program.uniformData);
    }
    if (group.autoManage) {
      var data = new Float32Array(uboData.size / 4);
      group.buffer.update(data);
    }
    glProgram.uniformGroups[group.id] = uboData.syncFunc;
    return glProgram.uniformGroups[group.id];
  };
  ShaderSystem2.prototype.getSignature = function(group, uniformData, preFix) {
    var uniforms = group.uniforms;
    var strings = [preFix + "-"];
    for (var i in uniforms) {
      strings.push(i);
      if (uniformData[i]) {
        strings.push(uniformData[i].type);
      }
    }
    return strings.join("-");
  };
  ShaderSystem2.prototype.getGlProgram = function() {
    if (this.shader) {
      return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
    }
    return null;
  };
  ShaderSystem2.prototype.generateProgram = function(shader) {
    var gl = this.gl;
    var program = shader.program;
    var glProgram = generateProgram(gl, program);
    program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
    return glProgram;
  };
  ShaderSystem2.prototype.reset = function() {
    this.program = null;
    this.shader = null;
  };
  ShaderSystem2.prototype.destroy = function() {
    this.renderer = null;
    this.destroyed = true;
  };
  return ShaderSystem2;
}();
function mapWebGLBlendModesToPixi(gl, array) {
  if (array === void 0) {
    array = [];
  }
  array[BLEND_MODES$3.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.ADD] = [gl.ONE, gl.ONE];
  array[BLEND_MODES$3.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.NONE] = [0, 0];
  array[BLEND_MODES$3.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  array[BLEND_MODES$3.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
  array[BLEND_MODES$3.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
  array[BLEND_MODES$3.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
  array[BLEND_MODES$3.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
  array[BLEND_MODES$3.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
  array[BLEND_MODES$3.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
  return array;
}
var BLEND$1 = 0;
var OFFSET$1 = 1;
var CULLING$1 = 2;
var DEPTH_TEST$1 = 3;
var WINDING$1 = 4;
var DEPTH_MASK$1 = 5;
var StateSystem = function() {
  function StateSystem2() {
    this.gl = null;
    this.stateId = 0;
    this.polygonOffset = 0;
    this.blendMode = BLEND_MODES$3.NONE;
    this._blendEq = false;
    this.map = [];
    this.map[BLEND$1] = this.setBlend;
    this.map[OFFSET$1] = this.setOffset;
    this.map[CULLING$1] = this.setCullFace;
    this.map[DEPTH_TEST$1] = this.setDepthTest;
    this.map[WINDING$1] = this.setFrontFace;
    this.map[DEPTH_MASK$1] = this.setDepthMask;
    this.checks = [];
    this.defaultState = new State();
    this.defaultState.blend = true;
  }
  StateSystem2.prototype.contextChange = function(gl) {
    this.gl = gl;
    this.blendModes = mapWebGLBlendModesToPixi(gl);
    this.set(this.defaultState);
    this.reset();
  };
  StateSystem2.prototype.set = function(state) {
    state = state || this.defaultState;
    if (this.stateId !== state.data) {
      var diff = this.stateId ^ state.data;
      var i = 0;
      while (diff) {
        if (diff & 1) {
          this.map[i].call(this, !!(state.data & 1 << i));
        }
        diff = diff >> 1;
        i++;
      }
      this.stateId = state.data;
    }
    for (var i = 0; i < this.checks.length; i++) {
      this.checks[i](this, state);
    }
  };
  StateSystem2.prototype.forceState = function(state) {
    state = state || this.defaultState;
    for (var i = 0; i < this.map.length; i++) {
      this.map[i].call(this, !!(state.data & 1 << i));
    }
    for (var i = 0; i < this.checks.length; i++) {
      this.checks[i](this, state);
    }
    this.stateId = state.data;
  };
  StateSystem2.prototype.setBlend = function(value) {
    this.updateCheck(StateSystem2.checkBlendMode, value);
    this.gl[value ? "enable" : "disable"](this.gl.BLEND);
  };
  StateSystem2.prototype.setOffset = function(value) {
    this.updateCheck(StateSystem2.checkPolygonOffset, value);
    this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  };
  StateSystem2.prototype.setDepthTest = function(value) {
    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
  };
  StateSystem2.prototype.setDepthMask = function(value) {
    this.gl.depthMask(value);
  };
  StateSystem2.prototype.setCullFace = function(value) {
    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
  };
  StateSystem2.prototype.setFrontFace = function(value) {
    this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
  };
  StateSystem2.prototype.setBlendMode = function(value) {
    if (value === this.blendMode) {
      return;
    }
    this.blendMode = value;
    var mode2 = this.blendModes[value];
    var gl = this.gl;
    if (mode2.length === 2) {
      gl.blendFunc(mode2[0], mode2[1]);
    } else {
      gl.blendFuncSeparate(mode2[0], mode2[1], mode2[2], mode2[3]);
    }
    if (mode2.length === 6) {
      this._blendEq = true;
      gl.blendEquationSeparate(mode2[4], mode2[5]);
    } else if (this._blendEq) {
      this._blendEq = false;
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    }
  };
  StateSystem2.prototype.setPolygonOffset = function(value, scale) {
    this.gl.polygonOffset(value, scale);
  };
  StateSystem2.prototype.reset = function() {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
    this.forceState(this.defaultState);
    this._blendEq = true;
    this.blendMode = -1;
    this.setBlendMode(0);
  };
  StateSystem2.prototype.updateCheck = function(func, value) {
    var index2 = this.checks.indexOf(func);
    if (value && index2 === -1) {
      this.checks.push(func);
    } else if (!value && index2 !== -1) {
      this.checks.splice(index2, 1);
    }
  };
  StateSystem2.checkBlendMode = function(system, state) {
    system.setBlendMode(state.blendMode);
  };
  StateSystem2.checkPolygonOffset = function(system, state) {
    system.setPolygonOffset(1, state.polygonOffset);
  };
  StateSystem2.prototype.destroy = function() {
    this.gl = null;
  };
  return StateSystem2;
}();
var TextureGCSystem = function() {
  function TextureGCSystem2(renderer) {
    this.renderer = renderer;
    this.count = 0;
    this.checkCount = 0;
    this.maxIdle = settings.GC_MAX_IDLE;
    this.checkCountMax = settings.GC_MAX_CHECK_COUNT;
    this.mode = settings.GC_MODE;
  }
  TextureGCSystem2.prototype.postrender = function() {
    if (!this.renderer.renderingToScreen) {
      return;
    }
    this.count++;
    if (this.mode === GC_MODES$3.MANUAL) {
      return;
    }
    this.checkCount++;
    if (this.checkCount > this.checkCountMax) {
      this.checkCount = 0;
      this.run();
    }
  };
  TextureGCSystem2.prototype.run = function() {
    var tm = this.renderer.texture;
    var managedTextures = tm.managedTextures;
    var wasRemoved = false;
    for (var i = 0; i < managedTextures.length; i++) {
      var texture = managedTextures[i];
      if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
        tm.destroyTexture(texture, true);
        managedTextures[i] = null;
        wasRemoved = true;
      }
    }
    if (wasRemoved) {
      var j = 0;
      for (var i = 0; i < managedTextures.length; i++) {
        if (managedTextures[i] !== null) {
          managedTextures[j++] = managedTextures[i];
        }
      }
      managedTextures.length = j;
    }
  };
  TextureGCSystem2.prototype.unload = function(displayObject) {
    var tm = this.renderer.texture;
    var texture = displayObject._texture;
    if (texture && !texture.framebuffer) {
      tm.destroyTexture(texture);
    }
    for (var i = displayObject.children.length - 1; i >= 0; i--) {
      this.unload(displayObject.children[i]);
    }
  };
  TextureGCSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return TextureGCSystem2;
}();
function mapTypeAndFormatToInternalFormat(gl) {
  var _a2, _b2, _c2, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
  var table2;
  if ("WebGL2RenderingContext" in self && gl instanceof self.WebGL2RenderingContext) {
    table2 = (_a2 = {}, _a2[TYPES$3.UNSIGNED_BYTE] = (_b2 = {}, _b2[FORMATS$3.RGBA] = gl.RGBA8, _b2[FORMATS$3.RGB] = gl.RGB8, _b2[FORMATS$3.RG] = gl.RG8, _b2[FORMATS$3.RED] = gl.R8, _b2[FORMATS$3.RGBA_INTEGER] = gl.RGBA8UI, _b2[FORMATS$3.RGB_INTEGER] = gl.RGB8UI, _b2[FORMATS$3.RG_INTEGER] = gl.RG8UI, _b2[FORMATS$3.RED_INTEGER] = gl.R8UI, _b2[FORMATS$3.ALPHA] = gl.ALPHA, _b2[FORMATS$3.LUMINANCE] = gl.LUMINANCE, _b2[FORMATS$3.LUMINANCE_ALPHA] = gl.LUMINANCE_ALPHA, _b2), _a2[TYPES$3.BYTE] = (_c2 = {}, _c2[FORMATS$3.RGBA] = gl.RGBA8_SNORM, _c2[FORMATS$3.RGB] = gl.RGB8_SNORM, _c2[FORMATS$3.RG] = gl.RG8_SNORM, _c2[FORMATS$3.RED] = gl.R8_SNORM, _c2[FORMATS$3.RGBA_INTEGER] = gl.RGBA8I, _c2[FORMATS$3.RGB_INTEGER] = gl.RGB8I, _c2[FORMATS$3.RG_INTEGER] = gl.RG8I, _c2[FORMATS$3.RED_INTEGER] = gl.R8I, _c2), _a2[TYPES$3.UNSIGNED_SHORT] = (_d = {}, _d[FORMATS$3.RGBA_INTEGER] = gl.RGBA16UI, _d[FORMATS$3.RGB_INTEGER] = gl.RGB16UI, _d[FORMATS$3.RG_INTEGER] = gl.RG16UI, _d[FORMATS$3.RED_INTEGER] = gl.R16UI, _d[FORMATS$3.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT16, _d), _a2[TYPES$3.SHORT] = (_e = {}, _e[FORMATS$3.RGBA_INTEGER] = gl.RGBA16I, _e[FORMATS$3.RGB_INTEGER] = gl.RGB16I, _e[FORMATS$3.RG_INTEGER] = gl.RG16I, _e[FORMATS$3.RED_INTEGER] = gl.R16I, _e), _a2[TYPES$3.UNSIGNED_INT] = (_f = {}, _f[FORMATS$3.RGBA_INTEGER] = gl.RGBA32UI, _f[FORMATS$3.RGB_INTEGER] = gl.RGB32UI, _f[FORMATS$3.RG_INTEGER] = gl.RG32UI, _f[FORMATS$3.RED_INTEGER] = gl.R32UI, _f[FORMATS$3.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT24, _f), _a2[TYPES$3.INT] = (_g = {}, _g[FORMATS$3.RGBA_INTEGER] = gl.RGBA32I, _g[FORMATS$3.RGB_INTEGER] = gl.RGB32I, _g[FORMATS$3.RG_INTEGER] = gl.RG32I, _g[FORMATS$3.RED_INTEGER] = gl.R32I, _g), _a2[TYPES$3.FLOAT] = (_h = {}, _h[FORMATS$3.RGBA] = gl.RGBA32F, _h[FORMATS$3.RGB] = gl.RGB32F, _h[FORMATS$3.RG] = gl.RG32F, _h[FORMATS$3.RED] = gl.R32F, _h[FORMATS$3.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT32F, _h), _a2[TYPES$3.HALF_FLOAT] = (_j = {}, _j[FORMATS$3.RGBA] = gl.RGBA16F, _j[FORMATS$3.RGB] = gl.RGB16F, _j[FORMATS$3.RG] = gl.RG16F, _j[FORMATS$3.RED] = gl.R16F, _j), _a2[TYPES$3.UNSIGNED_SHORT_5_6_5] = (_k = {}, _k[FORMATS$3.RGB] = gl.RGB565, _k), _a2[TYPES$3.UNSIGNED_SHORT_4_4_4_4] = (_l = {}, _l[FORMATS$3.RGBA] = gl.RGBA4, _l), _a2[TYPES$3.UNSIGNED_SHORT_5_5_5_1] = (_m = {}, _m[FORMATS$3.RGBA] = gl.RGB5_A1, _m), _a2[TYPES$3.UNSIGNED_INT_2_10_10_10_REV] = (_o = {}, _o[FORMATS$3.RGBA] = gl.RGB10_A2, _o[FORMATS$3.RGBA_INTEGER] = gl.RGB10_A2UI, _o), _a2[TYPES$3.UNSIGNED_INT_10F_11F_11F_REV] = (_p = {}, _p[FORMATS$3.RGB] = gl.R11F_G11F_B10F, _p), _a2[TYPES$3.UNSIGNED_INT_5_9_9_9_REV] = (_q = {}, _q[FORMATS$3.RGB] = gl.RGB9_E5, _q), _a2[TYPES$3.UNSIGNED_INT_24_8] = (_r = {}, _r[FORMATS$3.DEPTH_STENCIL] = gl.DEPTH24_STENCIL8, _r), _a2[TYPES$3.FLOAT_32_UNSIGNED_INT_24_8_REV] = (_s = {}, _s[FORMATS$3.DEPTH_STENCIL] = gl.DEPTH32F_STENCIL8, _s), _a2);
  } else {
    table2 = (_t = {}, _t[TYPES$3.UNSIGNED_BYTE] = (_u = {}, _u[FORMATS$3.RGBA] = gl.RGBA, _u[FORMATS$3.RGB] = gl.RGB, _u[FORMATS$3.ALPHA] = gl.ALPHA, _u[FORMATS$3.LUMINANCE] = gl.LUMINANCE, _u[FORMATS$3.LUMINANCE_ALPHA] = gl.LUMINANCE_ALPHA, _u), _t[TYPES$3.UNSIGNED_SHORT_5_6_5] = (_v = {}, _v[FORMATS$3.RGB] = gl.RGB, _v), _t[TYPES$3.UNSIGNED_SHORT_4_4_4_4] = (_w = {}, _w[FORMATS$3.RGBA] = gl.RGBA, _w), _t[TYPES$3.UNSIGNED_SHORT_5_5_5_1] = (_x = {}, _x[FORMATS$3.RGBA] = gl.RGBA, _x), _t);
  }
  return table2;
}
var GLTexture = function() {
  function GLTexture2(texture) {
    this.texture = texture;
    this.width = -1;
    this.height = -1;
    this.dirtyId = -1;
    this.dirtyStyleId = -1;
    this.mipmap = false;
    this.wrapMode = 33071;
    this.type = TYPES$3.UNSIGNED_BYTE;
    this.internalFormat = FORMATS$3.RGBA;
    this.samplerType = 0;
  }
  return GLTexture2;
}();
var TextureSystem = function() {
  function TextureSystem2(renderer) {
    this.renderer = renderer;
    this.boundTextures = [];
    this.currentLocation = -1;
    this.managedTextures = [];
    this._unknownBoundTextures = false;
    this.unknownTexture = new BaseTexture();
    this.hasIntegerTextures = false;
  }
  TextureSystem2.prototype.contextChange = function() {
    var gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.webGLVersion = this.renderer.context.webGLVersion;
    this.internalFormats = mapTypeAndFormatToInternalFormat(gl);
    var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.boundTextures.length = maxTextures;
    for (var i = 0; i < maxTextures; i++) {
      this.boundTextures[i] = null;
    }
    this.emptyTextures = {};
    var emptyTexture2D = new GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
    this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
    this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
    for (var i = 0; i < 6; i++) {
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    for (var i = 0; i < this.boundTextures.length; i++) {
      this.bind(null, i);
    }
  };
  TextureSystem2.prototype.bind = function(texture, location) {
    if (location === void 0) {
      location = 0;
    }
    var gl = this.gl;
    texture = texture === null || texture === void 0 ? void 0 : texture.castToBaseTexture();
    if (texture && texture.valid && !texture.parentTextureArray) {
      texture.touched = this.renderer.textureGC.count;
      var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
      if (this.boundTextures[location] !== texture) {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        gl.bindTexture(texture.target, glTexture.texture);
      }
      if (glTexture.dirtyId !== texture.dirtyId) {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        this.updateTexture(texture);
      }
      this.boundTextures[location] = texture;
    } else {
      if (this.currentLocation !== location) {
        this.currentLocation = location;
        gl.activeTexture(gl.TEXTURE0 + location);
      }
      gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
      this.boundTextures[location] = null;
    }
  };
  TextureSystem2.prototype.reset = function() {
    this._unknownBoundTextures = true;
    this.hasIntegerTextures = false;
    this.currentLocation = -1;
    for (var i = 0; i < this.boundTextures.length; i++) {
      this.boundTextures[i] = this.unknownTexture;
    }
  };
  TextureSystem2.prototype.unbind = function(texture) {
    var _a2 = this, gl = _a2.gl, boundTextures = _a2.boundTextures;
    if (this._unknownBoundTextures) {
      this._unknownBoundTextures = false;
      for (var i = 0; i < boundTextures.length; i++) {
        if (boundTextures[i] === this.unknownTexture) {
          this.bind(null, i);
        }
      }
    }
    for (var i = 0; i < boundTextures.length; i++) {
      if (boundTextures[i] === texture) {
        if (this.currentLocation !== i) {
          gl.activeTexture(gl.TEXTURE0 + i);
          this.currentLocation = i;
        }
        gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
        boundTextures[i] = null;
      }
    }
  };
  TextureSystem2.prototype.ensureSamplerType = function(maxTextures) {
    var _a2 = this, boundTextures = _a2.boundTextures, hasIntegerTextures = _a2.hasIntegerTextures, CONTEXT_UID = _a2.CONTEXT_UID;
    if (!hasIntegerTextures) {
      return;
    }
    for (var i = maxTextures - 1; i >= 0; --i) {
      var tex = boundTextures[i];
      if (tex) {
        var glTexture = tex._glTextures[CONTEXT_UID];
        if (glTexture.samplerType !== SAMPLER_TYPES$3.FLOAT) {
          this.renderer.texture.unbind(tex);
        }
      }
    }
  };
  TextureSystem2.prototype.initTexture = function(texture) {
    var glTexture = new GLTexture(this.gl.createTexture());
    glTexture.dirtyId = -1;
    texture._glTextures[this.CONTEXT_UID] = glTexture;
    this.managedTextures.push(texture);
    texture.on("dispose", this.destroyTexture, this);
    return glTexture;
  };
  TextureSystem2.prototype.initTextureType = function(texture, glTexture) {
    var _a2, _b2;
    glTexture.internalFormat = (_b2 = (_a2 = this.internalFormats[texture.type]) === null || _a2 === void 0 ? void 0 : _a2[texture.format]) !== null && _b2 !== void 0 ? _b2 : texture.format;
    if (this.webGLVersion === 2 && texture.type === TYPES$3.HALF_FLOAT) {
      glTexture.type = this.gl.HALF_FLOAT;
    } else {
      glTexture.type = texture.type;
    }
  };
  TextureSystem2.prototype.updateTexture = function(texture) {
    var glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    var renderer = this.renderer;
    this.initTextureType(texture, glTexture);
    if (texture.resource && texture.resource.upload(renderer, texture, glTexture)) {
      if (glTexture.samplerType !== SAMPLER_TYPES$3.FLOAT) {
        this.hasIntegerTextures = true;
      }
    } else {
      var width = texture.realWidth;
      var height = texture.realHeight;
      var gl = renderer.gl;
      if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
      }
    }
    if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
      this.updateTextureStyle(texture);
    }
    glTexture.dirtyId = texture.dirtyId;
  };
  TextureSystem2.prototype.destroyTexture = function(texture, skipRemove) {
    var gl = this.gl;
    texture = texture.castToBaseTexture();
    if (texture._glTextures[this.CONTEXT_UID]) {
      this.unbind(texture);
      gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
      texture.off("dispose", this.destroyTexture, this);
      delete texture._glTextures[this.CONTEXT_UID];
      if (!skipRemove) {
        var i = this.managedTextures.indexOf(texture);
        if (i !== -1) {
          removeItems(this.managedTextures, i, 1);
        }
      }
    }
  };
  TextureSystem2.prototype.updateTextureStyle = function(texture) {
    var glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    if ((texture.mipmap === MIPMAP_MODES$3.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
      glTexture.mipmap = false;
    } else {
      glTexture.mipmap = texture.mipmap >= 1;
    }
    if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
      glTexture.wrapMode = WRAP_MODES$3.CLAMP;
    } else {
      glTexture.wrapMode = texture.wrapMode;
    }
    if (texture.resource && texture.resource.style(this.renderer, texture, glTexture))
      ;
    else {
      this.setStyle(texture, glTexture);
    }
    glTexture.dirtyStyleId = texture.dirtyStyleId;
  };
  TextureSystem2.prototype.setStyle = function(texture, glTexture) {
    var gl = this.gl;
    if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES$3.ON_MANUAL) {
      gl.generateMipmap(texture.target);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
    if (glTexture.mipmap) {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES$3.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
      var anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES$3.LINEAR) {
        var level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
      }
    } else {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES$3.LINEAR ? gl.LINEAR : gl.NEAREST);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES$3.LINEAR ? gl.LINEAR : gl.NEAREST);
  };
  TextureSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return TextureSystem2;
}();
var _systems = {
  __proto__: null,
  FilterSystem,
  BatchSystem,
  ContextSystem,
  FramebufferSystem,
  GeometrySystem,
  MaskSystem,
  ScissorSystem,
  StencilSystem,
  ProjectionSystem,
  RenderTextureSystem,
  ShaderSystem,
  StateSystem,
  TextureGCSystem,
  TextureSystem
};
var tempMatrix$2 = new Matrix();
var AbstractRenderer = function(_super) {
  __extends$h(AbstractRenderer2, _super);
  function AbstractRenderer2(type, options) {
    if (type === void 0) {
      type = RENDERER_TYPE$3.UNKNOWN;
    }
    var _this = _super.call(this) || this;
    options = Object.assign({}, settings.RENDER_OPTIONS, options);
    _this.options = options;
    _this.type = type;
    _this.screen = new Rectangle(0, 0, options.width, options.height);
    _this.view = options.view || document.createElement("canvas");
    _this.resolution = options.resolution || settings.RESOLUTION;
    _this.useContextAlpha = options.useContextAlpha;
    _this.autoDensity = !!options.autoDensity;
    _this.preserveDrawingBuffer = options.preserveDrawingBuffer;
    _this.clearBeforeRender = options.clearBeforeRender;
    _this._backgroundColor = 0;
    _this._backgroundColorRgba = [0, 0, 0, 1];
    _this._backgroundColorString = "#000000";
    _this.backgroundColor = options.backgroundColor || _this._backgroundColor;
    _this.backgroundAlpha = options.backgroundAlpha;
    if (options.transparent !== void 0) {
      deprecation("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead.");
      _this.useContextAlpha = options.transparent;
      _this.backgroundAlpha = options.transparent ? 0 : 1;
    }
    _this._lastObjectRendered = null;
    _this.plugins = {};
    return _this;
  }
  AbstractRenderer2.prototype.initPlugins = function(staticMap) {
    for (var o in staticMap) {
      this.plugins[o] = new staticMap[o](this);
    }
  };
  Object.defineProperty(AbstractRenderer2.prototype, "width", {
    get: function() {
      return this.view.width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractRenderer2.prototype, "height", {
    get: function() {
      return this.view.height;
    },
    enumerable: false,
    configurable: true
  });
  AbstractRenderer2.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {
    this.view.width = Math.round(desiredScreenWidth * this.resolution);
    this.view.height = Math.round(desiredScreenHeight * this.resolution);
    var screenWidth = this.view.width / this.resolution;
    var screenHeight = this.view.height / this.resolution;
    this.screen.width = screenWidth;
    this.screen.height = screenHeight;
    if (this.autoDensity) {
      this.view.style.width = screenWidth + "px";
      this.view.style.height = screenHeight + "px";
    }
    this.emit("resize", screenWidth, screenHeight);
  };
  AbstractRenderer2.prototype.generateTexture = function(displayObject, options, resolution, region) {
    if (options === void 0) {
      options = {};
    }
    if (typeof options === "number") {
      deprecation("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options.");
      options = { scaleMode: options, resolution, region };
    }
    var manualRegion = options.region, textureOptions = __rest(options, ["region"]);
    region = manualRegion || displayObject.getLocalBounds(null, true);
    if (region.width === 0) {
      region.width = 1;
    }
    if (region.height === 0) {
      region.height = 1;
    }
    var renderTexture = RenderTexture.create(__assign({ width: region.width, height: region.height }, textureOptions));
    tempMatrix$2.tx = -region.x;
    tempMatrix$2.ty = -region.y;
    this.render(displayObject, {
      renderTexture,
      clear: false,
      transform: tempMatrix$2,
      skipUpdateTransform: !!displayObject.parent
    });
    return renderTexture;
  };
  AbstractRenderer2.prototype.destroy = function(removeView) {
    for (var o in this.plugins) {
      this.plugins[o].destroy();
      this.plugins[o] = null;
    }
    if (removeView && this.view.parentNode) {
      this.view.parentNode.removeChild(this.view);
    }
    var thisAny = this;
    thisAny.plugins = null;
    thisAny.type = RENDERER_TYPE$3.UNKNOWN;
    thisAny.view = null;
    thisAny.screen = null;
    thisAny._tempDisplayObjectParent = null;
    thisAny.options = null;
    this._backgroundColorRgba = null;
    this._backgroundColorString = null;
    this._lastObjectRendered = null;
  };
  Object.defineProperty(AbstractRenderer2.prototype, "backgroundColor", {
    get: function() {
      return this._backgroundColor;
    },
    set: function(value) {
      this._backgroundColor = value;
      this._backgroundColorString = hex2string(value);
      hex2rgb(value, this._backgroundColorRgba);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractRenderer2.prototype, "backgroundAlpha", {
    get: function() {
      return this._backgroundColorRgba[3];
    },
    set: function(value) {
      this._backgroundColorRgba[3] = value;
    },
    enumerable: false,
    configurable: true
  });
  return AbstractRenderer2;
}(EventEmitter);
var GLBuffer = function() {
  function GLBuffer2(buffer2) {
    this.buffer = buffer2 || null;
    this.updateID = -1;
    this.byteLength = -1;
    this.refCount = 0;
  }
  return GLBuffer2;
}();
var BufferSystem = function() {
  function BufferSystem2(renderer) {
    this.renderer = renderer;
    this.managedBuffers = {};
    this.boundBufferBases = {};
  }
  BufferSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  BufferSystem2.prototype.contextChange = function() {
    this.disposeAll(true);
    this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  };
  BufferSystem2.prototype.bind = function(buffer2) {
    var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
    var glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
    gl.bindBuffer(buffer2.type, glBuffer.buffer);
  };
  BufferSystem2.prototype.bindBufferBase = function(buffer2, index2) {
    var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
    if (this.boundBufferBases[index2] !== buffer2) {
      var glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
      this.boundBufferBases[index2] = buffer2;
      gl.bindBufferBase(gl.UNIFORM_BUFFER, index2, glBuffer.buffer);
    }
  };
  BufferSystem2.prototype.bindBufferRange = function(buffer2, index2, offset) {
    var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
    offset = offset || 0;
    var glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
    gl.bindBufferRange(gl.UNIFORM_BUFFER, index2 || 0, glBuffer.buffer, offset * 256, 256);
  };
  BufferSystem2.prototype.update = function(buffer2) {
    var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
    var glBuffer = buffer2._glBuffers[CONTEXT_UID];
    if (buffer2._updateID === glBuffer.updateID) {
      return;
    }
    glBuffer.updateID = buffer2._updateID;
    gl.bindBuffer(buffer2.type, glBuffer.buffer);
    if (glBuffer.byteLength >= buffer2.data.byteLength) {
      gl.bufferSubData(buffer2.type, 0, buffer2.data);
    } else {
      var drawType = buffer2.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
      glBuffer.byteLength = buffer2.data.byteLength;
      gl.bufferData(buffer2.type, buffer2.data, drawType);
    }
  };
  BufferSystem2.prototype.dispose = function(buffer2, contextLost) {
    if (!this.managedBuffers[buffer2.id]) {
      return;
    }
    delete this.managedBuffers[buffer2.id];
    var glBuffer = buffer2._glBuffers[this.CONTEXT_UID];
    var gl = this.gl;
    buffer2.disposeRunner.remove(this);
    if (!glBuffer) {
      return;
    }
    if (!contextLost) {
      gl.deleteBuffer(glBuffer.buffer);
    }
    delete buffer2._glBuffers[this.CONTEXT_UID];
  };
  BufferSystem2.prototype.disposeAll = function(contextLost) {
    var all = Object.keys(this.managedBuffers);
    for (var i = 0; i < all.length; i++) {
      this.dispose(this.managedBuffers[all[i]], contextLost);
    }
  };
  BufferSystem2.prototype.createGLBuffer = function(buffer2) {
    var _a2 = this, CONTEXT_UID = _a2.CONTEXT_UID, gl = _a2.gl;
    buffer2._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());
    this.managedBuffers[buffer2.id] = buffer2;
    buffer2.disposeRunner.add(this);
    return buffer2._glBuffers[CONTEXT_UID];
  };
  return BufferSystem2;
}();
var Renderer$1 = function(_super) {
  __extends$h(Renderer2, _super);
  function Renderer2(options) {
    var _this = _super.call(this, RENDERER_TYPE$3.WEBGL, options) || this;
    options = _this.options;
    _this.gl = null;
    _this.CONTEXT_UID = 0;
    _this.runners = {
      destroy: new Runner("destroy"),
      contextChange: new Runner("contextChange"),
      reset: new Runner("reset"),
      update: new Runner("update"),
      postrender: new Runner("postrender"),
      prerender: new Runner("prerender"),
      resize: new Runner("resize")
    };
    _this.runners.contextChange.add(_this);
    _this.globalUniforms = new UniformGroup({
      projectionMatrix: new Matrix()
    }, true);
    _this.addSystem(MaskSystem, "mask").addSystem(ContextSystem, "context").addSystem(StateSystem, "state").addSystem(ShaderSystem, "shader").addSystem(TextureSystem, "texture").addSystem(BufferSystem, "buffer").addSystem(GeometrySystem, "geometry").addSystem(FramebufferSystem, "framebuffer").addSystem(ScissorSystem, "scissor").addSystem(StencilSystem, "stencil").addSystem(ProjectionSystem, "projection").addSystem(TextureGCSystem, "textureGC").addSystem(FilterSystem, "filter").addSystem(RenderTextureSystem, "renderTexture").addSystem(BatchSystem, "batch");
    _this.initPlugins(Renderer2.__plugins);
    _this.multisample = void 0;
    if (options.context) {
      _this.context.initFromContext(options.context);
    } else {
      _this.context.initFromOptions({
        alpha: !!_this.useContextAlpha,
        antialias: options.antialias,
        premultipliedAlpha: _this.useContextAlpha && _this.useContextAlpha !== "notMultiplied",
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer,
        powerPreference: _this.options.powerPreference
      });
    }
    _this.renderingToScreen = true;
    sayHello(_this.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1");
    _this.resize(_this.options.width, _this.options.height);
    return _this;
  }
  Renderer2.create = function(options) {
    if (isWebGLSupported()) {
      return new Renderer2(options);
    }
    throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
  };
  Renderer2.prototype.contextChange = function() {
    var gl = this.gl;
    var samples;
    if (this.context.webGLVersion === 1) {
      var framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    } else {
      var framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
    }
    if (samples >= MSAA_QUALITY$3.HIGH) {
      this.multisample = MSAA_QUALITY$3.HIGH;
    } else if (samples >= MSAA_QUALITY$3.MEDIUM) {
      this.multisample = MSAA_QUALITY$3.MEDIUM;
    } else if (samples >= MSAA_QUALITY$3.LOW) {
      this.multisample = MSAA_QUALITY$3.LOW;
    } else {
      this.multisample = MSAA_QUALITY$3.NONE;
    }
  };
  Renderer2.prototype.addSystem = function(ClassRef, name) {
    var system = new ClassRef(this);
    if (this[name]) {
      throw new Error('Whoops! The name "' + name + '" is already in use');
    }
    this[name] = system;
    for (var i in this.runners) {
      this.runners[i].add(system);
    }
    return this;
  };
  Renderer2.prototype.render = function(displayObject, options) {
    var renderTexture;
    var clear;
    var transform;
    var skipUpdateTransform;
    if (options) {
      if (options instanceof RenderTexture) {
        deprecation("6.0.0", "Renderer#render arguments changed, use options instead.");
        renderTexture = options;
        clear = arguments[2];
        transform = arguments[3];
        skipUpdateTransform = arguments[4];
      } else {
        renderTexture = options.renderTexture;
        clear = options.clear;
        transform = options.transform;
        skipUpdateTransform = options.skipUpdateTransform;
      }
    }
    this.renderingToScreen = !renderTexture;
    this.runners.prerender.emit();
    this.emit("prerender");
    this.projection.transform = transform;
    if (this.context.isLost) {
      return;
    }
    if (!renderTexture) {
      this._lastObjectRendered = displayObject;
    }
    if (!skipUpdateTransform) {
      var cacheParent = displayObject.enableTempParent();
      displayObject.updateTransform();
      displayObject.disableTempParent(cacheParent);
    }
    this.renderTexture.bind(renderTexture);
    this.batch.currentRenderer.start();
    if (clear !== void 0 ? clear : this.clearBeforeRender) {
      this.renderTexture.clear();
    }
    displayObject.render(this);
    this.batch.currentRenderer.flush();
    if (renderTexture) {
      renderTexture.baseTexture.update();
    }
    this.runners.postrender.emit();
    this.projection.transform = null;
    this.emit("postrender");
  };
  Renderer2.prototype.generateTexture = function(displayObject, options, resolution, region) {
    if (options === void 0) {
      options = {};
    }
    var renderTexture = _super.prototype.generateTexture.call(this, displayObject, options, resolution, region);
    this.framebuffer.blit();
    return renderTexture;
  };
  Renderer2.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {
    _super.prototype.resize.call(this, desiredScreenWidth, desiredScreenHeight);
    this.runners.resize.emit(this.screen.height, this.screen.width);
  };
  Renderer2.prototype.reset = function() {
    this.runners.reset.emit();
    return this;
  };
  Renderer2.prototype.clear = function() {
    this.renderTexture.bind();
    this.renderTexture.clear();
  };
  Renderer2.prototype.destroy = function(removeView) {
    this.runners.destroy.emit();
    for (var r in this.runners) {
      this.runners[r].destroy();
    }
    _super.prototype.destroy.call(this, removeView);
    this.gl = null;
  };
  Object.defineProperty(Renderer2.prototype, "extract", {
    get: function() {
      deprecation("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.");
      return this.plugins.extract;
    },
    enumerable: false,
    configurable: true
  });
  Renderer2.registerPlugin = function(pluginName, ctor) {
    Renderer2.__plugins = Renderer2.__plugins || {};
    Renderer2.__plugins[pluginName] = ctor;
  };
  return Renderer2;
}(AbstractRenderer);
function autoDetectRenderer(options) {
  return Renderer$1.create(options);
}
var $defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var $defaultFilterVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
var defaultVertex$2 = $defaultVertex;
var defaultFilterVertex = $defaultFilterVertex;
var BatchDrawCall = function() {
  function BatchDrawCall2() {
    this.texArray = null;
    this.blend = 0;
    this.type = DRAW_MODES$3.TRIANGLES;
    this.start = 0;
    this.size = 0;
    this.data = null;
  }
  return BatchDrawCall2;
}();
var BatchTextureArray = function() {
  function BatchTextureArray2() {
    this.elements = [];
    this.ids = [];
    this.count = 0;
  }
  BatchTextureArray2.prototype.clear = function() {
    for (var i = 0; i < this.count; i++) {
      this.elements[i] = null;
    }
    this.count = 0;
  };
  return BatchTextureArray2;
}();
var ViewableBuffer = function() {
  function ViewableBuffer2(sizeOrBuffer) {
    if (typeof sizeOrBuffer === "number") {
      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
    } else if (sizeOrBuffer instanceof Uint8Array) {
      this.rawBinaryData = sizeOrBuffer.buffer;
    } else {
      this.rawBinaryData = sizeOrBuffer;
    }
    this.uint32View = new Uint32Array(this.rawBinaryData);
    this.float32View = new Float32Array(this.rawBinaryData);
  }
  Object.defineProperty(ViewableBuffer2.prototype, "int8View", {
    get: function() {
      if (!this._int8View) {
        this._int8View = new Int8Array(this.rawBinaryData);
      }
      return this._int8View;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewableBuffer2.prototype, "uint8View", {
    get: function() {
      if (!this._uint8View) {
        this._uint8View = new Uint8Array(this.rawBinaryData);
      }
      return this._uint8View;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewableBuffer2.prototype, "int16View", {
    get: function() {
      if (!this._int16View) {
        this._int16View = new Int16Array(this.rawBinaryData);
      }
      return this._int16View;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewableBuffer2.prototype, "uint16View", {
    get: function() {
      if (!this._uint16View) {
        this._uint16View = new Uint16Array(this.rawBinaryData);
      }
      return this._uint16View;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewableBuffer2.prototype, "int32View", {
    get: function() {
      if (!this._int32View) {
        this._int32View = new Int32Array(this.rawBinaryData);
      }
      return this._int32View;
    },
    enumerable: false,
    configurable: true
  });
  ViewableBuffer2.prototype.view = function(type) {
    return this[type + "View"];
  };
  ViewableBuffer2.prototype.destroy = function() {
    this.rawBinaryData = null;
    this._int8View = null;
    this._uint8View = null;
    this._int16View = null;
    this._uint16View = null;
    this._int32View = null;
    this.uint32View = null;
    this.float32View = null;
  };
  ViewableBuffer2.sizeOf = function(type) {
    switch (type) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(type + " isn't a valid view type");
    }
  };
  return ViewableBuffer2;
}();
var AbstractBatchRenderer = function(_super) {
  __extends$h(AbstractBatchRenderer2, _super);
  function AbstractBatchRenderer2(renderer) {
    var _this = _super.call(this, renderer) || this;
    _this.shaderGenerator = null;
    _this.geometryClass = null;
    _this.vertexSize = null;
    _this.state = State.for2d();
    _this.size = settings.SPRITE_BATCH_SIZE * 4;
    _this._vertexCount = 0;
    _this._indexCount = 0;
    _this._bufferedElements = [];
    _this._bufferedTextures = [];
    _this._bufferSize = 0;
    _this._shader = null;
    _this._packedGeometries = [];
    _this._packedGeometryPoolSize = 2;
    _this._flushId = 0;
    _this._aBuffers = {};
    _this._iBuffers = {};
    _this.MAX_TEXTURES = 1;
    _this.renderer.on("prerender", _this.onPrerender, _this);
    renderer.runners.contextChange.add(_this);
    _this._dcIndex = 0;
    _this._aIndex = 0;
    _this._iIndex = 0;
    _this._attributeBuffer = null;
    _this._indexBuffer = null;
    _this._tempBoundTextures = [];
    return _this;
  }
  AbstractBatchRenderer2.prototype.contextChange = function() {
    var gl = this.renderer.gl;
    if (settings.PREFER_ENV === ENV$3.WEBGL_LEGACY) {
      this.MAX_TEXTURES = 1;
    } else {
      this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES);
      this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);
    }
    this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
    for (var i = 0; i < this._packedGeometryPoolSize; i++) {
      this._packedGeometries[i] = new this.geometryClass();
    }
    this.initFlushBuffers();
  };
  AbstractBatchRenderer2.prototype.initFlushBuffers = function() {
    var _drawCallPool = AbstractBatchRenderer2._drawCallPool, _textureArrayPool = AbstractBatchRenderer2._textureArrayPool;
    var MAX_SPRITES = this.size / 4;
    var MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;
    while (_drawCallPool.length < MAX_SPRITES) {
      _drawCallPool.push(new BatchDrawCall());
    }
    while (_textureArrayPool.length < MAX_TA) {
      _textureArrayPool.push(new BatchTextureArray());
    }
    for (var i = 0; i < this.MAX_TEXTURES; i++) {
      this._tempBoundTextures[i] = null;
    }
  };
  AbstractBatchRenderer2.prototype.onPrerender = function() {
    this._flushId = 0;
  };
  AbstractBatchRenderer2.prototype.render = function(element) {
    if (!element._texture.valid) {
      return;
    }
    if (this._vertexCount + element.vertexData.length / 2 > this.size) {
      this.flush();
    }
    this._vertexCount += element.vertexData.length / 2;
    this._indexCount += element.indices.length;
    this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
    this._bufferedElements[this._bufferSize++] = element;
  };
  AbstractBatchRenderer2.prototype.buildTexturesAndDrawCalls = function() {
    var _a2 = this, textures = _a2._bufferedTextures, MAX_TEXTURES = _a2.MAX_TEXTURES;
    var textureArrays = AbstractBatchRenderer2._textureArrayPool;
    var batch = this.renderer.batch;
    var boundTextures = this._tempBoundTextures;
    var touch = this.renderer.textureGC.count;
    var TICK = ++BaseTexture._globalBatch;
    var countTexArrays = 0;
    var texArray = textureArrays[0];
    var start = 0;
    batch.copyBoundTextures(boundTextures, MAX_TEXTURES);
    for (var i = 0; i < this._bufferSize; ++i) {
      var tex = textures[i];
      textures[i] = null;
      if (tex._batchEnabled === TICK) {
        continue;
      }
      if (texArray.count >= MAX_TEXTURES) {
        batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
        this.buildDrawCalls(texArray, start, i);
        start = i;
        texArray = textureArrays[++countTexArrays];
        ++TICK;
      }
      tex._batchEnabled = TICK;
      tex.touched = touch;
      texArray.elements[texArray.count++] = tex;
    }
    if (texArray.count > 0) {
      batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
      this.buildDrawCalls(texArray, start, this._bufferSize);
      ++countTexArrays;
      ++TICK;
    }
    for (var i = 0; i < boundTextures.length; i++) {
      boundTextures[i] = null;
    }
    BaseTexture._globalBatch = TICK;
  };
  AbstractBatchRenderer2.prototype.buildDrawCalls = function(texArray, start, finish) {
    var _a2 = this, elements = _a2._bufferedElements, _attributeBuffer = _a2._attributeBuffer, _indexBuffer = _a2._indexBuffer, vertexSize = _a2.vertexSize;
    var drawCalls = AbstractBatchRenderer2._drawCallPool;
    var dcIndex = this._dcIndex;
    var aIndex = this._aIndex;
    var iIndex = this._iIndex;
    var drawCall = drawCalls[dcIndex];
    drawCall.start = this._iIndex;
    drawCall.texArray = texArray;
    for (var i = start; i < finish; ++i) {
      var sprite = elements[i];
      var tex = sprite._texture.baseTexture;
      var spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
      elements[i] = null;
      if (start < i && drawCall.blend !== spriteBlendMode) {
        drawCall.size = iIndex - drawCall.start;
        start = i;
        drawCall = drawCalls[++dcIndex];
        drawCall.texArray = texArray;
        drawCall.start = iIndex;
      }
      this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
      aIndex += sprite.vertexData.length / 2 * vertexSize;
      iIndex += sprite.indices.length;
      drawCall.blend = spriteBlendMode;
    }
    if (start < finish) {
      drawCall.size = iIndex - drawCall.start;
      ++dcIndex;
    }
    this._dcIndex = dcIndex;
    this._aIndex = aIndex;
    this._iIndex = iIndex;
  };
  AbstractBatchRenderer2.prototype.bindAndClearTexArray = function(texArray) {
    var textureSystem = this.renderer.texture;
    for (var j = 0; j < texArray.count; j++) {
      textureSystem.bind(texArray.elements[j], texArray.ids[j]);
      texArray.elements[j] = null;
    }
    texArray.count = 0;
  };
  AbstractBatchRenderer2.prototype.updateGeometry = function() {
    var _a2 = this, packedGeometries = _a2._packedGeometries, attributeBuffer = _a2._attributeBuffer, indexBuffer = _a2._indexBuffer;
    if (!settings.CAN_UPLOAD_SAME_BUFFER) {
      if (this._packedGeometryPoolSize <= this._flushId) {
        this._packedGeometryPoolSize++;
        packedGeometries[this._flushId] = new this.geometryClass();
      }
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.bind(packedGeometries[this._flushId]);
      this.renderer.geometry.updateBuffers();
      this._flushId++;
    } else {
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.updateBuffers();
    }
  };
  AbstractBatchRenderer2.prototype.drawBatches = function() {
    var dcCount = this._dcIndex;
    var _a2 = this.renderer, gl = _a2.gl, stateSystem = _a2.state;
    var drawCalls = AbstractBatchRenderer2._drawCallPool;
    var curTexArray = null;
    for (var i = 0; i < dcCount; i++) {
      var _b2 = drawCalls[i], texArray = _b2.texArray, type = _b2.type, size = _b2.size, start = _b2.start, blend = _b2.blend;
      if (curTexArray !== texArray) {
        curTexArray = texArray;
        this.bindAndClearTexArray(texArray);
      }
      this.state.blendMode = blend;
      stateSystem.set(this.state);
      gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);
    }
  };
  AbstractBatchRenderer2.prototype.flush = function() {
    if (this._vertexCount === 0) {
      return;
    }
    this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
    this._indexBuffer = this.getIndexBuffer(this._indexCount);
    this._aIndex = 0;
    this._iIndex = 0;
    this._dcIndex = 0;
    this.buildTexturesAndDrawCalls();
    this.updateGeometry();
    this.drawBatches();
    this._bufferSize = 0;
    this._vertexCount = 0;
    this._indexCount = 0;
  };
  AbstractBatchRenderer2.prototype.start = function() {
    this.renderer.state.set(this.state);
    this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES);
    this.renderer.shader.bind(this._shader);
    if (settings.CAN_UPLOAD_SAME_BUFFER) {
      this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }
  };
  AbstractBatchRenderer2.prototype.stop = function() {
    this.flush();
  };
  AbstractBatchRenderer2.prototype.destroy = function() {
    for (var i = 0; i < this._packedGeometryPoolSize; i++) {
      if (this._packedGeometries[i]) {
        this._packedGeometries[i].destroy();
      }
    }
    this.renderer.off("prerender", this.onPrerender, this);
    this._aBuffers = null;
    this._iBuffers = null;
    this._packedGeometries = null;
    this._attributeBuffer = null;
    this._indexBuffer = null;
    if (this._shader) {
      this._shader.destroy();
      this._shader = null;
    }
    _super.prototype.destroy.call(this);
  };
  AbstractBatchRenderer2.prototype.getAttributeBuffer = function(size) {
    var roundedP2 = nextPow2(Math.ceil(size / 8));
    var roundedSizeIndex = log2(roundedP2);
    var roundedSize = roundedP2 * 8;
    if (this._aBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    var buffer2 = this._aBuffers[roundedSize];
    if (!buffer2) {
      this._aBuffers[roundedSize] = buffer2 = new ViewableBuffer(roundedSize * this.vertexSize * 4);
    }
    return buffer2;
  };
  AbstractBatchRenderer2.prototype.getIndexBuffer = function(size) {
    var roundedP2 = nextPow2(Math.ceil(size / 12));
    var roundedSizeIndex = log2(roundedP2);
    var roundedSize = roundedP2 * 12;
    if (this._iBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    var buffer2 = this._iBuffers[roundedSizeIndex];
    if (!buffer2) {
      this._iBuffers[roundedSizeIndex] = buffer2 = new Uint16Array(roundedSize);
    }
    return buffer2;
  };
  AbstractBatchRenderer2.prototype.packInterleavedGeometry = function(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
    var uint32View = attributeBuffer.uint32View, float32View = attributeBuffer.float32View;
    var packedVertices = aIndex / this.vertexSize;
    var uvs = element.uvs;
    var indicies = element.indices;
    var vertexData = element.vertexData;
    var textureId = element._texture.baseTexture._batchLocation;
    var alpha = Math.min(element.worldAlpha, 1);
    var argb = alpha < 1 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha) : element._tintRGB + (alpha * 255 << 24);
    for (var i = 0; i < vertexData.length; i += 2) {
      float32View[aIndex++] = vertexData[i];
      float32View[aIndex++] = vertexData[i + 1];
      float32View[aIndex++] = uvs[i];
      float32View[aIndex++] = uvs[i + 1];
      uint32View[aIndex++] = argb;
      float32View[aIndex++] = textureId;
    }
    for (var i = 0; i < indicies.length; i++) {
      indexBuffer[iIndex++] = packedVertices + indicies[i];
    }
  };
  AbstractBatchRenderer2._drawCallPool = [];
  AbstractBatchRenderer2._textureArrayPool = [];
  return AbstractBatchRenderer2;
}(ObjectRenderer);
var BatchShaderGenerator = function() {
  function BatchShaderGenerator2(vertexSrc, fragTemplate2) {
    this.vertexSrc = vertexSrc;
    this.fragTemplate = fragTemplate2;
    this.programCache = {};
    this.defaultGroupCache = {};
    if (fragTemplate2.indexOf("%count%") < 0) {
      throw new Error('Fragment template must contain "%count%".');
    }
    if (fragTemplate2.indexOf("%forloop%") < 0) {
      throw new Error('Fragment template must contain "%forloop%".');
    }
  }
  BatchShaderGenerator2.prototype.generateShader = function(maxTextures) {
    if (!this.programCache[maxTextures]) {
      var sampleValues = new Int32Array(maxTextures);
      for (var i = 0; i < maxTextures; i++) {
        sampleValues[i] = i;
      }
      this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);
      var fragmentSrc = this.fragTemplate;
      fragmentSrc = fragmentSrc.replace(/%count%/gi, "" + maxTextures);
      fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
      this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
    }
    var uniforms = {
      tint: new Float32Array([1, 1, 1, 1]),
      translationMatrix: new Matrix(),
      default: this.defaultGroupCache[maxTextures]
    };
    return new Shader(this.programCache[maxTextures], uniforms);
  };
  BatchShaderGenerator2.prototype.generateSampleSrc = function(maxTextures) {
    var src = "";
    src += "\n";
    src += "\n";
    for (var i = 0; i < maxTextures; i++) {
      if (i > 0) {
        src += "\nelse ";
      }
      if (i < maxTextures - 1) {
        src += "if(vTextureId < " + i + ".5)";
      }
      src += "\n{";
      src += "\n	color = texture2D(uSamplers[" + i + "], vTextureCoord);";
      src += "\n}";
    }
    src += "\n";
    src += "\n";
    return src;
  };
  return BatchShaderGenerator2;
}();
var BatchGeometry = function(_super) {
  __extends$h(BatchGeometry2, _super);
  function BatchGeometry2(_static) {
    if (_static === void 0) {
      _static = false;
    }
    var _this = _super.call(this) || this;
    _this._buffer = new Buffer$1(null, _static, false);
    _this._indexBuffer = new Buffer$1(null, _static, true);
    _this.addAttribute("aVertexPosition", _this._buffer, 2, false, TYPES$3.FLOAT).addAttribute("aTextureCoord", _this._buffer, 2, false, TYPES$3.FLOAT).addAttribute("aColor", _this._buffer, 4, true, TYPES$3.UNSIGNED_BYTE).addAttribute("aTextureId", _this._buffer, 1, true, TYPES$3.FLOAT).addIndex(_this._indexBuffer);
    return _this;
  }
  return BatchGeometry2;
}(Geometry);
var defaultVertex$3 = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";
var defaultFragment$2 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";
var BatchPluginFactory = function() {
  function BatchPluginFactory2() {
  }
  BatchPluginFactory2.create = function(options) {
    var _a2 = Object.assign({
      vertex: defaultVertex$3,
      fragment: defaultFragment$2,
      geometryClass: BatchGeometry,
      vertexSize: 6
    }, options), vertex2 = _a2.vertex, fragment2 = _a2.fragment, vertexSize = _a2.vertexSize, geometryClass = _a2.geometryClass;
    return function(_super) {
      __extends$h(BatchPlugin, _super);
      function BatchPlugin(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.shaderGenerator = new BatchShaderGenerator(vertex2, fragment2);
        _this.geometryClass = geometryClass;
        _this.vertexSize = vertexSize;
        return _this;
      }
      return BatchPlugin;
    }(AbstractBatchRenderer);
  };
  Object.defineProperty(BatchPluginFactory2, "defaultVertexSrc", {
    get: function() {
      return defaultVertex$3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BatchPluginFactory2, "defaultFragmentTemplate", {
    get: function() {
      return defaultFragment$2;
    },
    enumerable: false,
    configurable: true
  });
  return BatchPluginFactory2;
}();
var BatchRenderer = BatchPluginFactory.create();
var resources = {};
var _loop_1 = function(name) {
  Object.defineProperty(resources, name, {
    get: function() {
      deprecation("6.0.0", "PIXI.systems." + name + " has moved to PIXI." + name);
      return _resources[name];
    }
  });
};
for (var name in _resources) {
  _loop_1(name);
}
var systems = {};
var _loop_2 = function(name) {
  Object.defineProperty(systems, name, {
    get: function() {
      deprecation("6.0.0", "PIXI.resources." + name + " has moved to PIXI." + name);
      return _systems[name];
    }
  });
};
for (var name in _systems) {
  _loop_2(name);
}
/*!
 * @pixi/app - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/app is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Application = function() {
  function Application2(options) {
    var _this = this;
    this.stage = new Container();
    options = Object.assign({
      forceCanvas: false
    }, options);
    this.renderer = autoDetectRenderer(options);
    Application2._plugins.forEach(function(plugin) {
      plugin.init.call(_this, options);
    });
  }
  Application2.registerPlugin = function(plugin) {
    Application2._plugins.push(plugin);
  };
  Application2.prototype.render = function() {
    this.renderer.render(this.stage);
  };
  Object.defineProperty(Application2.prototype, "view", {
    get: function() {
      return this.renderer.view;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Application2.prototype, "screen", {
    get: function() {
      return this.renderer.screen;
    },
    enumerable: false,
    configurable: true
  });
  Application2.prototype.destroy = function(removeView, stageOptions) {
    var _this = this;
    var plugins = Application2._plugins.slice(0);
    plugins.reverse();
    plugins.forEach(function(plugin) {
      plugin.destroy.call(_this);
    });
    this.stage.destroy(stageOptions);
    this.stage = null;
    this.renderer.destroy(removeView);
    this.renderer = null;
  };
  Application2._plugins = [];
  return Application2;
}();
var ResizePlugin = function() {
  function ResizePlugin2() {
  }
  ResizePlugin2.init = function(options) {
    var _this = this;
    Object.defineProperty(this, "resizeTo", {
      set: function(dom) {
        self.removeEventListener("resize", this.queueResize);
        this._resizeTo = dom;
        if (dom) {
          self.addEventListener("resize", this.queueResize);
          this.resize();
        }
      },
      get: function() {
        return this._resizeTo;
      }
    });
    this.queueResize = function() {
      if (!_this._resizeTo) {
        return;
      }
      _this.cancelResize();
      _this._resizeId = requestAnimationFrame(function() {
        return _this.resize();
      });
    };
    this.cancelResize = function() {
      if (_this._resizeId) {
        cancelAnimationFrame(_this._resizeId);
        _this._resizeId = null;
      }
    };
    this.resize = function() {
      if (!_this._resizeTo) {
        return;
      }
      _this.cancelResize();
      var width;
      var height;
      if (_this._resizeTo === self) {
        width = self.innerWidth;
        height = self.innerHeight;
      } else {
        var _a2 = _this._resizeTo, clientWidth = _a2.clientWidth, clientHeight = _a2.clientHeight;
        width = clientWidth;
        height = clientHeight;
      }
      _this.renderer.resize(width, height);
    };
    this._resizeId = null;
    this._resizeTo = null;
    this.resizeTo = options.resizeTo || null;
  };
  ResizePlugin2.destroy = function() {
    self.removeEventListener("resize", this.queueResize);
    this.cancelResize();
    this.cancelResize = null;
    this.queueResize = null;
    this.resizeTo = null;
    this.resize = null;
  };
  return ResizePlugin2;
}();
Application.registerPlugin(ResizePlugin);
/*!
 * @pixi/extract - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/extract is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var TEMP_RECT = new Rectangle();
var BYTES_PER_PIXEL = 4;
var Extract = function() {
  function Extract2(renderer) {
    this.renderer = renderer;
  }
  Extract2.prototype.image = function(target, format2, quality) {
    var image2 = new Image();
    image2.src = this.base64(target, format2, quality);
    return image2;
  };
  Extract2.prototype.base64 = function(target, format2, quality) {
    return this.canvas(target).toDataURL(format2, quality);
  };
  Extract2.prototype.canvas = function(target) {
    var renderer = this.renderer;
    var resolution;
    var frame;
    var flipY = false;
    var renderTexture;
    var generated = false;
    if (target) {
      if (target instanceof RenderTexture) {
        renderTexture = target;
      } else {
        renderTexture = this.renderer.generateTexture(target);
        generated = true;
      }
    }
    if (renderTexture) {
      resolution = renderTexture.baseTexture.resolution;
      frame = renderTexture.frame;
      flipY = false;
      renderer.renderTexture.bind(renderTexture);
    } else {
      resolution = this.renderer.resolution;
      flipY = true;
      frame = TEMP_RECT;
      frame.width = this.renderer.width;
      frame.height = this.renderer.height;
      renderer.renderTexture.bind(null);
    }
    var width = Math.floor(frame.width * resolution + 1e-4);
    var height = Math.floor(frame.height * resolution + 1e-4);
    var canvasBuffer = new CanvasRenderTarget(width, height, 1);
    var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    var gl = renderer.gl;
    gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
    var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);
    Extract2.arrayPostDivide(webglPixels, canvasData.data);
    canvasBuffer.context.putImageData(canvasData, 0, 0);
    if (flipY) {
      var target_1 = new CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);
      target_1.context.scale(1, -1);
      target_1.context.drawImage(canvasBuffer.canvas, 0, -height);
      canvasBuffer.destroy();
      canvasBuffer = target_1;
    }
    if (generated) {
      renderTexture.destroy(true);
    }
    return canvasBuffer.canvas;
  };
  Extract2.prototype.pixels = function(target) {
    var renderer = this.renderer;
    var resolution;
    var frame;
    var renderTexture;
    var generated = false;
    if (target) {
      if (target instanceof RenderTexture) {
        renderTexture = target;
      } else {
        renderTexture = this.renderer.generateTexture(target);
        generated = true;
      }
    }
    if (renderTexture) {
      resolution = renderTexture.baseTexture.resolution;
      frame = renderTexture.frame;
      renderer.renderTexture.bind(renderTexture);
    } else {
      resolution = renderer.resolution;
      frame = TEMP_RECT;
      frame.width = renderer.width;
      frame.height = renderer.height;
      renderer.renderTexture.bind(null);
    }
    var width = frame.width * resolution;
    var height = frame.height * resolution;
    var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    var gl = renderer.gl;
    gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
    if (generated) {
      renderTexture.destroy(true);
    }
    Extract2.arrayPostDivide(webglPixels, webglPixels);
    return webglPixels;
  };
  Extract2.prototype.destroy = function() {
    this.renderer = null;
  };
  Extract2.arrayPostDivide = function(pixels, out) {
    for (var i = 0; i < pixels.length; i += 4) {
      var alpha = out[i + 3] = pixels[i + 3];
      if (alpha !== 0) {
        out[i] = Math.round(Math.min(pixels[i] * 255 / alpha, 255));
        out[i + 1] = Math.round(Math.min(pixels[i + 1] * 255 / alpha, 255));
        out[i + 2] = Math.round(Math.min(pixels[i + 2] * 255 / alpha, 255));
      } else {
        out[i] = pixels[i];
        out[i + 1] = pixels[i + 1];
        out[i + 2] = pixels[i + 2];
      }
    }
  };
  return Extract2;
}();
/*!
 * @pixi/loaders - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/loaders is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var SignalBinding = function() {
  function SignalBinding2(fn, once, thisArg) {
    if (once === void 0) {
      once = false;
    }
    this._fn = fn;
    this._once = once;
    this._thisArg = thisArg;
    this._next = this._prev = this._owner = null;
  }
  SignalBinding2.prototype.detach = function() {
    if (this._owner === null) {
      return false;
    }
    this._owner.detach(this);
    return true;
  };
  return SignalBinding2;
}();
function _addSignalBinding(self2, node) {
  if (!self2._head) {
    self2._head = node;
    self2._tail = node;
  } else {
    self2._tail._next = node;
    node._prev = self2._tail;
    self2._tail = node;
  }
  node._owner = self2;
  return node;
}
var Signal = function() {
  function Signal2() {
    this._head = this._tail = void 0;
  }
  Signal2.prototype.handlers = function(exists) {
    if (exists === void 0) {
      exists = false;
    }
    var node = this._head;
    if (exists) {
      return !!node;
    }
    var ee = [];
    while (node) {
      ee.push(node);
      node = node._next;
    }
    return ee;
  };
  Signal2.prototype.has = function(node) {
    if (!(node instanceof SignalBinding)) {
      throw new Error("MiniSignal#has(): First arg must be a SignalBinding object.");
    }
    return node._owner === this;
  };
  Signal2.prototype.dispatch = function() {
    var arguments$1 = arguments;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments$1[_i];
    }
    var node = this._head;
    if (!node) {
      return false;
    }
    while (node) {
      if (node._once) {
        this.detach(node);
      }
      node._fn.apply(node._thisArg, args);
      node = node._next;
    }
    return true;
  };
  Signal2.prototype.add = function(fn, thisArg) {
    if (thisArg === void 0) {
      thisArg = null;
    }
    if (typeof fn !== "function") {
      throw new Error("MiniSignal#add(): First arg must be a Function.");
    }
    return _addSignalBinding(this, new SignalBinding(fn, false, thisArg));
  };
  Signal2.prototype.once = function(fn, thisArg) {
    if (thisArg === void 0) {
      thisArg = null;
    }
    if (typeof fn !== "function") {
      throw new Error("MiniSignal#once(): First arg must be a Function.");
    }
    return _addSignalBinding(this, new SignalBinding(fn, true, thisArg));
  };
  Signal2.prototype.detach = function(node) {
    if (!(node instanceof SignalBinding)) {
      throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object.");
    }
    if (node._owner !== this) {
      return this;
    }
    if (node._prev) {
      node._prev._next = node._next;
    }
    if (node._next) {
      node._next._prev = node._prev;
    }
    if (node === this._head) {
      this._head = node._next;
      if (node._next === null) {
        this._tail = null;
      }
    } else if (node === this._tail) {
      this._tail = node._prev;
      this._tail._next = null;
    }
    node._owner = null;
    return this;
  };
  Signal2.prototype.detachAll = function() {
    var node = this._head;
    if (!node) {
      return this;
    }
    this._head = this._tail = null;
    while (node) {
      node._owner = null;
      node = node._next;
    }
    return this;
  };
  return Signal2;
}();
function parseUri(str, opts) {
  opts = opts || {};
  var o = {
    key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
    q: {
      name: "queryKey",
      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  };
  var m = o.parser[opts.strictMode ? "strict" : "loose"].exec(str);
  var uri = {};
  var i = 14;
  while (i--) {
    uri[o.key[i]] = m[i] || "";
  }
  uri[o.q.name] = {};
  uri[o.key[12]].replace(o.q.parser, function(_t0, t1, t2) {
    if (t1) {
      uri[o.q.name][t1] = t2;
    }
  });
  return uri;
}
var useXdr = !!(self.XDomainRequest && !("withCredentials" in new XMLHttpRequest()));
var tempAnchor = null;
var STATUS_NONE = 0;
var STATUS_OK = 200;
var STATUS_EMPTY = 204;
var STATUS_IE_BUG_EMPTY = 1223;
var STATUS_TYPE_OK = 2;
function _noop() {
}
function setExtMap(map2, extname, val) {
  if (extname && extname.indexOf(".") === 0) {
    extname = extname.substring(1);
  }
  if (!extname) {
    return;
  }
  map2[extname] = val;
}
function reqType(xhr) {
  return xhr.toString().replace("object ", "");
}
var LoaderResource = function() {
  function LoaderResource2(name, url2, options) {
    this._dequeue = _noop;
    this._onLoadBinding = null;
    this._elementTimer = 0;
    this._boundComplete = null;
    this._boundOnError = null;
    this._boundOnProgress = null;
    this._boundOnTimeout = null;
    this._boundXhrOnError = null;
    this._boundXhrOnTimeout = null;
    this._boundXhrOnAbort = null;
    this._boundXhrOnLoad = null;
    if (typeof name !== "string" || typeof url2 !== "string") {
      throw new Error("Both name and url are required for constructing a resource.");
    }
    options = options || {};
    this._flags = 0;
    this._setFlag(LoaderResource2.STATUS_FLAGS.DATA_URL, url2.indexOf("data:") === 0);
    this.name = name;
    this.url = url2;
    this.extension = this._getExtension();
    this.data = null;
    this.crossOrigin = options.crossOrigin === true ? "anonymous" : options.crossOrigin;
    this.timeout = options.timeout || 0;
    this.loadType = options.loadType || this._determineLoadType();
    this.xhrType = options.xhrType;
    this.metadata = options.metadata || {};
    this.error = null;
    this.xhr = null;
    this.children = [];
    this.type = LoaderResource2.TYPE.UNKNOWN;
    this.progressChunk = 0;
    this._dequeue = _noop;
    this._onLoadBinding = null;
    this._elementTimer = 0;
    this._boundComplete = this.complete.bind(this);
    this._boundOnError = this._onError.bind(this);
    this._boundOnProgress = this._onProgress.bind(this);
    this._boundOnTimeout = this._onTimeout.bind(this);
    this._boundXhrOnError = this._xhrOnError.bind(this);
    this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);
    this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
    this._boundXhrOnLoad = this._xhrOnLoad.bind(this);
    this.onStart = new Signal();
    this.onProgress = new Signal();
    this.onComplete = new Signal();
    this.onAfterMiddleware = new Signal();
  }
  LoaderResource2.setExtensionLoadType = function(extname, loadType) {
    setExtMap(LoaderResource2._loadTypeMap, extname, loadType);
  };
  LoaderResource2.setExtensionXhrType = function(extname, xhrType) {
    setExtMap(LoaderResource2._xhrTypeMap, extname, xhrType);
  };
  Object.defineProperty(LoaderResource2.prototype, "isDataUrl", {
    get: function() {
      return this._hasFlag(LoaderResource2.STATUS_FLAGS.DATA_URL);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LoaderResource2.prototype, "isComplete", {
    get: function() {
      return this._hasFlag(LoaderResource2.STATUS_FLAGS.COMPLETE);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LoaderResource2.prototype, "isLoading", {
    get: function() {
      return this._hasFlag(LoaderResource2.STATUS_FLAGS.LOADING);
    },
    enumerable: false,
    configurable: true
  });
  LoaderResource2.prototype.complete = function() {
    this._clearEvents();
    this._finish();
  };
  LoaderResource2.prototype.abort = function(message) {
    if (this.error) {
      return;
    }
    this.error = new Error(message);
    this._clearEvents();
    if (this.xhr) {
      this.xhr.abort();
    } else if (this.xdr) {
      this.xdr.abort();
    } else if (this.data) {
      if (this.data.src) {
        this.data.src = LoaderResource2.EMPTY_GIF;
      } else {
        while (this.data.firstChild) {
          this.data.removeChild(this.data.firstChild);
        }
      }
    }
    this._finish();
  };
  LoaderResource2.prototype.load = function(cb) {
    var _this = this;
    if (this.isLoading) {
      return;
    }
    if (this.isComplete) {
      if (cb) {
        setTimeout(function() {
          return cb(_this);
        }, 1);
      }
      return;
    } else if (cb) {
      this.onComplete.once(cb);
    }
    this._setFlag(LoaderResource2.STATUS_FLAGS.LOADING, true);
    this.onStart.dispatch(this);
    if (this.crossOrigin === false || typeof this.crossOrigin !== "string") {
      this.crossOrigin = this._determineCrossOrigin(this.url);
    }
    switch (this.loadType) {
      case LoaderResource2.LOAD_TYPE.IMAGE:
        this.type = LoaderResource2.TYPE.IMAGE;
        this._loadElement("image");
        break;
      case LoaderResource2.LOAD_TYPE.AUDIO:
        this.type = LoaderResource2.TYPE.AUDIO;
        this._loadSourceElement("audio");
        break;
      case LoaderResource2.LOAD_TYPE.VIDEO:
        this.type = LoaderResource2.TYPE.VIDEO;
        this._loadSourceElement("video");
        break;
      case LoaderResource2.LOAD_TYPE.XHR:
      default:
        if (useXdr && this.crossOrigin) {
          this._loadXdr();
        } else {
          this._loadXhr();
        }
        break;
    }
  };
  LoaderResource2.prototype._hasFlag = function(flag) {
    return (this._flags & flag) !== 0;
  };
  LoaderResource2.prototype._setFlag = function(flag, value) {
    this._flags = value ? this._flags | flag : this._flags & ~flag;
  };
  LoaderResource2.prototype._clearEvents = function() {
    clearTimeout(this._elementTimer);
    if (this.data && this.data.removeEventListener) {
      this.data.removeEventListener("error", this._boundOnError, false);
      this.data.removeEventListener("load", this._boundComplete, false);
      this.data.removeEventListener("progress", this._boundOnProgress, false);
      this.data.removeEventListener("canplaythrough", this._boundComplete, false);
    }
    if (this.xhr) {
      if (this.xhr.removeEventListener) {
        this.xhr.removeEventListener("error", this._boundXhrOnError, false);
        this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, false);
        this.xhr.removeEventListener("abort", this._boundXhrOnAbort, false);
        this.xhr.removeEventListener("progress", this._boundOnProgress, false);
        this.xhr.removeEventListener("load", this._boundXhrOnLoad, false);
      } else {
        this.xhr.onerror = null;
        this.xhr.ontimeout = null;
        this.xhr.onprogress = null;
        this.xhr.onload = null;
      }
    }
  };
  LoaderResource2.prototype._finish = function() {
    if (this.isComplete) {
      throw new Error("Complete called again for an already completed resource.");
    }
    this._setFlag(LoaderResource2.STATUS_FLAGS.COMPLETE, true);
    this._setFlag(LoaderResource2.STATUS_FLAGS.LOADING, false);
    this.onComplete.dispatch(this);
  };
  LoaderResource2.prototype._loadElement = function(type) {
    if (this.metadata.loadElement) {
      this.data = this.metadata.loadElement;
    } else if (type === "image" && typeof self.Image !== "undefined") {
      this.data = new Image();
    } else {
      this.data = document.createElement(type);
    }
    if (this.crossOrigin) {
      this.data.crossOrigin = this.crossOrigin;
    }
    if (!this.metadata.skipSource) {
      this.data.src = this.url;
    }
    this.data.addEventListener("error", this._boundOnError, false);
    this.data.addEventListener("load", this._boundComplete, false);
    this.data.addEventListener("progress", this._boundOnProgress, false);
    if (this.timeout) {
      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
    }
  };
  LoaderResource2.prototype._loadSourceElement = function(type) {
    if (this.metadata.loadElement) {
      this.data = this.metadata.loadElement;
    } else if (type === "audio" && typeof self.Audio !== "undefined") {
      this.data = new Audio();
    } else {
      this.data = document.createElement(type);
    }
    if (this.data === null) {
      this.abort("Unsupported element: " + type);
      return;
    }
    if (this.crossOrigin) {
      this.data.crossOrigin = this.crossOrigin;
    }
    if (!this.metadata.skipSource) {
      if (navigator.isCocoonJS) {
        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
      } else if (Array.isArray(this.url)) {
        var mimeTypes = this.metadata.mimeType;
        for (var i = 0; i < this.url.length; ++i) {
          this.data.appendChild(this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));
        }
      } else {
        var mimeTypes = this.metadata.mimeType;
        this.data.appendChild(this._createSource(type, this.url, Array.isArray(mimeTypes) ? mimeTypes[0] : mimeTypes));
      }
    }
    this.data.addEventListener("error", this._boundOnError, false);
    this.data.addEventListener("load", this._boundComplete, false);
    this.data.addEventListener("progress", this._boundOnProgress, false);
    this.data.addEventListener("canplaythrough", this._boundComplete, false);
    this.data.load();
    if (this.timeout) {
      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
    }
  };
  LoaderResource2.prototype._loadXhr = function() {
    if (typeof this.xhrType !== "string") {
      this.xhrType = this._determineXhrType();
    }
    var xhr = this.xhr = new XMLHttpRequest();
    xhr.open("GET", this.url, true);
    xhr.timeout = this.timeout;
    if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.JSON || this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT) {
      xhr.responseType = LoaderResource2.XHR_RESPONSE_TYPE.TEXT;
    } else {
      xhr.responseType = this.xhrType;
    }
    xhr.addEventListener("error", this._boundXhrOnError, false);
    xhr.addEventListener("timeout", this._boundXhrOnTimeout, false);
    xhr.addEventListener("abort", this._boundXhrOnAbort, false);
    xhr.addEventListener("progress", this._boundOnProgress, false);
    xhr.addEventListener("load", this._boundXhrOnLoad, false);
    xhr.send();
  };
  LoaderResource2.prototype._loadXdr = function() {
    if (typeof this.xhrType !== "string") {
      this.xhrType = this._determineXhrType();
    }
    var xdr = this.xhr = new self.XDomainRequest();
    xdr.timeout = this.timeout || 5e3;
    xdr.onerror = this._boundXhrOnError;
    xdr.ontimeout = this._boundXhrOnTimeout;
    xdr.onprogress = this._boundOnProgress;
    xdr.onload = this._boundXhrOnLoad;
    xdr.open("GET", this.url, true);
    setTimeout(function() {
      return xdr.send();
    }, 1);
  };
  LoaderResource2.prototype._createSource = function(type, url2, mime) {
    if (!mime) {
      mime = type + "/" + this._getExtension(url2);
    }
    var source = document.createElement("source");
    source.src = url2;
    source.type = mime;
    return source;
  };
  LoaderResource2.prototype._onError = function(event) {
    this.abort("Failed to load element using: " + event.target.nodeName);
  };
  LoaderResource2.prototype._onProgress = function(event) {
    if (event && event.lengthComputable) {
      this.onProgress.dispatch(this, event.loaded / event.total);
    }
  };
  LoaderResource2.prototype._onTimeout = function() {
    this.abort("Load timed out.");
  };
  LoaderResource2.prototype._xhrOnError = function() {
    var xhr = this.xhr;
    this.abort(reqType(xhr) + " Request failed. Status: " + xhr.status + ', text: "' + xhr.statusText + '"');
  };
  LoaderResource2.prototype._xhrOnTimeout = function() {
    var xhr = this.xhr;
    this.abort(reqType(xhr) + " Request timed out.");
  };
  LoaderResource2.prototype._xhrOnAbort = function() {
    var xhr = this.xhr;
    this.abort(reqType(xhr) + " Request was aborted by the user.");
  };
  LoaderResource2.prototype._xhrOnLoad = function() {
    var xhr = this.xhr;
    var text = "";
    var status = typeof xhr.status === "undefined" ? STATUS_OK : xhr.status;
    if (xhr.responseType === "" || xhr.responseType === "text" || typeof xhr.responseType === "undefined") {
      text = xhr.responseText;
    }
    if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === LoaderResource2.XHR_RESPONSE_TYPE.BUFFER)) {
      status = STATUS_OK;
    } else if (status === STATUS_IE_BUG_EMPTY) {
      status = STATUS_EMPTY;
    }
    var statusType = status / 100 | 0;
    if (statusType === STATUS_TYPE_OK) {
      if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.TEXT) {
        this.data = text;
        this.type = LoaderResource2.TYPE.TEXT;
      } else if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.JSON) {
        try {
          this.data = JSON.parse(text);
          this.type = LoaderResource2.TYPE.JSON;
        } catch (e2) {
          this.abort("Error trying to parse loaded json: " + e2);
          return;
        }
      } else if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT) {
        try {
          if (self.DOMParser) {
            var domparser = new DOMParser();
            this.data = domparser.parseFromString(text, "text/xml");
          } else {
            var div = document.createElement("div");
            div.innerHTML = text;
            this.data = div;
          }
          this.type = LoaderResource2.TYPE.XML;
        } catch (e$1) {
          this.abort("Error trying to parse loaded xml: " + e$1);
          return;
        }
      } else {
        this.data = xhr.response || text;
      }
    } else {
      this.abort("[" + xhr.status + "] " + xhr.statusText + ": " + xhr.responseURL);
      return;
    }
    this.complete();
  };
  LoaderResource2.prototype._determineCrossOrigin = function(url2, loc) {
    if (url2.indexOf("data:") === 0) {
      return "";
    }
    if (self.origin !== self.location.origin) {
      return "anonymous";
    }
    loc = loc || self.location;
    if (!tempAnchor) {
      tempAnchor = document.createElement("a");
    }
    tempAnchor.href = url2;
    var parsedUrl = parseUri(tempAnchor.href, { strictMode: true });
    var samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
    var protocol = parsedUrl.protocol ? parsedUrl.protocol + ":" : "";
    if (parsedUrl.host !== loc.hostname || !samePort || protocol !== loc.protocol) {
      return "anonymous";
    }
    return "";
  };
  LoaderResource2.prototype._determineXhrType = function() {
    return LoaderResource2._xhrTypeMap[this.extension] || LoaderResource2.XHR_RESPONSE_TYPE.TEXT;
  };
  LoaderResource2.prototype._determineLoadType = function() {
    return LoaderResource2._loadTypeMap[this.extension] || LoaderResource2.LOAD_TYPE.XHR;
  };
  LoaderResource2.prototype._getExtension = function(url2) {
    if (url2 === void 0) {
      url2 = this.url;
    }
    var ext = "";
    if (this.isDataUrl) {
      var slashIndex = url2.indexOf("/");
      ext = url2.substring(slashIndex + 1, url2.indexOf(";", slashIndex));
    } else {
      var queryStart = url2.indexOf("?");
      var hashStart = url2.indexOf("#");
      var index2 = Math.min(queryStart > -1 ? queryStart : url2.length, hashStart > -1 ? hashStart : url2.length);
      url2 = url2.substring(0, index2);
      ext = url2.substring(url2.lastIndexOf(".") + 1);
    }
    return ext.toLowerCase();
  };
  LoaderResource2.prototype._getMimeFromXhrType = function(type) {
    switch (type) {
      case LoaderResource2.XHR_RESPONSE_TYPE.BUFFER:
        return "application/octet-binary";
      case LoaderResource2.XHR_RESPONSE_TYPE.BLOB:
        return "application/blob";
      case LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT:
        return "application/xml";
      case LoaderResource2.XHR_RESPONSE_TYPE.JSON:
        return "application/json";
      case LoaderResource2.XHR_RESPONSE_TYPE.DEFAULT:
      case LoaderResource2.XHR_RESPONSE_TYPE.TEXT:
      default:
        return "text/plain";
    }
  };
  return LoaderResource2;
}();
(function(LoaderResource2) {
  (function(STATUS_FLAGS) {
    STATUS_FLAGS[STATUS_FLAGS["NONE"] = 0] = "NONE";
    STATUS_FLAGS[STATUS_FLAGS["DATA_URL"] = 1] = "DATA_URL";
    STATUS_FLAGS[STATUS_FLAGS["COMPLETE"] = 2] = "COMPLETE";
    STATUS_FLAGS[STATUS_FLAGS["LOADING"] = 4] = "LOADING";
  })(LoaderResource2.STATUS_FLAGS || (LoaderResource2.STATUS_FLAGS = {}));
  (function(TYPE) {
    TYPE[TYPE["UNKNOWN"] = 0] = "UNKNOWN";
    TYPE[TYPE["JSON"] = 1] = "JSON";
    TYPE[TYPE["XML"] = 2] = "XML";
    TYPE[TYPE["IMAGE"] = 3] = "IMAGE";
    TYPE[TYPE["AUDIO"] = 4] = "AUDIO";
    TYPE[TYPE["VIDEO"] = 5] = "VIDEO";
    TYPE[TYPE["TEXT"] = 6] = "TEXT";
  })(LoaderResource2.TYPE || (LoaderResource2.TYPE = {}));
  (function(LOAD_TYPE) {
    LOAD_TYPE[LOAD_TYPE["XHR"] = 1] = "XHR";
    LOAD_TYPE[LOAD_TYPE["IMAGE"] = 2] = "IMAGE";
    LOAD_TYPE[LOAD_TYPE["AUDIO"] = 3] = "AUDIO";
    LOAD_TYPE[LOAD_TYPE["VIDEO"] = 4] = "VIDEO";
  })(LoaderResource2.LOAD_TYPE || (LoaderResource2.LOAD_TYPE = {}));
  (function(XHR_RESPONSE_TYPE) {
    XHR_RESPONSE_TYPE["DEFAULT"] = "text";
    XHR_RESPONSE_TYPE["BUFFER"] = "arraybuffer";
    XHR_RESPONSE_TYPE["BLOB"] = "blob";
    XHR_RESPONSE_TYPE["DOCUMENT"] = "document";
    XHR_RESPONSE_TYPE["JSON"] = "json";
    XHR_RESPONSE_TYPE["TEXT"] = "text";
  })(LoaderResource2.XHR_RESPONSE_TYPE || (LoaderResource2.XHR_RESPONSE_TYPE = {}));
  LoaderResource2._loadTypeMap = {
    gif: LoaderResource2.LOAD_TYPE.IMAGE,
    png: LoaderResource2.LOAD_TYPE.IMAGE,
    bmp: LoaderResource2.LOAD_TYPE.IMAGE,
    jpg: LoaderResource2.LOAD_TYPE.IMAGE,
    jpeg: LoaderResource2.LOAD_TYPE.IMAGE,
    tif: LoaderResource2.LOAD_TYPE.IMAGE,
    tiff: LoaderResource2.LOAD_TYPE.IMAGE,
    webp: LoaderResource2.LOAD_TYPE.IMAGE,
    tga: LoaderResource2.LOAD_TYPE.IMAGE,
    svg: LoaderResource2.LOAD_TYPE.IMAGE,
    "svg+xml": LoaderResource2.LOAD_TYPE.IMAGE,
    mp3: LoaderResource2.LOAD_TYPE.AUDIO,
    ogg: LoaderResource2.LOAD_TYPE.AUDIO,
    wav: LoaderResource2.LOAD_TYPE.AUDIO,
    mp4: LoaderResource2.LOAD_TYPE.VIDEO,
    webm: LoaderResource2.LOAD_TYPE.VIDEO
  };
  LoaderResource2._xhrTypeMap = {
    xhtml: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    html: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    htm: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    xml: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    tmx: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    svg: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    tsx: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    gif: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    png: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    bmp: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    jpg: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    jpeg: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    tif: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    tiff: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    webp: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    tga: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    json: LoaderResource2.XHR_RESPONSE_TYPE.JSON,
    text: LoaderResource2.XHR_RESPONSE_TYPE.TEXT,
    txt: LoaderResource2.XHR_RESPONSE_TYPE.TEXT,
    ttf: LoaderResource2.XHR_RESPONSE_TYPE.BUFFER,
    otf: LoaderResource2.XHR_RESPONSE_TYPE.BUFFER
  };
  LoaderResource2.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
})(LoaderResource || (LoaderResource = {}));
function _noop$1() {
}
function onlyOnce(fn) {
  return function onceWrapper() {
    var arguments$1 = arguments;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments$1[_i];
    }
    if (fn === null) {
      throw new Error("Callback was already called.");
    }
    var callFn = fn;
    fn = null;
    callFn.apply(this, args);
  };
}
var AsyncQueueItem = function() {
  function AsyncQueueItem2(data, callback) {
    this.data = data;
    this.callback = callback;
  }
  return AsyncQueueItem2;
}();
var AsyncQueue = function() {
  function AsyncQueue2(worker, concurrency) {
    var _this = this;
    if (concurrency === void 0) {
      concurrency = 1;
    }
    this.workers = 0;
    this.saturated = _noop$1;
    this.unsaturated = _noop$1;
    this.empty = _noop$1;
    this.drain = _noop$1;
    this.error = _noop$1;
    this.started = false;
    this.paused = false;
    this._tasks = [];
    this._insert = function(data, insertAtFront, callback) {
      if (callback && typeof callback !== "function") {
        throw new Error("task callback must be a function");
      }
      _this.started = true;
      if (data == null && _this.idle()) {
        setTimeout(function() {
          return _this.drain();
        }, 1);
        return;
      }
      var item = new AsyncQueueItem(data, typeof callback === "function" ? callback : _noop$1);
      if (insertAtFront) {
        _this._tasks.unshift(item);
      } else {
        _this._tasks.push(item);
      }
      setTimeout(_this.process, 1);
    };
    this.process = function() {
      while (!_this.paused && _this.workers < _this.concurrency && _this._tasks.length) {
        var task = _this._tasks.shift();
        if (_this._tasks.length === 0) {
          _this.empty();
        }
        _this.workers += 1;
        if (_this.workers === _this.concurrency) {
          _this.saturated();
        }
        _this._worker(task.data, onlyOnce(_this._next(task)));
      }
    };
    this._worker = worker;
    if (concurrency === 0) {
      throw new Error("Concurrency must not be zero");
    }
    this.concurrency = concurrency;
    this.buffer = concurrency / 4;
  }
  AsyncQueue2.prototype._next = function(task) {
    var _this = this;
    return function() {
      var arguments$1 = arguments;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments$1[_i];
      }
      _this.workers -= 1;
      task.callback.apply(task, args);
      if (args[0] != null) {
        _this.error(args[0], task.data);
      }
      if (_this.workers <= _this.concurrency - _this.buffer) {
        _this.unsaturated();
      }
      if (_this.idle()) {
        _this.drain();
      }
      _this.process();
    };
  };
  AsyncQueue2.prototype.push = function(data, callback) {
    this._insert(data, false, callback);
  };
  AsyncQueue2.prototype.kill = function() {
    this.workers = 0;
    this.drain = _noop$1;
    this.started = false;
    this._tasks = [];
  };
  AsyncQueue2.prototype.unshift = function(data, callback) {
    this._insert(data, true, callback);
  };
  AsyncQueue2.prototype.length = function() {
    return this._tasks.length;
  };
  AsyncQueue2.prototype.running = function() {
    return this.workers;
  };
  AsyncQueue2.prototype.idle = function() {
    return this._tasks.length + this.workers === 0;
  };
  AsyncQueue2.prototype.pause = function() {
    if (this.paused === true) {
      return;
    }
    this.paused = true;
  };
  AsyncQueue2.prototype.resume = function() {
    if (this.paused === false) {
      return;
    }
    this.paused = false;
    for (var w = 1; w <= this.concurrency; w++) {
      this.process();
    }
  };
  AsyncQueue2.eachSeries = function(array, iterator, callback, deferNext) {
    var i = 0;
    var len = array.length;
    function next(err) {
      if (err || i === len) {
        if (callback) {
          callback(err);
        }
        return;
      }
      if (deferNext) {
        setTimeout(function() {
          iterator(array[i++], next);
        }, 1);
      } else {
        iterator(array[i++], next);
      }
    }
    next();
  };
  AsyncQueue2.queue = function(worker, concurrency) {
    return new AsyncQueue2(worker, concurrency);
  };
  return AsyncQueue2;
}();
var MAX_PROGRESS = 100;
var rgxExtractUrlHash = /(#[\w-]+)?$/;
var Loader = function() {
  function Loader2(baseUrl, concurrency) {
    var _this = this;
    if (baseUrl === void 0) {
      baseUrl = "";
    }
    if (concurrency === void 0) {
      concurrency = 10;
    }
    this.progress = 0;
    this.loading = false;
    this.defaultQueryString = "";
    this._beforeMiddleware = [];
    this._afterMiddleware = [];
    this._resourcesParsing = [];
    this._boundLoadResource = function(r, d) {
      return _this._loadResource(r, d);
    };
    this.resources = {};
    this.baseUrl = baseUrl;
    this._beforeMiddleware = [];
    this._afterMiddleware = [];
    this._resourcesParsing = [];
    this._boundLoadResource = function(r, d) {
      return _this._loadResource(r, d);
    };
    this._queue = AsyncQueue.queue(this._boundLoadResource, concurrency);
    this._queue.pause();
    this.resources = {};
    this.onProgress = new Signal();
    this.onError = new Signal();
    this.onLoad = new Signal();
    this.onStart = new Signal();
    this.onComplete = new Signal();
    for (var i = 0; i < Loader2._plugins.length; ++i) {
      var plugin = Loader2._plugins[i];
      var pre = plugin.pre, use = plugin.use;
      if (pre) {
        this.pre(pre);
      }
      if (use) {
        this.use(use);
      }
    }
    this._protected = false;
  }
  Loader2.prototype._add = function(name, url2, options, callback) {
    if (this.loading && (!options || !options.parentResource)) {
      throw new Error("Cannot add resources while the loader is running.");
    }
    if (this.resources[name]) {
      throw new Error('Resource named "' + name + '" already exists.');
    }
    url2 = this._prepareUrl(url2);
    this.resources[name] = new LoaderResource(name, url2, options);
    if (typeof callback === "function") {
      this.resources[name].onAfterMiddleware.once(callback);
    }
    if (this.loading) {
      var parent = options.parentResource;
      var incompleteChildren = [];
      for (var i = 0; i < parent.children.length; ++i) {
        if (!parent.children[i].isComplete) {
          incompleteChildren.push(parent.children[i]);
        }
      }
      var fullChunk = parent.progressChunk * (incompleteChildren.length + 1);
      var eachChunk = fullChunk / (incompleteChildren.length + 2);
      parent.children.push(this.resources[name]);
      parent.progressChunk = eachChunk;
      for (var i = 0; i < incompleteChildren.length; ++i) {
        incompleteChildren[i].progressChunk = eachChunk;
      }
      this.resources[name].progressChunk = eachChunk;
    }
    this._queue.push(this.resources[name]);
    return this;
  };
  Loader2.prototype.pre = function(fn) {
    this._beforeMiddleware.push(fn);
    return this;
  };
  Loader2.prototype.use = function(fn) {
    this._afterMiddleware.push(fn);
    return this;
  };
  Loader2.prototype.reset = function() {
    this.progress = 0;
    this.loading = false;
    this._queue.kill();
    this._queue.pause();
    for (var k in this.resources) {
      var res = this.resources[k];
      if (res._onLoadBinding) {
        res._onLoadBinding.detach();
      }
      if (res.isLoading) {
        res.abort("loader reset");
      }
    }
    this.resources = {};
    return this;
  };
  Loader2.prototype.load = function(cb) {
    if (typeof cb === "function") {
      this.onComplete.once(cb);
    }
    if (this.loading) {
      return this;
    }
    if (this._queue.idle()) {
      this._onStart();
      this._onComplete();
    } else {
      var numTasks = this._queue._tasks.length;
      var chunk = MAX_PROGRESS / numTasks;
      for (var i = 0; i < this._queue._tasks.length; ++i) {
        this._queue._tasks[i].data.progressChunk = chunk;
      }
      this._onStart();
      this._queue.resume();
    }
    return this;
  };
  Object.defineProperty(Loader2.prototype, "concurrency", {
    get: function() {
      return this._queue.concurrency;
    },
    set: function(concurrency) {
      this._queue.concurrency = concurrency;
    },
    enumerable: false,
    configurable: true
  });
  Loader2.prototype._prepareUrl = function(url2) {
    var parsedUrl = parseUri(url2, { strictMode: true });
    var result;
    if (parsedUrl.protocol || !parsedUrl.path || url2.indexOf("//") === 0) {
      result = url2;
    } else if (this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && url2.charAt(0) !== "/") {
      result = this.baseUrl + "/" + url2;
    } else {
      result = this.baseUrl + url2;
    }
    if (this.defaultQueryString) {
      var hash2 = rgxExtractUrlHash.exec(result)[0];
      result = result.substr(0, result.length - hash2.length);
      if (result.indexOf("?") !== -1) {
        result += "&" + this.defaultQueryString;
      } else {
        result += "?" + this.defaultQueryString;
      }
      result += hash2;
    }
    return result;
  };
  Loader2.prototype._loadResource = function(resource, dequeue) {
    var _this = this;
    resource._dequeue = dequeue;
    AsyncQueue.eachSeries(this._beforeMiddleware, function(fn, next) {
      fn.call(_this, resource, function() {
        next(resource.isComplete ? {} : null);
      });
    }, function() {
      if (resource.isComplete) {
        _this._onLoad(resource);
      } else {
        resource._onLoadBinding = resource.onComplete.once(_this._onLoad, _this);
        resource.load();
      }
    }, true);
  };
  Loader2.prototype._onStart = function() {
    this.progress = 0;
    this.loading = true;
    this.onStart.dispatch(this);
  };
  Loader2.prototype._onComplete = function() {
    this.progress = MAX_PROGRESS;
    this.loading = false;
    this.onComplete.dispatch(this, this.resources);
  };
  Loader2.prototype._onLoad = function(resource) {
    var _this = this;
    resource._onLoadBinding = null;
    this._resourcesParsing.push(resource);
    resource._dequeue();
    AsyncQueue.eachSeries(this._afterMiddleware, function(fn, next) {
      fn.call(_this, resource, next);
    }, function() {
      resource.onAfterMiddleware.dispatch(resource);
      _this.progress = Math.min(MAX_PROGRESS, _this.progress + resource.progressChunk);
      _this.onProgress.dispatch(_this, resource);
      if (resource.error) {
        _this.onError.dispatch(resource.error, _this, resource);
      } else {
        _this.onLoad.dispatch(_this, resource);
      }
      _this._resourcesParsing.splice(_this._resourcesParsing.indexOf(resource), 1);
      if (_this._queue.idle() && _this._resourcesParsing.length === 0) {
        _this._onComplete();
      }
    }, true);
  };
  Loader2.prototype.destroy = function() {
    if (!this._protected) {
      this.reset();
    }
  };
  Object.defineProperty(Loader2, "shared", {
    get: function() {
      var shared = Loader2._shared;
      if (!shared) {
        shared = new Loader2();
        shared._protected = true;
        Loader2._shared = shared;
      }
      return shared;
    },
    enumerable: false,
    configurable: true
  });
  Loader2.registerPlugin = function(plugin) {
    Loader2._plugins.push(plugin);
    if (plugin.add) {
      plugin.add();
    }
    return Loader2;
  };
  Loader2._plugins = [];
  return Loader2;
}();
Loader.prototype.add = function add(name, url2, options, callback) {
  if (Array.isArray(name)) {
    for (var i = 0; i < name.length; ++i) {
      this.add(name[i]);
    }
    return this;
  }
  if (typeof name === "object") {
    options = name;
    callback = url2 || options.callback || options.onComplete;
    url2 = options.url;
    name = options.name || options.key || options.url;
  }
  if (typeof url2 !== "string") {
    callback = options;
    options = url2;
    url2 = name;
  }
  if (typeof url2 !== "string") {
    throw new Error("No url passed to add resource to loader.");
  }
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  return this._add(name, url2, options, callback);
};
var AppLoaderPlugin = function() {
  function AppLoaderPlugin2() {
  }
  AppLoaderPlugin2.init = function(options) {
    options = Object.assign({
      sharedLoader: false
    }, options);
    this.loader = options.sharedLoader ? Loader.shared : new Loader();
  };
  AppLoaderPlugin2.destroy = function() {
    if (this.loader) {
      this.loader.destroy();
      this.loader = null;
    }
  };
  return AppLoaderPlugin2;
}();
var TextureLoader = function() {
  function TextureLoader2() {
  }
  TextureLoader2.add = function() {
    LoaderResource.setExtensionLoadType("svg", LoaderResource.LOAD_TYPE.XHR);
    LoaderResource.setExtensionXhrType("svg", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
  };
  TextureLoader2.use = function(resource, next) {
    if (resource.data && (resource.type === LoaderResource.TYPE.IMAGE || resource.extension === "svg")) {
      var data = resource.data, url2 = resource.url, name = resource.name, metadata = resource.metadata;
      Texture.fromLoader(data, url2, name, metadata).then(function(texture) {
        resource.texture = texture;
        next();
      }).catch(next);
    } else {
      next();
    }
  };
  return TextureLoader2;
}();
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function encodeBinary(input) {
  var output = "";
  var inx = 0;
  while (inx < input.length) {
    var bytebuffer = [0, 0, 0];
    var encodedCharIndexes = [0, 0, 0, 0];
    for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {
      if (inx < input.length) {
        bytebuffer[jnx] = input.charCodeAt(inx++) & 255;
      } else {
        bytebuffer[jnx] = 0;
      }
    }
    encodedCharIndexes[0] = bytebuffer[0] >> 2;
    encodedCharIndexes[1] = (bytebuffer[0] & 3) << 4 | bytebuffer[1] >> 4;
    encodedCharIndexes[2] = (bytebuffer[1] & 15) << 2 | bytebuffer[2] >> 6;
    encodedCharIndexes[3] = bytebuffer[2] & 63;
    var paddingBytes = inx - (input.length - 1);
    switch (paddingBytes) {
      case 2:
        encodedCharIndexes[3] = 64;
        encodedCharIndexes[2] = 64;
        break;
      case 1:
        encodedCharIndexes[3] = 64;
        break;
    }
    for (var jnx = 0; jnx < encodedCharIndexes.length; ++jnx) {
      output += _keyStr.charAt(encodedCharIndexes[jnx]);
    }
  }
  return output;
}
var Url = self.URL || self.webkitURL;
function parsing(resource, next) {
  if (!resource.data) {
    next();
    return;
  }
  if (resource.xhr && resource.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB) {
    if (!self.Blob || typeof resource.data === "string") {
      var type = resource.xhr.getResponseHeader("content-type");
      if (type && type.indexOf("image") === 0) {
        resource.data = new Image();
        resource.data.src = "data:" + type + ";base64," + encodeBinary(resource.xhr.responseText);
        resource.type = LoaderResource.TYPE.IMAGE;
        resource.data.onload = function() {
          resource.data.onload = null;
          next();
        };
        return;
      }
    } else if (resource.data.type.indexOf("image") === 0) {
      var src_1 = Url.createObjectURL(resource.data);
      resource.blob = resource.data;
      resource.data = new Image();
      resource.data.src = src_1;
      resource.type = LoaderResource.TYPE.IMAGE;
      resource.data.onload = function() {
        Url.revokeObjectURL(src_1);
        resource.data.onload = null;
        next();
      };
      return;
    }
  }
  next();
}
Loader.registerPlugin({ use: parsing });
Loader.registerPlugin(TextureLoader);
/*!
 * @pixi/compressed-textures - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/compressed-textures is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var _a$1;
var INTERNAL_FORMATS;
(function(INTERNAL_FORMATS2) {
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
})(INTERNAL_FORMATS || (INTERNAL_FORMATS = {}));
var INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = (_a$1 = {}, _a$1[INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, _a$1[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, _a$1[INTERNAL_FORMATS.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, _a$1[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, _a$1[INTERNAL_FORMATS.COMPRESSED_R11_EAC] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_SIGNED_R11_EAC] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_RG11_EAC] = 1, _a$1[INTERNAL_FORMATS.COMPRESSED_SIGNED_RG11_EAC] = 1, _a$1[INTERNAL_FORMATS.COMPRESSED_RGB8_ETC2] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_RGBA8_ETC2_EAC] = 1, _a$1[INTERNAL_FORMATS.COMPRESSED_SRGB8_ETC2] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, _a$1[INTERNAL_FORMATS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, _a$1[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, _a$1[INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, _a$1[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, _a$1);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$g = function(d, b) {
  extendStatics$g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$g(d, b);
};
function __extends$g(d, b) {
  extendStatics$g(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject2(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject2(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : new P(function(resolve3) {
        resolve3(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) {
      throw t[1];
    }
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) {
      throw new TypeError("Generator is already executing.");
    }
    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) {
          return t;
        }
        if (y = 0, t) {
          op = [op[0] & 2, t.value];
        }
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) {
              _.ops.pop();
            }
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y = 0;
      } finally {
        f = t = 0;
      }
    }
    if (op[0] & 5) {
      throw op[1];
    }
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var BlobResource = function(_super) {
  __extends$g(BlobResource2, _super);
  function BlobResource2(source, options) {
    if (options === void 0) {
      options = { width: 1, height: 1, autoLoad: true };
    }
    var _this = this;
    var origin;
    var data;
    if (typeof source === "string") {
      origin = source;
      data = new Uint8Array();
    } else {
      origin = null;
      data = source;
    }
    _this = _super.call(this, data, options) || this;
    _this.origin = origin;
    _this.buffer = data ? new ViewableBuffer(data) : null;
    if (_this.origin && options.autoLoad !== false) {
      _this.load();
    }
    if (data && data.length) {
      _this.loaded = true;
      _this.onBlobLoaded(_this.buffer.rawBinaryData);
    }
    return _this;
  }
  BlobResource2.prototype.onBlobLoaded = function(_data) {
  };
  BlobResource2.prototype.load = function() {
    return __awaiter(this, void 0, Promise, function() {
      var response, blob, arrayBuffer;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, fetch(this.origin)];
          case 1:
            response = _a2.sent();
            return [4, response.blob()];
          case 2:
            blob = _a2.sent();
            return [4, blob.arrayBuffer()];
          case 3:
            arrayBuffer = _a2.sent();
            this.data = new Uint32Array(arrayBuffer);
            this.buffer = new ViewableBuffer(arrayBuffer);
            this.loaded = true;
            this.onBlobLoaded(arrayBuffer);
            this.update();
            return [2, this];
        }
      });
    });
  };
  return BlobResource2;
}(BufferResource);
var CompressedTextureResource = function(_super) {
  __extends$g(CompressedTextureResource2, _super);
  function CompressedTextureResource2(source, options) {
    var _this = _super.call(this, source, options) || this;
    _this.format = options.format;
    _this.levels = options.levels || 1;
    _this._width = options.width;
    _this._height = options.height;
    _this._extension = CompressedTextureResource2._formatToExtension(_this.format);
    if (options.levelBuffers || _this.buffer) {
      _this._levelBuffers = options.levelBuffers || CompressedTextureResource2._createLevelBuffers(source instanceof Uint8Array ? source : _this.buffer.uint8View, _this.format, _this.levels, 4, 4, _this.width, _this.height);
    }
    return _this;
  }
  CompressedTextureResource2.prototype.upload = function(renderer, _texture, _glTexture) {
    var gl = renderer.gl;
    var extension = renderer.context.extensions[this._extension];
    if (!extension) {
      throw new Error(this._extension + " textures are not supported on the current machine");
    }
    if (!this._levelBuffers) {
      return false;
    }
    for (var i = 0, j = this.levels; i < j; i++) {
      var _a2 = this._levelBuffers[i], levelID = _a2.levelID, levelWidth = _a2.levelWidth, levelHeight = _a2.levelHeight, levelBuffer = _a2.levelBuffer;
      gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
    }
    return true;
  };
  CompressedTextureResource2.prototype.onBlobLoaded = function() {
    this._levelBuffers = CompressedTextureResource2._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
  };
  CompressedTextureResource2._formatToExtension = function(format2) {
    if (format2 >= 33776 && format2 <= 33779) {
      return "s3tc";
    } else if (format2 >= 37488 && format2 <= 37497) {
      return "etc";
    } else if (format2 >= 35840 && format2 <= 35843) {
      return "pvrtc";
    } else if (format2 >= 36196) {
      return "etc1";
    } else if (format2 >= 35986 && format2 <= 34798) {
      return "atc";
    }
    throw new Error("Invalid (compressed) texture format given!");
  };
  CompressedTextureResource2._createLevelBuffers = function(buffer2, format2, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
    var buffers = new Array(levels);
    var offset = buffer2.byteOffset;
    var levelWidth = imageWidth;
    var levelHeight = imageHeight;
    var alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
    var alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
    var levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
    for (var i = 0; i < levels; i++) {
      buffers[i] = {
        levelID: i,
        levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
        levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
        levelBuffer: new Uint8Array(buffer2.buffer, offset, levelSize)
      };
      offset += levelSize;
      levelWidth = levelWidth >> 1 || 1;
      levelHeight = levelHeight >> 1 || 1;
      alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
      alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
      levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
    }
    return buffers;
  };
  return CompressedTextureResource2;
}(BlobResource);
var CompressedTextureLoader = function() {
  function CompressedTextureLoader2() {
  }
  CompressedTextureLoader2.use = function(resource, next) {
    var data = resource.data;
    var loader = this;
    if (resource.type === LoaderResource.TYPE.JSON && data && data.cacheID && data.textures) {
      var textures = data.textures;
      var textureURL = void 0;
      var fallbackURL = void 0;
      for (var i = 0, j = textures.length; i < j; i++) {
        var texture = textures[i];
        var url_1 = texture.src;
        var format2 = texture.format;
        if (!format2) {
          fallbackURL = url_1;
        }
        if (CompressedTextureLoader2.textureFormats[format2]) {
          textureURL = url_1;
          break;
        }
      }
      textureURL = textureURL || fallbackURL;
      if (!textureURL) {
        next(new Error("Cannot load compressed-textures in " + resource.url + ", make sure you provide a fallback"));
        return;
      }
      if (textureURL === resource.url) {
        next(new Error("URL of compressed texture cannot be the same as the manifest's URL"));
        return;
      }
      var loadOptions = {
        crossOrigin: resource.crossOrigin,
        metadata: resource.metadata.imageMetadata,
        parentResource: resource
      };
      var resourcePath = url.resolve(resource.url.replace(loader.baseUrl, ""), textureURL);
      var resourceName = data.cacheID;
      loader.add(resourceName, resourcePath, loadOptions, function(res) {
        if (res.error) {
          next(res.error);
          return;
        }
        var _a2 = res.texture, texture2 = _a2 === void 0 ? null : _a2, _b2 = res.textures, textures2 = _b2 === void 0 ? {} : _b2;
        Object.assign(resource, { texture: texture2, textures: textures2 });
        next();
      });
    } else {
      next();
    }
  };
  CompressedTextureLoader2.add = function() {
    var canvas2 = document.createElement("canvas");
    var gl = canvas2.getContext("webgl");
    if (!gl) {
      console.warn("WebGL not available for compressed textures. Silently failing.");
      return;
    }
    var extensions = {
      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: gl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl.getExtension("WEBGL_compressed_texture_astc")
    };
    CompressedTextureLoader2.textureExtensions = extensions;
    CompressedTextureLoader2.textureFormats = {};
    for (var extensionName in extensions) {
      var extension = extensions[extensionName];
      if (!extension) {
        continue;
      }
      Object.assign(CompressedTextureLoader2.textureFormats, Object.getPrototypeOf(extension));
    }
  };
  return CompressedTextureLoader2;
}();
function registerCompressedTextures(url2, resources2, metadata) {
  var result = {
    textures: {},
    texture: null
  };
  if (!resources2) {
    return result;
  }
  var textures = resources2.map(function(resource) {
    return new Texture(new BaseTexture(resource, Object.assign({
      mipmap: MIPMAP_MODES$3.OFF,
      alphaMode: ALPHA_MODES$3.NO_PREMULTIPLIED_ALPHA
    }, metadata)));
  });
  textures.forEach(function(texture, i) {
    var baseTexture = texture.baseTexture;
    var cacheID = url2 + "-" + (i + 1);
    BaseTexture.addToCache(baseTexture, cacheID);
    Texture.addToCache(texture, cacheID);
    if (i === 0) {
      BaseTexture.addToCache(baseTexture, url2);
      Texture.addToCache(texture, url2);
      result.texture = texture;
    }
    result.textures[cacheID] = texture;
  });
  return result;
}
var _a$1$1, _b;
LoaderResource.setExtensionXhrType("dds", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var DDS_MAGIC_SIZE = 4;
var DDS_HEADER_SIZE = 124;
var DDS_HEADER_PF_SIZE = 32;
var DDS_HEADER_DX10_SIZE = 20;
var DDS_MAGIC = 542327876;
var DDS_FIELDS = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
};
var DDS_PF_FIELDS = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
};
var DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
};
var DXGI_FORMAT;
(function(DXGI_FORMAT2) {
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_UNKNOWN"] = 0] = "DXGI_FORMAT_UNKNOWN";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_TYPELESS"] = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_FLOAT"] = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_UINT"] = 3] = "DXGI_FORMAT_R32G32B32A32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_SINT"] = 4] = "DXGI_FORMAT_R32G32B32A32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_TYPELESS"] = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_FLOAT"] = 6] = "DXGI_FORMAT_R32G32B32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_UINT"] = 7] = "DXGI_FORMAT_R32G32B32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_SINT"] = 8] = "DXGI_FORMAT_R32G32B32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_TYPELESS"] = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_FLOAT"] = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UNORM"] = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UINT"] = 12] = "DXGI_FORMAT_R16G16B16A16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SNORM"] = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SINT"] = 14] = "DXGI_FORMAT_R16G16B16A16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_TYPELESS"] = 15] = "DXGI_FORMAT_R32G32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_FLOAT"] = 16] = "DXGI_FORMAT_R32G32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_UINT"] = 17] = "DXGI_FORMAT_R32G32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_SINT"] = 18] = "DXGI_FORMAT_R32G32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G8X24_TYPELESS"] = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT_S8X24_UINT"] = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"] = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"] = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_TYPELESS"] = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UNORM"] = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UINT"] = 25] = "DXGI_FORMAT_R10G10B10A2_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R11G11B10_FLOAT"] = 26] = "DXGI_FORMAT_R11G11B10_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_TYPELESS"] = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM"] = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"] = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UINT"] = 30] = "DXGI_FORMAT_R8G8B8A8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SNORM"] = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SINT"] = 32] = "DXGI_FORMAT_R8G8B8A8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_TYPELESS"] = 33] = "DXGI_FORMAT_R16G16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_FLOAT"] = 34] = "DXGI_FORMAT_R16G16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UNORM"] = 35] = "DXGI_FORMAT_R16G16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UINT"] = 36] = "DXGI_FORMAT_R16G16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SNORM"] = 37] = "DXGI_FORMAT_R16G16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SINT"] = 38] = "DXGI_FORMAT_R16G16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_TYPELESS"] = 39] = "DXGI_FORMAT_R32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT"] = 40] = "DXGI_FORMAT_D32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT"] = 41] = "DXGI_FORMAT_R32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_UINT"] = 42] = "DXGI_FORMAT_R32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_SINT"] = 43] = "DXGI_FORMAT_R32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24G8_TYPELESS"] = 44] = "DXGI_FORMAT_R24G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D24_UNORM_S8_UINT"] = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24_UNORM_X8_TYPELESS"] = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X24_TYPELESS_G8_UINT"] = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_TYPELESS"] = 48] = "DXGI_FORMAT_R8G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UNORM"] = 49] = "DXGI_FORMAT_R8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UINT"] = 50] = "DXGI_FORMAT_R8G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SNORM"] = 51] = "DXGI_FORMAT_R8G8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SINT"] = 52] = "DXGI_FORMAT_R8G8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_TYPELESS"] = 53] = "DXGI_FORMAT_R16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_FLOAT"] = 54] = "DXGI_FORMAT_R16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D16_UNORM"] = 55] = "DXGI_FORMAT_D16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UNORM"] = 56] = "DXGI_FORMAT_R16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UINT"] = 57] = "DXGI_FORMAT_R16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SNORM"] = 58] = "DXGI_FORMAT_R16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SINT"] = 59] = "DXGI_FORMAT_R16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_TYPELESS"] = 60] = "DXGI_FORMAT_R8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UNORM"] = 61] = "DXGI_FORMAT_R8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UINT"] = 62] = "DXGI_FORMAT_R8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SNORM"] = 63] = "DXGI_FORMAT_R8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SINT"] = 64] = "DXGI_FORMAT_R8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8_UNORM"] = 65] = "DXGI_FORMAT_A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R1_UNORM"] = 66] = "DXGI_FORMAT_R1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R9G9B9E5_SHAREDEXP"] = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_B8G8_UNORM"] = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_G8R8_G8B8_UNORM"] = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_TYPELESS"] = 70] = "DXGI_FORMAT_BC1_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM"] = 71] = "DXGI_FORMAT_BC1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM_SRGB"] = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_TYPELESS"] = 73] = "DXGI_FORMAT_BC2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM"] = 74] = "DXGI_FORMAT_BC2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM_SRGB"] = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_TYPELESS"] = 76] = "DXGI_FORMAT_BC3_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM"] = 77] = "DXGI_FORMAT_BC3_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM_SRGB"] = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_TYPELESS"] = 79] = "DXGI_FORMAT_BC4_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_UNORM"] = 80] = "DXGI_FORMAT_BC4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_SNORM"] = 81] = "DXGI_FORMAT_BC4_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_TYPELESS"] = 82] = "DXGI_FORMAT_BC5_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_UNORM"] = 83] = "DXGI_FORMAT_BC5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_SNORM"] = 84] = "DXGI_FORMAT_BC5_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G6R5_UNORM"] = 85] = "DXGI_FORMAT_B5G6R5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G5R5A1_UNORM"] = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM"] = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM"] = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"] = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_TYPELESS"] = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"] = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_TYPELESS"] = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"] = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_TYPELESS"] = 94] = "DXGI_FORMAT_BC6H_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_UF16"] = 95] = "DXGI_FORMAT_BC6H_UF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_SF16"] = 96] = "DXGI_FORMAT_BC6H_SF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_TYPELESS"] = 97] = "DXGI_FORMAT_BC7_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM"] = 98] = "DXGI_FORMAT_BC7_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM_SRGB"] = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AYUV"] = 100] = "DXGI_FORMAT_AYUV";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y410"] = 101] = "DXGI_FORMAT_Y410";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y416"] = 102] = "DXGI_FORMAT_Y416";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV12"] = 103] = "DXGI_FORMAT_NV12";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P010"] = 104] = "DXGI_FORMAT_P010";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P016"] = 105] = "DXGI_FORMAT_P016";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_420_OPAQUE"] = 106] = "DXGI_FORMAT_420_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_YUY2"] = 107] = "DXGI_FORMAT_YUY2";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y210"] = 108] = "DXGI_FORMAT_Y210";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y216"] = 109] = "DXGI_FORMAT_Y216";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV11"] = 110] = "DXGI_FORMAT_NV11";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AI44"] = 111] = "DXGI_FORMAT_AI44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_IA44"] = 112] = "DXGI_FORMAT_IA44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P8"] = 113] = "DXGI_FORMAT_P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8P8"] = 114] = "DXGI_FORMAT_A8P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B4G4R4A4_UNORM"] = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P208"] = 116] = "DXGI_FORMAT_P208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V208"] = 117] = "DXGI_FORMAT_V208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V408"] = 118] = "DXGI_FORMAT_V408";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"] = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"] = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_FORCE_UINT"] = 121] = "DXGI_FORMAT_FORCE_UINT";
})(DXGI_FORMAT || (DXGI_FORMAT = {}));
var D3D10_RESOURCE_DIMENSION;
(function(D3D10_RESOURCE_DIMENSION2) {
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE3D"] = 6] = "DDS_DIMENSION_TEXTURE3D";
})(D3D10_RESOURCE_DIMENSION || (D3D10_RESOURCE_DIMENSION = {}));
var PF_FLAGS = 1;
var DDPF_ALPHA = 2;
var DDPF_FOURCC = 4;
var DDPF_RGB = 64;
var DDPF_YUV = 512;
var DDPF_LUMINANCE = 131072;
var FOURCC_DXT1 = 827611204;
var FOURCC_DXT3 = 861165636;
var FOURCC_DXT5 = 894720068;
var FOURCC_DX10 = 808540228;
var DDS_RESOURCE_MISC_TEXTURECUBE = 4;
var FOURCC_TO_FORMAT = (_a$1$1 = {}, _a$1$1[FOURCC_DXT1] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _a$1$1[FOURCC_DXT3] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _a$1$1[FOURCC_DXT5] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _a$1$1);
var DXGI_TO_FORMAT = (_b = {}, _b[DXGI_FORMAT.DXGI_FORMAT_BC1_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC2_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC3_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, _b);
var DDSLoader = function() {
  function DDSLoader2() {
  }
  DDSLoader2.use = function(resource, next) {
    if (resource.extension === "dds" && resource.data) {
      try {
        Object.assign(resource, registerCompressedTextures(resource.name || resource.url, DDSLoader2.parse(resource.data), resource.metadata));
      } catch (err) {
        next(err);
        return;
      }
    }
    next();
  };
  DDSLoader2.parse = function(arrayBuffer) {
    var data = new Uint32Array(arrayBuffer);
    var magicWord = data[0];
    if (magicWord !== DDS_MAGIC) {
      throw new Error("Invalid DDS file magic word");
    }
    var header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    var height = header[DDS_FIELDS.HEIGHT];
    var width = header[DDS_FIELDS.WIDTH];
    var mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];
    var pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    var formatFlags = pixelFormat[PF_FLAGS];
    if (formatFlags & DDPF_FOURCC) {
      var fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];
      if (fourCC !== FOURCC_DX10) {
        var internalFormat_1 = FOURCC_TO_FORMAT[fourCC];
        var dataOffset_1 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
        var texData = new Uint8Array(arrayBuffer, dataOffset_1);
        var resource = new CompressedTextureResource(texData, {
          format: internalFormat_1,
          width,
          height,
          levels: mipmapCount
        });
        return [resource];
      }
      var dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
      var dx10Header = new Uint32Array(data.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
      var dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];
      var resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];
      var miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];
      var arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];
      var internalFormat_2 = DXGI_TO_FORMAT[dxgiFormat];
      if (internalFormat_2 === void 0) {
        throw new Error("DDSLoader cannot parse texture data with DXGI format " + dxgiFormat);
      }
      if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) {
        throw new Error("DDSLoader does not support cubemap textures");
      }
      if (resourceDimension === D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D) {
        throw new Error("DDSLoader does not supported 3D texture data");
      }
      var imageBuffers = new Array();
      var dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
      if (arraySize === 1) {
        imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));
      } else {
        var pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat_2];
        var imageSize = 0;
        var levelWidth = width;
        var levelHeight = height;
        for (var i = 0; i < mipmapCount; i++) {
          var alignedLevelWidth = Math.max(1, levelWidth + 3 & ~3);
          var alignedLevelHeight = Math.max(1, levelHeight + 3 & ~3);
          var levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;
          imageSize += levelSize;
          levelWidth = levelWidth >>> 1;
          levelHeight = levelHeight >>> 1;
        }
        var imageOffset = dataOffset;
        for (var i = 0; i < arraySize; i++) {
          imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));
          imageOffset += imageSize;
        }
      }
      return imageBuffers.map(function(buffer2) {
        return new CompressedTextureResource(buffer2, {
          format: internalFormat_2,
          width,
          height,
          levels: mipmapCount
        });
      });
    }
    if (formatFlags & DDPF_RGB) {
      throw new Error("DDSLoader does not support uncompressed texture data.");
    }
    if (formatFlags & DDPF_YUV) {
      throw new Error("DDSLoader does not supported YUV uncompressed texture data.");
    }
    if (formatFlags & DDPF_LUMINANCE) {
      throw new Error("DDSLoader does not support single-channel (lumninance) texture data!");
    }
    if (formatFlags & DDPF_ALPHA) {
      throw new Error("DDSLoader does not support single-channel (alpha) texture data!");
    }
    throw new Error("DDSLoader failed to load a texture file due to an unknown reason!");
  };
  return DDSLoader2;
}();
var _a$2, _b$1, _c;
LoaderResource.setExtensionXhrType("ktx", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
var ENDIANNESS = 67305985;
var KTX_FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
};
var FILE_HEADER_SIZE = 64;
var TYPES_TO_BYTES_PER_COMPONENT = (_a$2 = {}, _a$2[TYPES$3.UNSIGNED_BYTE] = 1, _a$2[TYPES$3.UNSIGNED_SHORT] = 2, _a$2[TYPES$3.FLOAT] = 4, _a$2[TYPES$3.HALF_FLOAT] = 8, _a$2);
var FORMATS_TO_COMPONENTS = (_b$1 = {}, _b$1[FORMATS$3.RGBA] = 4, _b$1[FORMATS$3.RGB] = 3, _b$1[FORMATS$3.LUMINANCE] = 1, _b$1[FORMATS$3.LUMINANCE_ALPHA] = 2, _b$1[FORMATS$3.ALPHA] = 1, _b$1);
var TYPES_TO_BYTES_PER_PIXEL = (_c = {}, _c[TYPES$3.UNSIGNED_SHORT_4_4_4_4] = 2, _c[TYPES$3.UNSIGNED_SHORT_5_5_5_1] = 2, _c[TYPES$3.UNSIGNED_SHORT_5_6_5] = 2, _c);
var KTXLoader = function() {
  function KTXLoader2() {
  }
  KTXLoader2.use = function(resource, next) {
    if (resource.extension === "ktx" && resource.data) {
      try {
        var url2 = resource.name || resource.url;
        Object.assign(resource, registerCompressedTextures(url2, KTXLoader2.parse(url2, resource.data), resource.metadata));
      } catch (err) {
        next(err);
        return;
      }
    }
    next();
  };
  KTXLoader2.parse = function(url2, arrayBuffer) {
    var dataView = new DataView(arrayBuffer);
    if (!KTXLoader2.validate(url2, dataView)) {
      return null;
    }
    var littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS;
    var glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian);
    var glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian);
    var glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian);
    var pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian);
    var pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
    var pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1;
    var numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
    var numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian);
    var numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
    var bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
    if (pixelHeight === 0 || pixelDepth !== 1) {
      throw new Error("Only 2D textures are supported");
    }
    if (numberOfFaces !== 1) {
      throw new Error("CubeTextures are not supported by KTXLoader yet!");
    }
    if (numberOfArrayElements !== 1) {
      throw new Error("WebGL does not support array textures");
    }
    var blockWidth = 4;
    var blockHeight = 4;
    var alignedWidth = pixelWidth + 3 & ~3;
    var alignedHeight = pixelHeight + 3 & ~3;
    var imageBuffers = new Array(numberOfArrayElements);
    var imagePixels = pixelWidth * pixelHeight;
    if (glType === 0) {
      imagePixels = alignedWidth * alignedHeight;
    }
    var imagePixelByteSize;
    if (glType !== 0) {
      if (TYPES_TO_BYTES_PER_COMPONENT[glType]) {
        imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat];
      } else {
        imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType];
      }
    } else {
      imagePixelByteSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
    }
    if (imagePixelByteSize === void 0) {
      throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
    }
    var imageByteSize = imagePixels * imagePixelByteSize;
    var mipByteSize = imageByteSize;
    var mipWidth = pixelWidth;
    var mipHeight = pixelHeight;
    var alignedMipWidth = alignedWidth;
    var alignedMipHeight = alignedHeight;
    var imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;
    for (var mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
      var imageSize = dataView.getUint32(imageOffset, littleEndian);
      var elementOffset = imageOffset + 4;
      for (var arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {
        var mips = imageBuffers[arrayElement];
        if (!mips) {
          mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels);
        }
        mips[mipmapLevel] = {
          levelID: mipmapLevel,
          levelWidth: numberOfMipmapLevels > 1 ? mipWidth : alignedMipWidth,
          levelHeight: numberOfMipmapLevels > 1 ? mipHeight : alignedMipHeight,
          levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)
        };
        elementOffset += mipByteSize;
      }
      imageOffset += imageSize + 4;
      imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
      mipWidth = mipWidth >> 1 || 1;
      mipHeight = mipHeight >> 1 || 1;
      alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);
      alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);
      mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
    }
    if (glType !== 0) {
      throw new Error("TODO: Uncompressed");
    }
    return imageBuffers.map(function(levelBuffers) {
      return new CompressedTextureResource(null, {
        format: glInternalFormat,
        width: pixelWidth,
        height: pixelHeight,
        levels: numberOfMipmapLevels,
        levelBuffers
      });
    });
  };
  KTXLoader2.validate = function(url2, dataView) {
    for (var i = 0; i < FILE_IDENTIFIER.length; i++) {
      if (dataView.getUint8(i) !== FILE_IDENTIFIER[i]) {
        console.error(url2 + " is not a valid *.ktx file!");
        return false;
      }
    }
    return true;
  };
  return KTXLoader2;
}();
/*!
 * @pixi/particle-container - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/particle-container is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$f = function(d, b) {
  extendStatics$f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$f(d, b);
};
function __extends$f(d, b) {
  extendStatics$f(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
(function(_super) {
  __extends$f(ParticleContainer, _super);
  function ParticleContainer(maxSize, properties, batchSize, autoResize) {
    if (maxSize === void 0) {
      maxSize = 1500;
    }
    if (batchSize === void 0) {
      batchSize = 16384;
    }
    if (autoResize === void 0) {
      autoResize = false;
    }
    var _this = _super.call(this) || this;
    var maxBatchSize = 16384;
    if (batchSize > maxBatchSize) {
      batchSize = maxBatchSize;
    }
    _this._properties = [false, true, false, false, false];
    _this._maxSize = maxSize;
    _this._batchSize = batchSize;
    _this._buffers = null;
    _this._bufferUpdateIDs = [];
    _this._updateID = 0;
    _this.interactiveChildren = false;
    _this.blendMode = BLEND_MODES$3.NORMAL;
    _this.autoResize = autoResize;
    _this.roundPixels = true;
    _this.baseTexture = null;
    _this.setProperties(properties);
    _this._tint = 0;
    _this.tintRgb = new Float32Array(4);
    _this.tint = 16777215;
    return _this;
  }
  ParticleContainer.prototype.setProperties = function(properties) {
    if (properties) {
      this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];
      this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];
      this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];
      this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];
      this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];
    }
  };
  ParticleContainer.prototype.updateTransform = function() {
    this.displayObjectUpdateTransform();
  };
  Object.defineProperty(ParticleContainer.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(value) {
      this._tint = value;
      hex2rgb(value, this.tintRgb);
    },
    enumerable: false,
    configurable: true
  });
  ParticleContainer.prototype.render = function(renderer) {
    var _this = this;
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
      return;
    }
    if (!this.baseTexture) {
      this.baseTexture = this.children[0]._texture.baseTexture;
      if (!this.baseTexture.valid) {
        this.baseTexture.once("update", function() {
          return _this.onChildrenChange(0);
        });
      }
    }
    renderer.batch.setObjectRenderer(renderer.plugins.particle);
    renderer.plugins.particle.render(this);
  };
  ParticleContainer.prototype.onChildrenChange = function(smallestChildIndex) {
    var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
    while (this._bufferUpdateIDs.length < bufferIndex) {
      this._bufferUpdateIDs.push(0);
    }
    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
  };
  ParticleContainer.prototype.dispose = function() {
    if (this._buffers) {
      for (var i = 0; i < this._buffers.length; ++i) {
        this._buffers[i].destroy();
      }
      this._buffers = null;
    }
  };
  ParticleContainer.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this, options);
    this.dispose();
    this._properties = null;
    this._buffers = null;
    this._bufferUpdateIDs = null;
  };
  return ParticleContainer;
})(Container);
var ParticleBuffer = function() {
  function ParticleBuffer2(properties, dynamicPropertyFlags, size) {
    this.geometry = new Geometry();
    this.indexBuffer = null;
    this.size = size;
    this.dynamicProperties = [];
    this.staticProperties = [];
    for (var i = 0; i < properties.length; ++i) {
      var property = properties[i];
      property = {
        attributeName: property.attributeName,
        size: property.size,
        uploadFunction: property.uploadFunction,
        type: property.type || TYPES$3.FLOAT,
        offset: property.offset
      };
      if (dynamicPropertyFlags[i]) {
        this.dynamicProperties.push(property);
      } else {
        this.staticProperties.push(property);
      }
    }
    this.staticStride = 0;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.dynamicStride = 0;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this._updateID = 0;
    this.initBuffers();
  }
  ParticleBuffer2.prototype.initBuffers = function() {
    var geometry = this.geometry;
    var dynamicOffset = 0;
    this.indexBuffer = new Buffer$1(createIndicesForQuads(this.size), true, true);
    geometry.addIndex(this.indexBuffer);
    this.dynamicStride = 0;
    for (var i = 0; i < this.dynamicProperties.length; ++i) {
      var property = this.dynamicProperties[i];
      property.offset = dynamicOffset;
      dynamicOffset += property.size;
      this.dynamicStride += property.size;
    }
    var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
    this.dynamicData = new Float32Array(dynBuffer);
    this.dynamicDataUint32 = new Uint32Array(dynBuffer);
    this.dynamicBuffer = new Buffer$1(this.dynamicData, false, false);
    var staticOffset = 0;
    this.staticStride = 0;
    for (var i = 0; i < this.staticProperties.length; ++i) {
      var property = this.staticProperties[i];
      property.offset = staticOffset;
      staticOffset += property.size;
      this.staticStride += property.size;
    }
    var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
    this.staticData = new Float32Array(statBuffer);
    this.staticDataUint32 = new Uint32Array(statBuffer);
    this.staticBuffer = new Buffer$1(this.staticData, true, false);
    for (var i = 0; i < this.dynamicProperties.length; ++i) {
      var property = this.dynamicProperties[i];
      geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === TYPES$3.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);
    }
    for (var i = 0; i < this.staticProperties.length; ++i) {
      var property = this.staticProperties[i];
      geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === TYPES$3.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);
    }
  };
  ParticleBuffer2.prototype.uploadDynamic = function(children, startIndex, amount) {
    for (var i = 0; i < this.dynamicProperties.length; i++) {
      var property = this.dynamicProperties[i];
      property.uploadFunction(children, startIndex, amount, property.type === TYPES$3.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
    }
    this.dynamicBuffer._updateID++;
  };
  ParticleBuffer2.prototype.uploadStatic = function(children, startIndex, amount) {
    for (var i = 0; i < this.staticProperties.length; i++) {
      var property = this.staticProperties[i];
      property.uploadFunction(children, startIndex, amount, property.type === TYPES$3.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
    }
    this.staticBuffer._updateID++;
  };
  ParticleBuffer2.prototype.destroy = function() {
    this.indexBuffer = null;
    this.dynamicProperties = null;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this.staticProperties = null;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.geometry.destroy();
  };
  return ParticleBuffer2;
}();
var fragment$6 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";
var vertex$3 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";
var ParticleRenderer = function(_super) {
  __extends$f(ParticleRenderer2, _super);
  function ParticleRenderer2(renderer) {
    var _this = _super.call(this, renderer) || this;
    _this.shader = null;
    _this.properties = null;
    _this.tempMatrix = new Matrix();
    _this.properties = [
      {
        attributeName: "aVertexPosition",
        size: 2,
        uploadFunction: _this.uploadVertices,
        offset: 0
      },
      {
        attributeName: "aPositionCoord",
        size: 2,
        uploadFunction: _this.uploadPosition,
        offset: 0
      },
      {
        attributeName: "aRotation",
        size: 1,
        uploadFunction: _this.uploadRotation,
        offset: 0
      },
      {
        attributeName: "aTextureCoord",
        size: 2,
        uploadFunction: _this.uploadUvs,
        offset: 0
      },
      {
        attributeName: "aColor",
        size: 1,
        type: TYPES$3.UNSIGNED_BYTE,
        uploadFunction: _this.uploadTint,
        offset: 0
      }
    ];
    _this.shader = Shader.from(vertex$3, fragment$6, {});
    _this.state = State.for2d();
    return _this;
  }
  ParticleRenderer2.prototype.render = function(container) {
    var children = container.children;
    var maxSize = container._maxSize;
    var batchSize = container._batchSize;
    var renderer = this.renderer;
    var totalChildren = children.length;
    if (totalChildren === 0) {
      return;
    } else if (totalChildren > maxSize && !container.autoResize) {
      totalChildren = maxSize;
    }
    var buffers = container._buffers;
    if (!buffers) {
      buffers = container._buffers = this.generateBuffers(container);
    }
    var baseTexture = children[0]._texture.baseTexture;
    this.state.blendMode = correctBlendMode(container.blendMode, baseTexture.alphaMode);
    renderer.state.set(this.state);
    var gl = renderer.gl;
    var m = container.worldTransform.copyTo(this.tempMatrix);
    m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
    this.shader.uniforms.translationMatrix = m.toArray(true);
    this.shader.uniforms.uColor = premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, baseTexture.alphaMode);
    this.shader.uniforms.uSampler = baseTexture;
    this.renderer.shader.bind(this.shader);
    var updateStatic = false;
    for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
      var amount = totalChildren - i;
      if (amount > batchSize) {
        amount = batchSize;
      }
      if (j >= buffers.length) {
        buffers.push(this._generateOneMoreBuffer(container));
      }
      var buffer2 = buffers[j];
      buffer2.uploadDynamic(children, i, amount);
      var bid = container._bufferUpdateIDs[j] || 0;
      updateStatic = updateStatic || buffer2._updateID < bid;
      if (updateStatic) {
        buffer2._updateID = container._updateID;
        buffer2.uploadStatic(children, i, amount);
      }
      renderer.geometry.bind(buffer2.geometry);
      gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
    }
  };
  ParticleRenderer2.prototype.generateBuffers = function(container) {
    var buffers = [];
    var size = container._maxSize;
    var batchSize = container._batchSize;
    var dynamicPropertyFlags = container._properties;
    for (var i = 0; i < size; i += batchSize) {
      buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
    }
    return buffers;
  };
  ParticleRenderer2.prototype._generateOneMoreBuffer = function(container) {
    var batchSize = container._batchSize;
    var dynamicPropertyFlags = container._properties;
    return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
  };
  ParticleRenderer2.prototype.uploadVertices = function(children, startIndex, amount, array, stride, offset) {
    var w0 = 0;
    var w1 = 0;
    var h0 = 0;
    var h1 = 0;
    for (var i = 0; i < amount; ++i) {
      var sprite = children[startIndex + i];
      var texture = sprite._texture;
      var sx = sprite.scale.x;
      var sy = sprite.scale.y;
      var trim = texture.trim;
      var orig = texture.orig;
      if (trim) {
        w1 = trim.x - sprite.anchor.x * orig.width;
        w0 = w1 + trim.width;
        h1 = trim.y - sprite.anchor.y * orig.height;
        h0 = h1 + trim.height;
      } else {
        w0 = orig.width * (1 - sprite.anchor.x);
        w1 = orig.width * -sprite.anchor.x;
        h0 = orig.height * (1 - sprite.anchor.y);
        h1 = orig.height * -sprite.anchor.y;
      }
      array[offset] = w1 * sx;
      array[offset + 1] = h1 * sy;
      array[offset + stride] = w0 * sx;
      array[offset + stride + 1] = h1 * sy;
      array[offset + stride * 2] = w0 * sx;
      array[offset + stride * 2 + 1] = h0 * sy;
      array[offset + stride * 3] = w1 * sx;
      array[offset + stride * 3 + 1] = h0 * sy;
      offset += stride * 4;
    }
  };
  ParticleRenderer2.prototype.uploadPosition = function(children, startIndex, amount, array, stride, offset) {
    for (var i = 0; i < amount; i++) {
      var spritePosition = children[startIndex + i].position;
      array[offset] = spritePosition.x;
      array[offset + 1] = spritePosition.y;
      array[offset + stride] = spritePosition.x;
      array[offset + stride + 1] = spritePosition.y;
      array[offset + stride * 2] = spritePosition.x;
      array[offset + stride * 2 + 1] = spritePosition.y;
      array[offset + stride * 3] = spritePosition.x;
      array[offset + stride * 3 + 1] = spritePosition.y;
      offset += stride * 4;
    }
  };
  ParticleRenderer2.prototype.uploadRotation = function(children, startIndex, amount, array, stride, offset) {
    for (var i = 0; i < amount; i++) {
      var spriteRotation = children[startIndex + i].rotation;
      array[offset] = spriteRotation;
      array[offset + stride] = spriteRotation;
      array[offset + stride * 2] = spriteRotation;
      array[offset + stride * 3] = spriteRotation;
      offset += stride * 4;
    }
  };
  ParticleRenderer2.prototype.uploadUvs = function(children, startIndex, amount, array, stride, offset) {
    for (var i = 0; i < amount; ++i) {
      var textureUvs = children[startIndex + i]._texture._uvs;
      if (textureUvs) {
        array[offset] = textureUvs.x0;
        array[offset + 1] = textureUvs.y0;
        array[offset + stride] = textureUvs.x1;
        array[offset + stride + 1] = textureUvs.y1;
        array[offset + stride * 2] = textureUvs.x2;
        array[offset + stride * 2 + 1] = textureUvs.y2;
        array[offset + stride * 3] = textureUvs.x3;
        array[offset + stride * 3 + 1] = textureUvs.y3;
        offset += stride * 4;
      } else {
        array[offset] = 0;
        array[offset + 1] = 0;
        array[offset + stride] = 0;
        array[offset + stride + 1] = 0;
        array[offset + stride * 2] = 0;
        array[offset + stride * 2 + 1] = 0;
        array[offset + stride * 3] = 0;
        array[offset + stride * 3 + 1] = 0;
        offset += stride * 4;
      }
    }
  };
  ParticleRenderer2.prototype.uploadTint = function(children, startIndex, amount, array, stride, offset) {
    for (var i = 0; i < amount; ++i) {
      var sprite = children[startIndex + i];
      var premultiplied = sprite._texture.baseTexture.alphaMode > 0;
      var alpha = sprite.alpha;
      var argb = alpha < 1 && premultiplied ? premultiplyTint(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);
      array[offset] = argb;
      array[offset + stride] = argb;
      array[offset + stride * 2] = argb;
      array[offset + stride * 3] = argb;
      offset += stride * 4;
    }
  };
  ParticleRenderer2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    if (this.shader) {
      this.shader.destroy();
      this.shader = null;
    }
    this.tempMatrix = null;
  };
  return ParticleRenderer2;
}(ObjectRenderer);
/*!
 * @pixi/graphics - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/graphics is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var LINE_JOIN;
(function(LINE_JOIN2) {
  LINE_JOIN2["MITER"] = "miter";
  LINE_JOIN2["BEVEL"] = "bevel";
  LINE_JOIN2["ROUND"] = "round";
})(LINE_JOIN || (LINE_JOIN = {}));
var LINE_CAP;
(function(LINE_CAP2) {
  LINE_CAP2["BUTT"] = "butt";
  LINE_CAP2["ROUND"] = "round";
  LINE_CAP2["SQUARE"] = "square";
})(LINE_CAP || (LINE_CAP = {}));
var GRAPHICS_CURVES = {
  adaptive: true,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount: function(length, defaultSegments) {
    if (defaultSegments === void 0) {
      defaultSegments = 20;
    }
    if (!this.adaptive || !length || isNaN(length)) {
      return defaultSegments;
    }
    var result = Math.ceil(length / this.maxLength);
    if (result < this.minSegments) {
      result = this.minSegments;
    } else if (result > this.maxSegments) {
      result = this.maxSegments;
    }
    return result;
  }
};
var FillStyle = function() {
  function FillStyle2() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = Texture.WHITE;
    this.matrix = null;
    this.visible = false;
    this.reset();
  }
  FillStyle2.prototype.clone = function() {
    var obj = new FillStyle2();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    return obj;
  };
  FillStyle2.prototype.reset = function() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = Texture.WHITE;
    this.matrix = null;
    this.visible = false;
  };
  FillStyle2.prototype.destroy = function() {
    this.texture = null;
    this.matrix = null;
  };
  return FillStyle2;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$e = function(d, b) {
  extendStatics$e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$e(d, b);
};
function __extends$e(d, b) {
  extendStatics$e(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var buildPoly = {
  build: function(graphicsData) {
    graphicsData.points = graphicsData.shape.points.slice();
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var holes = graphicsData.holes;
    var verts = graphicsGeometry.points;
    var indices2 = graphicsGeometry.indices;
    if (points.length >= 6) {
      var holeArray = [];
      for (var i = 0; i < holes.length; i++) {
        var hole = holes[i];
        holeArray.push(points.length / 2);
        points = points.concat(hole.points);
      }
      var triangles = earcut$1(points, holeArray, 2);
      if (!triangles) {
        return;
      }
      var vertPos = verts.length / 2;
      for (var i = 0; i < triangles.length; i += 3) {
        indices2.push(triangles[i] + vertPos);
        indices2.push(triangles[i + 1] + vertPos);
        indices2.push(triangles[i + 2] + vertPos);
      }
      for (var i = 0; i < points.length; i++) {
        verts.push(points[i]);
      }
    }
  }
};
var buildCircle = {
  build: function(graphicsData) {
    var circleData = graphicsData.shape;
    var points = graphicsData.points;
    var x = circleData.x;
    var y = circleData.y;
    var width;
    var height;
    points.length = 0;
    if (graphicsData.type === SHAPES.CIRC) {
      width = circleData.radius;
      height = circleData.radius;
    } else {
      var ellipseData = graphicsData.shape;
      width = ellipseData.width;
      height = ellipseData.height;
    }
    if (width === 0 || height === 0) {
      return;
    }
    var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(width + height));
    totalSegs /= 2.3;
    var seg = Math.PI * 2 / totalSegs;
    for (var i = 0; i < totalSegs - 0.5; i++) {
      points.push(x + Math.sin(-seg * i) * width, y + Math.cos(-seg * i) * height);
    }
    points.push(points[0], points[1]);
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var verts = graphicsGeometry.points;
    var indices2 = graphicsGeometry.indices;
    var vertPos = verts.length / 2;
    var center = vertPos;
    var circle = graphicsData.shape;
    var matrix = graphicsData.matrix;
    var x = circle.x;
    var y = circle.y;
    verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);
    for (var i = 0; i < points.length; i += 2) {
      verts.push(points[i], points[i + 1]);
      indices2.push(vertPos++, center, vertPos);
    }
  }
};
var buildRectangle = {
  build: function(graphicsData) {
    var rectData = graphicsData.shape;
    var x = rectData.x;
    var y = rectData.y;
    var width = rectData.width;
    var height = rectData.height;
    var points = graphicsData.points;
    points.length = 0;
    points.push(x, y, x + width, y, x + width, y + height, x, y + height);
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var verts = graphicsGeometry.points;
    var vertPos = verts.length / 2;
    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
  }
};
function getPt(n1, n2, perc) {
  var diff = n2 - n1;
  return n1 + diff * perc;
}
function quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {
  if (out === void 0) {
    out = [];
  }
  var n = 20;
  var points = out;
  var xa = 0;
  var ya = 0;
  var xb = 0;
  var yb = 0;
  var x = 0;
  var y = 0;
  for (var i = 0, j = 0; i <= n; ++i) {
    j = i / n;
    xa = getPt(fromX, cpX, j);
    ya = getPt(fromY, cpY, j);
    xb = getPt(cpX, toX, j);
    yb = getPt(cpY, toY, j);
    x = getPt(xa, xb, j);
    y = getPt(ya, yb, j);
    if (i === 0 && points[points.length - 2] === x && points[points.length - 1] === y) {
      continue;
    }
    points.push(x, y);
  }
  return points;
}
var buildRoundedRectangle = {
  build: function(graphicsData) {
    var rrectData = graphicsData.shape;
    var points = graphicsData.points;
    var x = rrectData.x;
    var y = rrectData.y;
    var width = rrectData.width;
    var height = rrectData.height;
    var radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));
    points.length = 0;
    if (!radius) {
      points.push(x, y, x + width, y, x + width, y + height, x, y + height);
    } else {
      quadraticBezierCurve(x, y + radius, x, y, x + radius, y, points);
      quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, points);
      quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, points);
      quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, points);
    }
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var verts = graphicsGeometry.points;
    var indices2 = graphicsGeometry.indices;
    var vecPos = verts.length / 2;
    var triangles = earcut$1(points, null, 2);
    for (var i = 0, j = triangles.length; i < j; i += 3) {
      indices2.push(triangles[i] + vecPos);
      indices2.push(triangles[i + 1] + vecPos);
      indices2.push(triangles[i + 2] + vecPos);
    }
    for (var i = 0, j = points.length; i < j; i++) {
      verts.push(points[i], points[++i]);
    }
  }
};
function square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  var ix = x - nx * innerWeight;
  var iy = y - ny * innerWeight;
  var ox = x + nx * outerWeight;
  var oy = y + ny * outerWeight;
  var exx;
  var eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  var eix = ix + exx;
  var eiy = iy + eyy;
  var eox = ox + exx;
  var eoy = oy + eyy;
  verts.push(eix, eiy);
  verts.push(eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  var cx2p0x = sx - cx;
  var cy2p0y = sy - cy;
  var angle0 = Math.atan2(cx2p0x, cy2p0y);
  var angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  var startAngle = angle0;
  var angleDiff = angle1 - angle0;
  var absAngleDiff = Math.abs(angleDiff);
  var radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  var segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  var angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy);
    verts.push(sx, sy);
    for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx, cy);
      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
    }
    verts.push(cx, cy);
    verts.push(ex, ey);
  } else {
    verts.push(sx, sy);
    verts.push(cx, cy);
    for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
      verts.push(cx, cy);
    }
    verts.push(ex, ey);
    verts.push(cx, cy);
  }
  return segCount * 2;
}
function buildNonNativeLine(graphicsData, graphicsGeometry) {
  var shape = graphicsData.shape;
  var points = graphicsData.points || shape.points.slice();
  var eps = graphicsGeometry.closePointEps;
  if (points.length === 0) {
    return;
  }
  var style = graphicsData.lineStyle;
  var firstPoint = new Point(points[0], points[1]);
  var lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  var closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    var midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    var midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  var verts = graphicsGeometry.points;
  var length = points.length / 2;
  var indexCount = points.length;
  var indexStart = verts.length / 2;
  var width = style.width / 2;
  var widthSquared = width * width;
  var miterLimitSquared = style.miterLimit * style.miterLimit;
  var x0 = points[0];
  var y0 = points[1];
  var x1 = points[2];
  var y1 = points[3];
  var x2 = 0;
  var y2 = 0;
  var perpx = -(y0 - y1);
  var perpy = x0 - x1;
  var perp1x = 0;
  var perp1y = 0;
  var dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  var ratio = style.alignment;
  var innerWeight = (1 - ratio) * 2;
  var outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);
  verts.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);
  for (var i = 1; i < length - 1; ++i) {
    x0 = points[(i - 1) * 2];
    y0 = points[(i - 1) * 2 + 1];
    x1 = points[i * 2];
    y1 = points[i * 2 + 1];
    x2 = points[(i + 1) * 2];
    y2 = points[(i + 1) * 2 + 1];
    perpx = -(y0 - y1);
    perpy = x0 - x1;
    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    var dx0 = x1 - x0;
    var dy0 = y0 - y1;
    var dx1 = x1 - x2;
    var dy1 = y2 - y1;
    var cross = dy0 * dx1 - dy1 * dx0;
    var clockwise = cross < 0;
    if (Math.abs(cross) < 0.1) {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      continue;
    }
    var c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
    var c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    var px = (dx0 * c2 - dx1 * c1) / cross;
    var py = (dy1 * c1 - dy0 * c2) / cross;
    var pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    var imx = x1 + (px - x1) * innerWeight;
    var imy = y1 + (py - y1) * innerWeight;
    var omx = x1 - (px - x1) * outerWeight;
    var omy = y1 - (py - y1) * outerWeight;
    var smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    var insideWeight = clockwise ? innerWeight : outerWeight;
    var smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    var insideMiterOk = pdist <= smallerInsideDiagonalSq;
    if (insideMiterOk) {
      if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
          verts.push(omx, omy);
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
        indexCount += 2;
      } else if (style.join === LINE_JOIN.ROUND) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
          indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
          verts.push(omx, omy);
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
      } else {
        verts.push(imx, imy);
        verts.push(omx, omy);
      }
    } else {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared)
        ;
      else if (style.join === LINE_JOIN.ROUND) {
        if (clockwise) {
          indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
        } else {
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
        }
      } else {
        if (clockwise) {
          verts.push(omx, omy);
          verts.push(omx, omy);
        } else {
          verts.push(imx, imy);
          verts.push(imx, imy);
        }
        indexCount += 2;
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpx = -(y0 - y1);
  perpy = x0 - x1;
  dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
  verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
    }
  }
  var indices2 = graphicsGeometry.indices;
  var eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;
  for (var i = indexStart; i < indexCount + indexStart - 2; ++i) {
    x0 = verts[i * 2];
    y0 = verts[i * 2 + 1];
    x1 = verts[(i + 1) * 2];
    y1 = verts[(i + 1) * 2 + 1];
    x2 = verts[(i + 2) * 2];
    y2 = verts[(i + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices2.push(i, i + 1, i + 2);
  }
}
function buildNativeLine(graphicsData, graphicsGeometry) {
  var i = 0;
  var shape = graphicsData.shape;
  var points = graphicsData.points || shape.points;
  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  if (points.length === 0) {
    return;
  }
  var verts = graphicsGeometry.points;
  var indices2 = graphicsGeometry.indices;
  var length = points.length / 2;
  var startIndex = verts.length / 2;
  var currentIndex = startIndex;
  verts.push(points[0], points[1]);
  for (i = 1; i < length; i++) {
    verts.push(points[i * 2], points[i * 2 + 1]);
    indices2.push(currentIndex, currentIndex + 1);
    currentIndex++;
  }
  if (closedShape) {
    indices2.push(currentIndex, startIndex);
  }
}
function buildLine(graphicsData, graphicsGeometry) {
  if (graphicsData.lineStyle.native) {
    buildNativeLine(graphicsData, graphicsGeometry);
  } else {
    buildNonNativeLine(graphicsData, graphicsGeometry);
  }
}
var ArcUtils = function() {
  function ArcUtils2() {
  }
  ArcUtils2.curveTo = function(x1, y1, x2, y2, radius, points) {
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];
    var a1 = fromY - y1;
    var b1 = fromX - x1;
    var a2 = y2 - y1;
    var b2 = x2 - x1;
    var mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius === 0) {
      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
        points.push(x1, y1);
      }
      return null;
    }
    var dd = a1 * a1 + b1 * b1;
    var cc = a2 * a2 + b2 * b2;
    var tt = a1 * a2 + b1 * b2;
    var k1 = radius * Math.sqrt(dd) / mm;
    var k2 = radius * Math.sqrt(cc) / mm;
    var j1 = k1 * tt / dd;
    var j2 = k2 * tt / cc;
    var cx = k1 * b2 + k2 * b1;
    var cy = k1 * a2 + k2 * a1;
    var px = b1 * (k2 + j1);
    var py = a1 * (k2 + j1);
    var qx = b2 * (k1 + j2);
    var qy = a2 * (k1 + j2);
    var startAngle = Math.atan2(py - cy, px - cx);
    var endAngle = Math.atan2(qy - cy, qx - cx);
    return {
      cx: cx + x1,
      cy: cy + y1,
      radius,
      startAngle,
      endAngle,
      anticlockwise: b1 * a2 > b2 * a1
    };
  };
  ArcUtils2.arc = function(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
    var sweep = endAngle - startAngle;
    var n = GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);
    var theta = sweep / (n * 2);
    var theta2 = theta * 2;
    var cTheta = Math.cos(theta);
    var sTheta = Math.sin(theta);
    var segMinus = n - 1;
    var remainder = segMinus % 1 / segMinus;
    for (var i = 0; i <= segMinus; ++i) {
      var real = i + remainder * i;
      var angle = theta + startAngle + theta2 * real;
      var c = Math.cos(angle);
      var s = -Math.sin(angle);
      points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
    }
  };
  return ArcUtils2;
}();
var BezierUtils = function() {
  function BezierUtils2() {
  }
  BezierUtils2.curveLength = function(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
    var n = 10;
    var result = 0;
    var t = 0;
    var t2 = 0;
    var t3 = 0;
    var nt = 0;
    var nt2 = 0;
    var nt3 = 0;
    var x = 0;
    var y = 0;
    var dx = 0;
    var dy = 0;
    var prevX = fromX;
    var prevY = fromY;
    for (var i = 1; i <= n; ++i) {
      t = i / n;
      t2 = t * t;
      t3 = t2 * t;
      nt = 1 - t;
      nt2 = nt * nt;
      nt3 = nt2 * nt;
      x = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX;
      y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;
      dx = prevX - x;
      dy = prevY - y;
      prevX = x;
      prevY = y;
      result += Math.sqrt(dx * dx + dy * dy);
    }
    return result;
  };
  BezierUtils2.curveTo = function(cpX, cpY, cpX2, cpY2, toX, toY, points) {
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];
    points.length -= 2;
    var n = GRAPHICS_CURVES._segmentsCount(BezierUtils2.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
    var dt = 0;
    var dt2 = 0;
    var dt3 = 0;
    var t2 = 0;
    var t3 = 0;
    points.push(fromX, fromY);
    for (var i = 1, j = 0; i <= n; ++i) {
      j = i / n;
      dt = 1 - j;
      dt2 = dt * dt;
      dt3 = dt2 * dt;
      t2 = j * j;
      t3 = t2 * j;
      points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
    }
  };
  return BezierUtils2;
}();
var QuadraticUtils = function() {
  function QuadraticUtils2() {
  }
  QuadraticUtils2.curveLength = function(fromX, fromY, cpX, cpY, toX, toY) {
    var ax = fromX - 2 * cpX + toX;
    var ay = fromY - 2 * cpY + toY;
    var bx = 2 * cpX - 2 * fromX;
    var by = 2 * cpY - 2 * fromY;
    var a = 4 * (ax * ax + ay * ay);
    var b = 4 * (ax * bx + ay * by);
    var c = bx * bx + by * by;
    var s = 2 * Math.sqrt(a + b + c);
    var a2 = Math.sqrt(a);
    var a32 = 2 * a * a2;
    var c2 = 2 * Math.sqrt(c);
    var ba = b / a2;
    return (a32 * s + a2 * b * (s - c2) + (4 * c * a - b * b) * Math.log((2 * a2 + ba + s) / (ba + c2))) / (4 * a32);
  };
  QuadraticUtils2.curveTo = function(cpX, cpY, toX, toY, points) {
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];
    var n = GRAPHICS_CURVES._segmentsCount(QuadraticUtils2.curveLength(fromX, fromY, cpX, cpY, toX, toY));
    var xa = 0;
    var ya = 0;
    for (var i = 1; i <= n; ++i) {
      var j = i / n;
      xa = fromX + (cpX - fromX) * j;
      ya = fromY + (cpY - fromY) * j;
      points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
    }
  };
  return QuadraticUtils2;
}();
var BatchPart = function() {
  function BatchPart2() {
    this.reset();
  }
  BatchPart2.prototype.begin = function(style, startIndex, attribStart) {
    this.reset();
    this.style = style;
    this.start = startIndex;
    this.attribStart = attribStart;
  };
  BatchPart2.prototype.end = function(endIndex, endAttrib) {
    this.attribSize = endAttrib - this.attribStart;
    this.size = endIndex - this.start;
  };
  BatchPart2.prototype.reset = function() {
    this.style = null;
    this.size = 0;
    this.start = 0;
    this.attribStart = 0;
    this.attribSize = 0;
  };
  return BatchPart2;
}();
var _a;
var FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a);
var BATCH_POOL = [];
var DRAW_CALL_POOL = [];
function isPolygonClockwise(polygon) {
  var points = polygon.points;
  var sum = 0;
  for (var i = 0; i < points.length - 2; i += 2) {
    sum += (points[i + 2] - points[i]) * (points[i + 3] + points[i + 1]);
  }
  return sum > 0;
}
var GraphicsData = function() {
  function GraphicsData2(shape, fillStyle, lineStyle, matrix) {
    if (fillStyle === void 0) {
      fillStyle = null;
    }
    if (lineStyle === void 0) {
      lineStyle = null;
    }
    if (matrix === void 0) {
      matrix = null;
    }
    this.points = [];
    this.holes = [];
    this.shape = shape;
    this.lineStyle = lineStyle;
    this.fillStyle = fillStyle;
    this.matrix = matrix;
    this.type = shape.type;
  }
  GraphicsData2.prototype.clone = function() {
    return new GraphicsData2(this.shape, this.fillStyle, this.lineStyle, this.matrix);
  };
  GraphicsData2.prototype.destroy = function() {
    this.shape = null;
    this.holes.length = 0;
    this.holes = null;
    this.points.length = 0;
    this.points = null;
    this.lineStyle = null;
    this.fillStyle = null;
  };
  return GraphicsData2;
}();
var tmpPoint = new Point();
var tmpBounds = new Bounds();
var GraphicsGeometry = function(_super) {
  __extends$e(GraphicsGeometry2, _super);
  function GraphicsGeometry2() {
    var _this = _super.call(this) || this;
    _this.closePointEps = 1e-4;
    _this.boundsPadding = 0;
    _this.uvsFloat32 = null;
    _this.indicesUint16 = null;
    _this.batchable = false;
    _this.points = [];
    _this.colors = [];
    _this.uvs = [];
    _this.indices = [];
    _this.textureIds = [];
    _this.graphicsData = [];
    _this.drawCalls = [];
    _this.batchDirty = -1;
    _this.batches = [];
    _this.dirty = 0;
    _this.cacheDirty = -1;
    _this.clearDirty = 0;
    _this.shapeIndex = 0;
    _this._bounds = new Bounds();
    _this.boundsDirty = -1;
    return _this;
  }
  Object.defineProperty(GraphicsGeometry2.prototype, "bounds", {
    get: function() {
      if (this.boundsDirty !== this.dirty) {
        this.boundsDirty = this.dirty;
        this.calculateBounds();
      }
      return this._bounds;
    },
    enumerable: false,
    configurable: true
  });
  GraphicsGeometry2.prototype.invalidate = function() {
    this.boundsDirty = -1;
    this.dirty++;
    this.batchDirty++;
    this.shapeIndex = 0;
    this.points.length = 0;
    this.colors.length = 0;
    this.uvs.length = 0;
    this.indices.length = 0;
    this.textureIds.length = 0;
    for (var i = 0; i < this.drawCalls.length; i++) {
      this.drawCalls[i].texArray.clear();
      DRAW_CALL_POOL.push(this.drawCalls[i]);
    }
    this.drawCalls.length = 0;
    for (var i = 0; i < this.batches.length; i++) {
      var batchPart = this.batches[i];
      batchPart.reset();
      BATCH_POOL.push(batchPart);
    }
    this.batches.length = 0;
  };
  GraphicsGeometry2.prototype.clear = function() {
    if (this.graphicsData.length > 0) {
      this.invalidate();
      this.clearDirty++;
      this.graphicsData.length = 0;
    }
    return this;
  };
  GraphicsGeometry2.prototype.drawShape = function(shape, fillStyle, lineStyle, matrix) {
    if (fillStyle === void 0) {
      fillStyle = null;
    }
    if (lineStyle === void 0) {
      lineStyle = null;
    }
    if (matrix === void 0) {
      matrix = null;
    }
    var data = new GraphicsData(shape, fillStyle, lineStyle, matrix);
    this.graphicsData.push(data);
    this.dirty++;
    return this;
  };
  GraphicsGeometry2.prototype.drawHole = function(shape, matrix) {
    if (matrix === void 0) {
      matrix = null;
    }
    if (!this.graphicsData.length) {
      return null;
    }
    var data = new GraphicsData(shape, null, null, matrix);
    var lastShape = this.graphicsData[this.graphicsData.length - 1];
    data.lineStyle = lastShape.lineStyle;
    lastShape.holes.push(data);
    this.dirty++;
    return this;
  };
  GraphicsGeometry2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    for (var i = 0; i < this.graphicsData.length; ++i) {
      this.graphicsData[i].destroy();
    }
    this.points.length = 0;
    this.points = null;
    this.colors.length = 0;
    this.colors = null;
    this.uvs.length = 0;
    this.uvs = null;
    this.indices.length = 0;
    this.indices = null;
    this.indexBuffer.destroy();
    this.indexBuffer = null;
    this.graphicsData.length = 0;
    this.graphicsData = null;
    this.drawCalls.length = 0;
    this.drawCalls = null;
    this.batches.length = 0;
    this.batches = null;
    this._bounds = null;
  };
  GraphicsGeometry2.prototype.containsPoint = function(point) {
    var graphicsData = this.graphicsData;
    for (var i = 0; i < graphicsData.length; ++i) {
      var data = graphicsData[i];
      if (!data.fillStyle.visible) {
        continue;
      }
      if (data.shape) {
        if (data.matrix) {
          data.matrix.applyInverse(point, tmpPoint);
        } else {
          tmpPoint.copyFrom(point);
        }
        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
          var hitHole = false;
          if (data.holes) {
            for (var i_1 = 0; i_1 < data.holes.length; i_1++) {
              var hole = data.holes[i_1];
              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                hitHole = true;
                break;
              }
            }
          }
          if (!hitHole) {
            return true;
          }
        }
      }
    }
    return false;
  };
  GraphicsGeometry2.prototype.updateBatches = function(allow32Indices) {
    if (!this.graphicsData.length) {
      this.batchable = true;
      return;
    }
    if (!this.validateBatching()) {
      return;
    }
    this.cacheDirty = this.dirty;
    var uvs = this.uvs;
    var graphicsData = this.graphicsData;
    var batchPart = null;
    var currentStyle = null;
    if (this.batches.length > 0) {
      batchPart = this.batches[this.batches.length - 1];
      currentStyle = batchPart.style;
    }
    for (var i = this.shapeIndex; i < graphicsData.length; i++) {
      this.shapeIndex++;
      var data = graphicsData[i];
      var fillStyle = data.fillStyle;
      var lineStyle = data.lineStyle;
      var command = FILL_COMMANDS[data.type];
      command.build(data);
      if (data.matrix) {
        this.transformPoints(data.points, data.matrix);
      }
      for (var j = 0; j < 2; j++) {
        var style = j === 0 ? fillStyle : lineStyle;
        if (!style.visible) {
          continue;
        }
        var nextTexture = style.texture.baseTexture;
        var index_1 = this.indices.length;
        var attribIndex = this.points.length / 2;
        nextTexture.wrapMode = WRAP_MODES$3.REPEAT;
        if (j === 0) {
          this.processFill(data);
        } else {
          this.processLine(data);
        }
        var size = this.points.length / 2 - attribIndex;
        if (size === 0) {
          continue;
        }
        if (batchPart && !this._compareStyles(currentStyle, style)) {
          batchPart.end(index_1, attribIndex);
          batchPart = null;
        }
        if (!batchPart) {
          batchPart = BATCH_POOL.pop() || new BatchPart();
          batchPart.begin(style, index_1, attribIndex);
          this.batches.push(batchPart);
          currentStyle = style;
        }
        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);
      }
    }
    var index2 = this.indices.length;
    var attrib = this.points.length / 2;
    if (batchPart) {
      batchPart.end(index2, attrib);
    }
    if (this.batches.length === 0) {
      this.batchable = true;
      return;
    }
    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length) {
      this.indicesUint16.set(this.indices);
    } else {
      var need32 = attrib > 65535 && allow32Indices;
      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
    }
    this.batchable = this.isBatchable();
    if (this.batchable) {
      this.packBatches();
    } else {
      this.buildDrawCalls();
    }
  };
  GraphicsGeometry2.prototype._compareStyles = function(styleA, styleB) {
    if (!styleA || !styleB) {
      return false;
    }
    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
      return false;
    }
    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
      return false;
    }
    if (!!styleA.native !== !!styleB.native) {
      return false;
    }
    return true;
  };
  GraphicsGeometry2.prototype.validateBatching = function() {
    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
      return false;
    }
    for (var i = 0, l = this.graphicsData.length; i < l; i++) {
      var data = this.graphicsData[i];
      var fill = data.fillStyle;
      var line = data.lineStyle;
      if (fill && !fill.texture.baseTexture.valid) {
        return false;
      }
      if (line && !line.texture.baseTexture.valid) {
        return false;
      }
    }
    return true;
  };
  GraphicsGeometry2.prototype.packBatches = function() {
    this.batchDirty++;
    this.uvsFloat32 = new Float32Array(this.uvs);
    var batches = this.batches;
    for (var i = 0, l = batches.length; i < l; i++) {
      var batch = batches[i];
      for (var j = 0; j < batch.size; j++) {
        var index2 = batch.start + j;
        this.indicesUint16[index2] = this.indicesUint16[index2] - batch.attribStart;
      }
    }
  };
  GraphicsGeometry2.prototype.isBatchable = function() {
    if (this.points.length > 65535 * 2) {
      return false;
    }
    var batches = this.batches;
    for (var i = 0; i < batches.length; i++) {
      if (batches[i].style.native) {
        return false;
      }
    }
    return this.points.length < GraphicsGeometry2.BATCHABLE_SIZE * 2;
  };
  GraphicsGeometry2.prototype.buildDrawCalls = function() {
    var TICK = ++BaseTexture._globalBatch;
    for (var i = 0; i < this.drawCalls.length; i++) {
      this.drawCalls[i].texArray.clear();
      DRAW_CALL_POOL.push(this.drawCalls[i]);
    }
    this.drawCalls.length = 0;
    var colors = this.colors;
    var textureIds = this.textureIds;
    var currentGroup = DRAW_CALL_POOL.pop();
    if (!currentGroup) {
      currentGroup = new BatchDrawCall();
      currentGroup.texArray = new BatchTextureArray();
    }
    currentGroup.texArray.count = 0;
    currentGroup.start = 0;
    currentGroup.size = 0;
    currentGroup.type = DRAW_MODES$3.TRIANGLES;
    var textureCount = 0;
    var currentTexture = null;
    var textureId = 0;
    var native = false;
    var drawMode = DRAW_MODES$3.TRIANGLES;
    var index2 = 0;
    this.drawCalls.push(currentGroup);
    for (var i = 0; i < this.batches.length; i++) {
      var data = this.batches[i];
      var MAX_TEXTURES = 8;
      var style = data.style;
      var nextTexture = style.texture.baseTexture;
      if (native !== !!style.native) {
        native = !!style.native;
        drawMode = native ? DRAW_MODES$3.LINES : DRAW_MODES$3.TRIANGLES;
        currentTexture = null;
        textureCount = MAX_TEXTURES;
        TICK++;
      }
      if (currentTexture !== nextTexture) {
        currentTexture = nextTexture;
        if (nextTexture._batchEnabled !== TICK) {
          if (textureCount === MAX_TEXTURES) {
            TICK++;
            textureCount = 0;
            if (currentGroup.size > 0) {
              currentGroup = DRAW_CALL_POOL.pop();
              if (!currentGroup) {
                currentGroup = new BatchDrawCall();
                currentGroup.texArray = new BatchTextureArray();
              }
              this.drawCalls.push(currentGroup);
            }
            currentGroup.start = index2;
            currentGroup.size = 0;
            currentGroup.texArray.count = 0;
            currentGroup.type = drawMode;
          }
          nextTexture.touched = 1;
          nextTexture._batchEnabled = TICK;
          nextTexture._batchLocation = textureCount;
          nextTexture.wrapMode = WRAP_MODES$3.REPEAT;
          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
          textureCount++;
        }
      }
      currentGroup.size += data.size;
      index2 += data.size;
      textureId = nextTexture._batchLocation;
      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);
      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
    }
    BaseTexture._globalBatch = TICK;
    this.packAttributes();
  };
  GraphicsGeometry2.prototype.packAttributes = function() {
    var verts = this.points;
    var uvs = this.uvs;
    var colors = this.colors;
    var textureIds = this.textureIds;
    var glPoints = new ArrayBuffer(verts.length * 3 * 4);
    var f32 = new Float32Array(glPoints);
    var u32 = new Uint32Array(glPoints);
    var p = 0;
    for (var i = 0; i < verts.length / 2; i++) {
      f32[p++] = verts[i * 2];
      f32[p++] = verts[i * 2 + 1];
      f32[p++] = uvs[i * 2];
      f32[p++] = uvs[i * 2 + 1];
      u32[p++] = colors[i];
      f32[p++] = textureIds[i];
    }
    this._buffer.update(glPoints);
    this._indexBuffer.update(this.indicesUint16);
  };
  GraphicsGeometry2.prototype.processFill = function(data) {
    if (data.holes.length) {
      this.processHoles(data.holes);
      buildPoly.triangulate(data, this);
    } else {
      var command = FILL_COMMANDS[data.type];
      command.triangulate(data, this);
    }
  };
  GraphicsGeometry2.prototype.processLine = function(data) {
    buildLine(data, this);
    for (var i = 0; i < data.holes.length; i++) {
      buildLine(data.holes[i], this);
    }
  };
  GraphicsGeometry2.prototype.processHoles = function(holes) {
    for (var i = 0; i < holes.length; i++) {
      var hole = holes[i];
      var command = FILL_COMMANDS[hole.type];
      command.build(hole);
      if (hole.matrix) {
        this.transformPoints(hole.points, hole.matrix);
      }
    }
  };
  GraphicsGeometry2.prototype.calculateBounds = function() {
    var bounds = this._bounds;
    var sequenceBounds = tmpBounds;
    var curMatrix = Matrix.IDENTITY;
    this._bounds.clear();
    sequenceBounds.clear();
    for (var i = 0; i < this.graphicsData.length; i++) {
      var data = this.graphicsData[i];
      var shape = data.shape;
      var type = data.type;
      var lineStyle = data.lineStyle;
      var nextMatrix = data.matrix || Matrix.IDENTITY;
      var lineWidth = 0;
      if (lineStyle && lineStyle.visible) {
        var alignment = lineStyle.alignment;
        lineWidth = lineStyle.width;
        if (type === SHAPES.POLY) {
          if (isPolygonClockwise(shape)) {
            lineWidth = lineWidth * (1 - alignment);
          } else {
            lineWidth = lineWidth * alignment;
          }
        } else {
          lineWidth = lineWidth * Math.max(0, alignment);
        }
      }
      if (curMatrix !== nextMatrix) {
        if (!sequenceBounds.isEmpty()) {
          bounds.addBoundsMatrix(sequenceBounds, curMatrix);
          sequenceBounds.clear();
        }
        curMatrix = nextMatrix;
      }
      if (type === SHAPES.RECT || type === SHAPES.RREC) {
        var rect = shape;
        sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, lineWidth, lineWidth);
      } else if (type === SHAPES.CIRC) {
        var circle = shape;
        sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y, circle.radius + lineWidth, circle.radius + lineWidth);
      } else if (type === SHAPES.ELIP) {
        var ellipse = shape;
        sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y, ellipse.width + lineWidth, ellipse.height + lineWidth);
      } else {
        var poly = shape;
        bounds.addVerticesMatrix(curMatrix, poly.points, 0, poly.points.length, lineWidth, lineWidth);
      }
    }
    if (!sequenceBounds.isEmpty()) {
      bounds.addBoundsMatrix(sequenceBounds, curMatrix);
    }
    bounds.pad(this.boundsPadding, this.boundsPadding);
  };
  GraphicsGeometry2.prototype.transformPoints = function(points, matrix) {
    for (var i = 0; i < points.length / 2; i++) {
      var x = points[i * 2];
      var y = points[i * 2 + 1];
      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;
      points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;
    }
  };
  GraphicsGeometry2.prototype.addColors = function(colors, color, alpha, size, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var rgb = (color >> 16) + (color & 65280) + ((color & 255) << 16);
    var rgba = premultiplyTint(rgb, alpha);
    colors.length = Math.max(colors.length, offset + size);
    for (var i = 0; i < size; i++) {
      colors[offset + i] = rgba;
    }
  };
  GraphicsGeometry2.prototype.addTextureIds = function(textureIds, id, size, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    textureIds.length = Math.max(textureIds.length, offset + size);
    for (var i = 0; i < size; i++) {
      textureIds[offset + i] = id;
    }
  };
  GraphicsGeometry2.prototype.addUvs = function(verts, uvs, texture, start, size, matrix) {
    if (matrix === void 0) {
      matrix = null;
    }
    var index2 = 0;
    var uvsStart = uvs.length;
    var frame = texture.frame;
    while (index2 < size) {
      var x = verts[(start + index2) * 2];
      var y = verts[(start + index2) * 2 + 1];
      if (matrix) {
        var nx = matrix.a * x + matrix.c * y + matrix.tx;
        y = matrix.b * x + matrix.d * y + matrix.ty;
        x = nx;
      }
      index2++;
      uvs.push(x / frame.width, y / frame.height);
    }
    var baseTexture = texture.baseTexture;
    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {
      this.adjustUvs(uvs, texture, uvsStart, size);
    }
  };
  GraphicsGeometry2.prototype.adjustUvs = function(uvs, texture, start, size) {
    var baseTexture = texture.baseTexture;
    var eps = 1e-6;
    var finish = start + size * 2;
    var frame = texture.frame;
    var scaleX = frame.width / baseTexture.width;
    var scaleY = frame.height / baseTexture.height;
    var offsetX = frame.x / frame.width;
    var offsetY = frame.y / frame.height;
    var minX = Math.floor(uvs[start] + eps);
    var minY = Math.floor(uvs[start + 1] + eps);
    for (var i = start + 2; i < finish; i += 2) {
      minX = Math.min(minX, Math.floor(uvs[i] + eps));
      minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
    }
    offsetX -= minX;
    offsetY -= minY;
    for (var i = start; i < finish; i += 2) {
      uvs[i] = (uvs[i] + offsetX) * scaleX;
      uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;
    }
  };
  GraphicsGeometry2.BATCHABLE_SIZE = 100;
  return GraphicsGeometry2;
}(BatchGeometry);
var LineStyle = function(_super) {
  __extends$e(LineStyle2, _super);
  function LineStyle2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.width = 0;
    _this.alignment = 0.5;
    _this.native = false;
    _this.cap = LINE_CAP.BUTT;
    _this.join = LINE_JOIN.MITER;
    _this.miterLimit = 10;
    return _this;
  }
  LineStyle2.prototype.clone = function() {
    var obj = new LineStyle2();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    obj.width = this.width;
    obj.alignment = this.alignment;
    obj.native = this.native;
    obj.cap = this.cap;
    obj.join = this.join;
    obj.miterLimit = this.miterLimit;
    return obj;
  };
  LineStyle2.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this.color = 0;
    this.alignment = 0.5;
    this.width = 0;
    this.native = false;
  };
  return LineStyle2;
}(FillStyle);
var temp = new Float32Array(3);
var DEFAULT_SHADERS = {};
var Graphics = function(_super) {
  __extends$e(Graphics2, _super);
  function Graphics2(geometry) {
    if (geometry === void 0) {
      geometry = null;
    }
    var _this = _super.call(this) || this;
    _this.shader = null;
    _this.pluginName = "batch";
    _this.currentPath = null;
    _this.batches = [];
    _this.batchTint = -1;
    _this.batchDirty = -1;
    _this.vertexData = null;
    _this._fillStyle = new FillStyle();
    _this._lineStyle = new LineStyle();
    _this._matrix = null;
    _this._holeMode = false;
    _this.state = State.for2d();
    _this._geometry = geometry || new GraphicsGeometry();
    _this._geometry.refCount++;
    _this._transformID = -1;
    _this.tint = 16777215;
    _this.blendMode = BLEND_MODES$3.NORMAL;
    return _this;
  }
  Object.defineProperty(Graphics2.prototype, "geometry", {
    get: function() {
      return this._geometry;
    },
    enumerable: false,
    configurable: true
  });
  Graphics2.prototype.clone = function() {
    this.finishPoly();
    return new Graphics2(this._geometry);
  };
  Object.defineProperty(Graphics2.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    set: function(value) {
      this.state.blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Graphics2.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(value) {
      this._tint = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Graphics2.prototype, "fill", {
    get: function() {
      return this._fillStyle;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Graphics2.prototype, "line", {
    get: function() {
      return this._lineStyle;
    },
    enumerable: false,
    configurable: true
  });
  Graphics2.prototype.lineStyle = function(options, color, alpha, alignment, native) {
    if (options === void 0) {
      options = null;
    }
    if (color === void 0) {
      color = 0;
    }
    if (alpha === void 0) {
      alpha = 1;
    }
    if (alignment === void 0) {
      alignment = 0.5;
    }
    if (native === void 0) {
      native = false;
    }
    if (typeof options === "number") {
      options = { width: options, color, alpha, alignment, native };
    }
    return this.lineTextureStyle(options);
  };
  Graphics2.prototype.lineTextureStyle = function(options) {
    options = Object.assign({
      width: 0,
      texture: Texture.WHITE,
      color: options && options.texture ? 16777215 : 0,
      alpha: 1,
      matrix: null,
      alignment: 0.5,
      native: false,
      cap: LINE_CAP.BUTT,
      join: LINE_JOIN.MITER,
      miterLimit: 10
    }, options);
    if (this.currentPath) {
      this.startPoly();
    }
    var visible = options.width > 0 && options.alpha > 0;
    if (!visible) {
      this._lineStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._lineStyle, { visible }, options);
    }
    return this;
  };
  Graphics2.prototype.startPoly = function() {
    if (this.currentPath) {
      var points = this.currentPath.points;
      var len = this.currentPath.points.length;
      if (len > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = new Polygon();
        this.currentPath.closeStroke = false;
        this.currentPath.points.push(points[len - 2], points[len - 1]);
      }
    } else {
      this.currentPath = new Polygon();
      this.currentPath.closeStroke = false;
    }
  };
  Graphics2.prototype.finishPoly = function() {
    if (this.currentPath) {
      if (this.currentPath.points.length > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = null;
      } else {
        this.currentPath.points.length = 0;
      }
    }
  };
  Graphics2.prototype.moveTo = function(x, y) {
    this.startPoly();
    this.currentPath.points[0] = x;
    this.currentPath.points[1] = y;
    return this;
  };
  Graphics2.prototype.lineTo = function(x, y) {
    if (!this.currentPath) {
      this.moveTo(0, 0);
    }
    var points = this.currentPath.points;
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];
    if (fromX !== x || fromY !== y) {
      points.push(x, y);
    }
    return this;
  };
  Graphics2.prototype._initCurve = function(x, y) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (this.currentPath) {
      if (this.currentPath.points.length === 0) {
        this.currentPath.points = [x, y];
      }
    } else {
      this.moveTo(x, y);
    }
  };
  Graphics2.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY) {
    this._initCurve();
    var points = this.currentPath.points;
    if (points.length === 0) {
      this.moveTo(0, 0);
    }
    QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
    return this;
  };
  Graphics2.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY) {
    this._initCurve();
    BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
    return this;
  };
  Graphics2.prototype.arcTo = function(x1, y1, x2, y2, radius) {
    this._initCurve(x1, y1);
    var points = this.currentPath.points;
    var result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
    if (result) {
      var cx = result.cx, cy = result.cy, radius_1 = result.radius, startAngle = result.startAngle, endAngle = result.endAngle, anticlockwise = result.anticlockwise;
      this.arc(cx, cy, radius_1, startAngle, endAngle, anticlockwise);
    }
    return this;
  };
  Graphics2.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise) {
    if (anticlockwise === void 0) {
      anticlockwise = false;
    }
    if (startAngle === endAngle) {
      return this;
    }
    if (!anticlockwise && endAngle <= startAngle) {
      endAngle += PI_2;
    } else if (anticlockwise && startAngle <= endAngle) {
      startAngle += PI_2;
    }
    var sweep = endAngle - startAngle;
    if (sweep === 0) {
      return this;
    }
    var startX = cx + Math.cos(startAngle) * radius;
    var startY = cy + Math.sin(startAngle) * radius;
    var eps = this._geometry.closePointEps;
    var points = this.currentPath ? this.currentPath.points : null;
    if (points) {
      var xDiff = Math.abs(points[points.length - 2] - startX);
      var yDiff = Math.abs(points[points.length - 1] - startY);
      if (xDiff < eps && yDiff < eps)
        ;
      else {
        points.push(startX, startY);
      }
    } else {
      this.moveTo(startX, startY);
      points = this.currentPath.points;
    }
    ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
    return this;
  };
  Graphics2.prototype.beginFill = function(color, alpha) {
    if (color === void 0) {
      color = 0;
    }
    if (alpha === void 0) {
      alpha = 1;
    }
    return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });
  };
  Graphics2.prototype.beginTextureFill = function(options) {
    options = Object.assign({
      texture: Texture.WHITE,
      color: 16777215,
      alpha: 1,
      matrix: null
    }, options);
    if (this.currentPath) {
      this.startPoly();
    }
    var visible = options.alpha > 0;
    if (!visible) {
      this._fillStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._fillStyle, { visible }, options);
    }
    return this;
  };
  Graphics2.prototype.endFill = function() {
    this.finishPoly();
    this._fillStyle.reset();
    return this;
  };
  Graphics2.prototype.drawRect = function(x, y, width, height) {
    return this.drawShape(new Rectangle(x, y, width, height));
  };
  Graphics2.prototype.drawRoundedRect = function(x, y, width, height, radius) {
    return this.drawShape(new RoundedRectangle(x, y, width, height, radius));
  };
  Graphics2.prototype.drawCircle = function(x, y, radius) {
    return this.drawShape(new Circle(x, y, radius));
  };
  Graphics2.prototype.drawEllipse = function(x, y, width, height) {
    return this.drawShape(new Ellipse(x, y, width, height));
  };
  Graphics2.prototype.drawPolygon = function() {
    var arguments$1 = arguments;
    var path = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      path[_i] = arguments$1[_i];
    }
    var points;
    var closeStroke = true;
    var poly = path[0];
    if (poly.points) {
      closeStroke = poly.closeStroke;
      points = poly.points;
    } else if (Array.isArray(path[0])) {
      points = path[0];
    } else {
      points = path;
    }
    var shape = new Polygon(points);
    shape.closeStroke = closeStroke;
    this.drawShape(shape);
    return this;
  };
  Graphics2.prototype.drawShape = function(shape) {
    if (!this._holeMode) {
      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
    } else {
      this._geometry.drawHole(shape, this._matrix);
    }
    return this;
  };
  Graphics2.prototype.clear = function() {
    this._geometry.clear();
    this._lineStyle.reset();
    this._fillStyle.reset();
    this._boundsID++;
    this._matrix = null;
    this._holeMode = false;
    this.currentPath = null;
    return this;
  };
  Graphics2.prototype.isFastRect = function() {
    var data = this._geometry.graphicsData;
    return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
  };
  Graphics2.prototype._render = function(renderer) {
    this.finishPoly();
    var geometry = this._geometry;
    var hasuint32 = renderer.context.supports.uint32Indices;
    geometry.updateBatches(hasuint32);
    if (geometry.batchable) {
      if (this.batchDirty !== geometry.batchDirty) {
        this._populateBatches();
      }
      this._renderBatched(renderer);
    } else {
      renderer.batch.flush();
      this._renderDirect(renderer);
    }
  };
  Graphics2.prototype._populateBatches = function() {
    var geometry = this._geometry;
    var blendMode = this.blendMode;
    var len = geometry.batches.length;
    this.batchTint = -1;
    this._transformID = -1;
    this.batchDirty = geometry.batchDirty;
    this.batches.length = len;
    this.vertexData = new Float32Array(geometry.points);
    for (var i = 0; i < len; i++) {
      var gI = geometry.batches[i];
      var color = gI.style.color;
      var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      var indices2 = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
      var batch = {
        vertexData,
        blendMode,
        indices: indices2,
        uvs,
        _batchRGB: hex2rgb(color),
        _tintRGB: color,
        _texture: gI.style.texture,
        alpha: gI.style.alpha,
        worldAlpha: 1
      };
      this.batches[i] = batch;
    }
  };
  Graphics2.prototype._renderBatched = function(renderer) {
    if (!this.batches.length) {
      return;
    }
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    this.calculateVertices();
    this.calculateTints();
    for (var i = 0, l = this.batches.length; i < l; i++) {
      var batch = this.batches[i];
      batch.worldAlpha = this.worldAlpha * batch.alpha;
      renderer.plugins[this.pluginName].render(batch);
    }
  };
  Graphics2.prototype._renderDirect = function(renderer) {
    var shader = this._resolveDirectShader(renderer);
    var geometry = this._geometry;
    var tint = this.tint;
    var worldAlpha = this.worldAlpha;
    var uniforms = shader.uniforms;
    var drawCalls = geometry.drawCalls;
    uniforms.translationMatrix = this.transform.worldTransform;
    uniforms.tint[0] = (tint >> 16 & 255) / 255 * worldAlpha;
    uniforms.tint[1] = (tint >> 8 & 255) / 255 * worldAlpha;
    uniforms.tint[2] = (tint & 255) / 255 * worldAlpha;
    uniforms.tint[3] = worldAlpha;
    renderer.shader.bind(shader);
    renderer.geometry.bind(geometry, shader);
    renderer.state.set(this.state);
    for (var i = 0, l = drawCalls.length; i < l; i++) {
      this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);
    }
  };
  Graphics2.prototype._renderDrawCallDirect = function(renderer, drawCall) {
    var texArray = drawCall.texArray, type = drawCall.type, size = drawCall.size, start = drawCall.start;
    var groupTextureCount = texArray.count;
    for (var j = 0; j < groupTextureCount; j++) {
      renderer.texture.bind(texArray.elements[j], j);
    }
    renderer.geometry.draw(type, size, start);
  };
  Graphics2.prototype._resolveDirectShader = function(renderer) {
    var shader = this.shader;
    var pluginName = this.pluginName;
    if (!shader) {
      if (!DEFAULT_SHADERS[pluginName]) {
        var MAX_TEXTURES = renderer.plugins.batch.MAX_TEXTURES;
        var sampleValues = new Int32Array(MAX_TEXTURES);
        for (var i = 0; i < MAX_TEXTURES; i++) {
          sampleValues[i] = i;
        }
        var uniforms = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new Matrix(),
          default: UniformGroup.from({ uSamplers: sampleValues }, true)
        };
        var program = renderer.plugins[pluginName]._shader.program;
        DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);
      }
      shader = DEFAULT_SHADERS[pluginName];
    }
    return shader;
  };
  Graphics2.prototype._calculateBounds = function() {
    this.finishPoly();
    var geometry = this._geometry;
    if (!geometry.graphicsData.length) {
      return;
    }
    var _a2 = geometry.bounds, minX = _a2.minX, minY = _a2.minY, maxX = _a2.maxX, maxY = _a2.maxY;
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  };
  Graphics2.prototype.containsPoint = function(point) {
    this.worldTransform.applyInverse(point, Graphics2._TEMP_POINT);
    return this._geometry.containsPoint(Graphics2._TEMP_POINT);
  };
  Graphics2.prototype.calculateTints = function() {
    if (this.batchTint !== this.tint) {
      this.batchTint = this.tint;
      var tintRGB = hex2rgb(this.tint, temp);
      for (var i = 0; i < this.batches.length; i++) {
        var batch = this.batches[i];
        var batchTint = batch._batchRGB;
        var r = tintRGB[0] * batchTint[0] * 255;
        var g = tintRGB[1] * batchTint[1] * 255;
        var b = tintRGB[2] * batchTint[2] * 255;
        var color = (r << 16) + (g << 8) + (b | 0);
        batch._tintRGB = (color >> 16) + (color & 65280) + ((color & 255) << 16);
      }
    }
  };
  Graphics2.prototype.calculateVertices = function() {
    var wtID = this.transform._worldID;
    if (this._transformID === wtID) {
      return;
    }
    this._transformID = wtID;
    var wt = this.transform.worldTransform;
    var a = wt.a;
    var b = wt.b;
    var c = wt.c;
    var d = wt.d;
    var tx = wt.tx;
    var ty = wt.ty;
    var data = this._geometry.points;
    var vertexData = this.vertexData;
    var count = 0;
    for (var i = 0; i < data.length; i += 2) {
      var x = data[i];
      var y = data[i + 1];
      vertexData[count++] = a * x + c * y + tx;
      vertexData[count++] = d * y + b * x + ty;
    }
  };
  Graphics2.prototype.closePath = function() {
    var currentPath = this.currentPath;
    if (currentPath) {
      currentPath.closeStroke = true;
      this.finishPoly();
    }
    return this;
  };
  Graphics2.prototype.setMatrix = function(matrix) {
    this._matrix = matrix;
    return this;
  };
  Graphics2.prototype.beginHole = function() {
    this.finishPoly();
    this._holeMode = true;
    return this;
  };
  Graphics2.prototype.endHole = function() {
    this.finishPoly();
    this._holeMode = false;
    return this;
  };
  Graphics2.prototype.destroy = function(options) {
    this._geometry.refCount--;
    if (this._geometry.refCount === 0) {
      this._geometry.dispose();
    }
    this._matrix = null;
    this.currentPath = null;
    this._lineStyle.destroy();
    this._lineStyle = null;
    this._fillStyle.destroy();
    this._fillStyle = null;
    this._geometry = null;
    this.shader = null;
    this.vertexData = null;
    this.batches.length = 0;
    this.batches = null;
    _super.prototype.destroy.call(this, options);
  };
  Graphics2._TEMP_POINT = new Point();
  return Graphics2;
}(Container);
/*!
 * @pixi/sprite - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/sprite is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$d = function(d, b) {
  extendStatics$d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$d(d, b);
};
function __extends$d(d, b) {
  extendStatics$d(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var tempPoint$2 = new Point();
var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
var Sprite = function(_super) {
  __extends$d(Sprite2, _super);
  function Sprite2(texture) {
    var _this = _super.call(this) || this;
    _this._anchor = new ObservablePoint(_this._onAnchorUpdate, _this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
    _this._texture = null;
    _this._width = 0;
    _this._height = 0;
    _this._tint = null;
    _this._tintRGB = null;
    _this.tint = 16777215;
    _this.blendMode = BLEND_MODES$3.NORMAL;
    _this._cachedTint = 16777215;
    _this.uvs = null;
    _this.texture = texture || Texture.EMPTY;
    _this.vertexData = new Float32Array(8);
    _this.vertexTrimmedData = null;
    _this._transformID = -1;
    _this._textureID = -1;
    _this._transformTrimmedID = -1;
    _this._textureTrimmedID = -1;
    _this.indices = indices;
    _this.pluginName = "batch";
    _this.isSprite = true;
    _this._roundPixels = settings.ROUND_PIXELS;
    return _this;
  }
  Sprite2.prototype._onTextureUpdate = function() {
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    if (this._width) {
      this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width;
    }
    if (this._height) {
      this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height;
    }
  };
  Sprite2.prototype._onAnchorUpdate = function() {
    this._transformID = -1;
    this._transformTrimmedID = -1;
  };
  Sprite2.prototype.calculateVertices = function() {
    var texture = this._texture;
    if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
      return;
    }
    if (this._textureID !== texture._updateID) {
      this.uvs = this._texture._uvs.uvsFloat32;
    }
    this._transformID = this.transform._worldID;
    this._textureID = texture._updateID;
    var wt = this.transform.worldTransform;
    var a = wt.a;
    var b = wt.b;
    var c = wt.c;
    var d = wt.d;
    var tx = wt.tx;
    var ty = wt.ty;
    var vertexData = this.vertexData;
    var trim = texture.trim;
    var orig = texture.orig;
    var anchor = this._anchor;
    var w0 = 0;
    var w1 = 0;
    var h0 = 0;
    var h1 = 0;
    if (trim) {
      w1 = trim.x - anchor._x * orig.width;
      w0 = w1 + trim.width;
      h1 = trim.y - anchor._y * orig.height;
      h0 = h1 + trim.height;
    } else {
      w1 = -anchor._x * orig.width;
      w0 = w1 + orig.width;
      h1 = -anchor._y * orig.height;
      h0 = h1 + orig.height;
    }
    vertexData[0] = a * w1 + c * h1 + tx;
    vertexData[1] = d * h1 + b * w1 + ty;
    vertexData[2] = a * w0 + c * h1 + tx;
    vertexData[3] = d * h1 + b * w0 + ty;
    vertexData[4] = a * w0 + c * h0 + tx;
    vertexData[5] = d * h0 + b * w0 + ty;
    vertexData[6] = a * w1 + c * h0 + tx;
    vertexData[7] = d * h0 + b * w1 + ty;
    if (this._roundPixels) {
      var resolution = settings.RESOLUTION;
      for (var i = 0; i < vertexData.length; ++i) {
        vertexData[i] = Math.round((vertexData[i] * resolution | 0) / resolution);
      }
    }
  };
  Sprite2.prototype.calculateTrimmedVertices = function() {
    if (!this.vertexTrimmedData) {
      this.vertexTrimmedData = new Float32Array(8);
    } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
      return;
    }
    this._transformTrimmedID = this.transform._worldID;
    this._textureTrimmedID = this._texture._updateID;
    var texture = this._texture;
    var vertexData = this.vertexTrimmedData;
    var orig = texture.orig;
    var anchor = this._anchor;
    var wt = this.transform.worldTransform;
    var a = wt.a;
    var b = wt.b;
    var c = wt.c;
    var d = wt.d;
    var tx = wt.tx;
    var ty = wt.ty;
    var w1 = -anchor._x * orig.width;
    var w0 = w1 + orig.width;
    var h1 = -anchor._y * orig.height;
    var h0 = h1 + orig.height;
    vertexData[0] = a * w1 + c * h1 + tx;
    vertexData[1] = d * h1 + b * w1 + ty;
    vertexData[2] = a * w0 + c * h1 + tx;
    vertexData[3] = d * h1 + b * w0 + ty;
    vertexData[4] = a * w0 + c * h0 + tx;
    vertexData[5] = d * h0 + b * w0 + ty;
    vertexData[6] = a * w1 + c * h0 + tx;
    vertexData[7] = d * h0 + b * w1 + ty;
  };
  Sprite2.prototype._render = function(renderer) {
    this.calculateVertices();
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    renderer.plugins[this.pluginName].render(this);
  };
  Sprite2.prototype._calculateBounds = function() {
    var trim = this._texture.trim;
    var orig = this._texture.orig;
    if (!trim || trim.width === orig.width && trim.height === orig.height) {
      this.calculateVertices();
      this._bounds.addQuad(this.vertexData);
    } else {
      this.calculateTrimmedVertices();
      this._bounds.addQuad(this.vertexTrimmedData);
    }
  };
  Sprite2.prototype.getLocalBounds = function(rect) {
    if (this.children.length === 0) {
      if (!this._localBounds) {
        this._localBounds = new Bounds();
      }
      this._localBounds.minX = this._texture.orig.width * -this._anchor._x;
      this._localBounds.minY = this._texture.orig.height * -this._anchor._y;
      this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
      this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._localBounds.getRectangle(rect);
    }
    return _super.prototype.getLocalBounds.call(this, rect);
  };
  Sprite2.prototype.containsPoint = function(point) {
    this.worldTransform.applyInverse(point, tempPoint$2);
    var width = this._texture.orig.width;
    var height = this._texture.orig.height;
    var x1 = -width * this.anchor.x;
    var y1 = 0;
    if (tempPoint$2.x >= x1 && tempPoint$2.x < x1 + width) {
      y1 = -height * this.anchor.y;
      if (tempPoint$2.y >= y1 && tempPoint$2.y < y1 + height) {
        return true;
      }
    }
    return false;
  };
  Sprite2.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this, options);
    this._texture.off("update", this._onTextureUpdate, this);
    this._anchor = null;
    var destroyTexture = typeof options === "boolean" ? options : options && options.texture;
    if (destroyTexture) {
      var destroyBaseTexture = typeof options === "boolean" ? options : options && options.baseTexture;
      this._texture.destroy(!!destroyBaseTexture);
    }
    this._texture = null;
  };
  Sprite2.from = function(source, options) {
    var texture = source instanceof Texture ? source : Texture.from(source, options);
    return new Sprite2(texture);
  };
  Object.defineProperty(Sprite2.prototype, "roundPixels", {
    get: function() {
      return this._roundPixels;
    },
    set: function(value) {
      if (this._roundPixels !== value) {
        this._transformID = -1;
      }
      this._roundPixels = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "width", {
    get: function() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    },
    set: function(value) {
      var s = sign(this.scale.x) || 1;
      this.scale.x = s * value / this._texture.orig.width;
      this._width = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "height", {
    get: function() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    },
    set: function(value) {
      var s = sign(this.scale.y) || 1;
      this.scale.y = s * value / this._texture.orig.height;
      this._height = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "anchor", {
    get: function() {
      return this._anchor;
    },
    set: function(value) {
      this._anchor.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(value) {
      this._tint = value;
      this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "texture", {
    get: function() {
      return this._texture;
    },
    set: function(value) {
      if (this._texture === value) {
        return;
      }
      if (this._texture) {
        this._texture.off("update", this._onTextureUpdate, this);
      }
      this._texture = value || Texture.EMPTY;
      this._cachedTint = 16777215;
      this._textureID = -1;
      this._textureTrimmedID = -1;
      if (value) {
        if (value.baseTexture.valid) {
          this._onTextureUpdate();
        } else {
          value.once("update", this._onTextureUpdate, this);
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  return Sprite2;
}(Container);
/*!
 * @pixi/text - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/text is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$c = function(d, b) {
  extendStatics$c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$c(d, b);
};
function __extends$c(d, b) {
  extendStatics$c(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var TEXT_GRADIENT;
(function(TEXT_GRADIENT2) {
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
})(TEXT_GRADIENT || (TEXT_GRADIENT = {}));
var defaultStyle = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: false,
  whiteSpace: "pre",
  wordWrap: false,
  wordWrapWidth: 100,
  leading: 0
};
var genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
var TextStyle = function() {
  function TextStyle2(style) {
    this.styleID = 0;
    this.reset();
    deepCopyProperties(this, style, style);
  }
  TextStyle2.prototype.clone = function() {
    var clonedProperties = {};
    deepCopyProperties(clonedProperties, this, defaultStyle);
    return new TextStyle2(clonedProperties);
  };
  TextStyle2.prototype.reset = function() {
    deepCopyProperties(this, defaultStyle, defaultStyle);
  };
  Object.defineProperty(TextStyle2.prototype, "align", {
    get: function() {
      return this._align;
    },
    set: function(align) {
      if (this._align !== align) {
        this._align = align;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "breakWords", {
    get: function() {
      return this._breakWords;
    },
    set: function(breakWords) {
      if (this._breakWords !== breakWords) {
        this._breakWords = breakWords;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadow", {
    get: function() {
      return this._dropShadow;
    },
    set: function(dropShadow) {
      if (this._dropShadow !== dropShadow) {
        this._dropShadow = dropShadow;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowAlpha", {
    get: function() {
      return this._dropShadowAlpha;
    },
    set: function(dropShadowAlpha) {
      if (this._dropShadowAlpha !== dropShadowAlpha) {
        this._dropShadowAlpha = dropShadowAlpha;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowAngle", {
    get: function() {
      return this._dropShadowAngle;
    },
    set: function(dropShadowAngle) {
      if (this._dropShadowAngle !== dropShadowAngle) {
        this._dropShadowAngle = dropShadowAngle;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowBlur", {
    get: function() {
      return this._dropShadowBlur;
    },
    set: function(dropShadowBlur) {
      if (this._dropShadowBlur !== dropShadowBlur) {
        this._dropShadowBlur = dropShadowBlur;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowColor", {
    get: function() {
      return this._dropShadowColor;
    },
    set: function(dropShadowColor) {
      var outputColor = getColor(dropShadowColor);
      if (this._dropShadowColor !== outputColor) {
        this._dropShadowColor = outputColor;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowDistance", {
    get: function() {
      return this._dropShadowDistance;
    },
    set: function(dropShadowDistance) {
      if (this._dropShadowDistance !== dropShadowDistance) {
        this._dropShadowDistance = dropShadowDistance;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fill", {
    get: function() {
      return this._fill;
    },
    set: function(fill) {
      var outputColor = getColor(fill);
      if (this._fill !== outputColor) {
        this._fill = outputColor;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fillGradientType", {
    get: function() {
      return this._fillGradientType;
    },
    set: function(fillGradientType) {
      if (this._fillGradientType !== fillGradientType) {
        this._fillGradientType = fillGradientType;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fillGradientStops", {
    get: function() {
      return this._fillGradientStops;
    },
    set: function(fillGradientStops) {
      if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
        this._fillGradientStops = fillGradientStops;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontFamily", {
    get: function() {
      return this._fontFamily;
    },
    set: function(fontFamily) {
      if (this.fontFamily !== fontFamily) {
        this._fontFamily = fontFamily;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontSize", {
    get: function() {
      return this._fontSize;
    },
    set: function(fontSize) {
      if (this._fontSize !== fontSize) {
        this._fontSize = fontSize;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontStyle", {
    get: function() {
      return this._fontStyle;
    },
    set: function(fontStyle) {
      if (this._fontStyle !== fontStyle) {
        this._fontStyle = fontStyle;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontVariant", {
    get: function() {
      return this._fontVariant;
    },
    set: function(fontVariant) {
      if (this._fontVariant !== fontVariant) {
        this._fontVariant = fontVariant;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontWeight", {
    get: function() {
      return this._fontWeight;
    },
    set: function(fontWeight) {
      if (this._fontWeight !== fontWeight) {
        this._fontWeight = fontWeight;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "letterSpacing", {
    get: function() {
      return this._letterSpacing;
    },
    set: function(letterSpacing) {
      if (this._letterSpacing !== letterSpacing) {
        this._letterSpacing = letterSpacing;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "lineHeight", {
    get: function() {
      return this._lineHeight;
    },
    set: function(lineHeight) {
      if (this._lineHeight !== lineHeight) {
        this._lineHeight = lineHeight;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "leading", {
    get: function() {
      return this._leading;
    },
    set: function(leading) {
      if (this._leading !== leading) {
        this._leading = leading;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "lineJoin", {
    get: function() {
      return this._lineJoin;
    },
    set: function(lineJoin) {
      if (this._lineJoin !== lineJoin) {
        this._lineJoin = lineJoin;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "miterLimit", {
    get: function() {
      return this._miterLimit;
    },
    set: function(miterLimit) {
      if (this._miterLimit !== miterLimit) {
        this._miterLimit = miterLimit;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "padding", {
    get: function() {
      return this._padding;
    },
    set: function(padding) {
      if (this._padding !== padding) {
        this._padding = padding;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "stroke", {
    get: function() {
      return this._stroke;
    },
    set: function(stroke) {
      var outputColor = getColor(stroke);
      if (this._stroke !== outputColor) {
        this._stroke = outputColor;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "strokeThickness", {
    get: function() {
      return this._strokeThickness;
    },
    set: function(strokeThickness) {
      if (this._strokeThickness !== strokeThickness) {
        this._strokeThickness = strokeThickness;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "textBaseline", {
    get: function() {
      return this._textBaseline;
    },
    set: function(textBaseline) {
      if (this._textBaseline !== textBaseline) {
        this._textBaseline = textBaseline;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "trim", {
    get: function() {
      return this._trim;
    },
    set: function(trim) {
      if (this._trim !== trim) {
        this._trim = trim;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "whiteSpace", {
    get: function() {
      return this._whiteSpace;
    },
    set: function(whiteSpace) {
      if (this._whiteSpace !== whiteSpace) {
        this._whiteSpace = whiteSpace;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "wordWrap", {
    get: function() {
      return this._wordWrap;
    },
    set: function(wordWrap) {
      if (this._wordWrap !== wordWrap) {
        this._wordWrap = wordWrap;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "wordWrapWidth", {
    get: function() {
      return this._wordWrapWidth;
    },
    set: function(wordWrapWidth) {
      if (this._wordWrapWidth !== wordWrapWidth) {
        this._wordWrapWidth = wordWrapWidth;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  TextStyle2.prototype.toFontString = function() {
    var fontSizeString = typeof this.fontSize === "number" ? this.fontSize + "px" : this.fontSize;
    var fontFamilies = this.fontFamily;
    if (!Array.isArray(this.fontFamily)) {
      fontFamilies = this.fontFamily.split(",");
    }
    for (var i = fontFamilies.length - 1; i >= 0; i--) {
      var fontFamily = fontFamilies[i].trim();
      if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && genericFontFamilies.indexOf(fontFamily) < 0) {
        fontFamily = '"' + fontFamily + '"';
      }
      fontFamilies[i] = fontFamily;
    }
    return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + fontSizeString + " " + fontFamilies.join(",");
  };
  return TextStyle2;
}();
function getSingleColor(color) {
  if (typeof color === "number") {
    return hex2string(color);
  } else if (typeof color === "string") {
    if (color.indexOf("0x") === 0) {
      color = color.replace("0x", "#");
    }
  }
  return color;
}
function getColor(color) {
  if (!Array.isArray(color)) {
    return getSingleColor(color);
  } else {
    for (var i = 0; i < color.length; ++i) {
      color[i] = getSingleColor(color[i]);
    }
    return color;
  }
}
function areArraysEqual(array1, array2) {
  if (!Array.isArray(array1) || !Array.isArray(array2)) {
    return false;
  }
  if (array1.length !== array2.length) {
    return false;
  }
  for (var i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function deepCopyProperties(target, source, propertyObj) {
  for (var prop in propertyObj) {
    if (Array.isArray(source[prop])) {
      target[prop] = source[prop].slice();
    } else {
      target[prop] = source[prop];
    }
  }
}
var TextMetrics = function() {
  function TextMetrics2(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
    this.text = text;
    this.style = style;
    this.width = width;
    this.height = height;
    this.lines = lines;
    this.lineWidths = lineWidths;
    this.lineHeight = lineHeight;
    this.maxLineWidth = maxLineWidth;
    this.fontProperties = fontProperties;
  }
  TextMetrics2.measureText = function(text, style, wordWrap, canvas2) {
    if (canvas2 === void 0) {
      canvas2 = TextMetrics2._canvas;
    }
    wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
    var font = style.toFontString();
    var fontProperties = TextMetrics2.measureFont(font);
    if (fontProperties.fontSize === 0) {
      fontProperties.fontSize = style.fontSize;
      fontProperties.ascent = style.fontSize;
    }
    var context2 = canvas2.getContext("2d");
    context2.font = font;
    var outputText = wordWrap ? TextMetrics2.wordWrap(text, style, canvas2) : text;
    var lines = outputText.split(/(?:\r\n|\r|\n)/);
    var lineWidths = new Array(lines.length);
    var maxLineWidth = 0;
    for (var i = 0; i < lines.length; i++) {
      var lineWidth = context2.measureText(lines[i]).width + (lines[i].length - 1) * style.letterSpacing;
      lineWidths[i] = lineWidth;
      maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    var width = maxLineWidth + style.strokeThickness;
    if (style.dropShadow) {
      width += style.dropShadowDistance;
    }
    var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
    var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) + (lines.length - 1) * (lineHeight + style.leading);
    if (style.dropShadow) {
      height += style.dropShadowDistance;
    }
    return new TextMetrics2(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
  };
  TextMetrics2.wordWrap = function(text, style, canvas2) {
    if (canvas2 === void 0) {
      canvas2 = TextMetrics2._canvas;
    }
    var context2 = canvas2.getContext("2d");
    var width = 0;
    var line = "";
    var lines = "";
    var cache = /* @__PURE__ */ Object.create(null);
    var letterSpacing = style.letterSpacing, whiteSpace = style.whiteSpace;
    var collapseSpaces = TextMetrics2.collapseSpaces(whiteSpace);
    var collapseNewlines = TextMetrics2.collapseNewlines(whiteSpace);
    var canPrependSpaces = !collapseSpaces;
    var wordWrapWidth = style.wordWrapWidth + letterSpacing;
    var tokens = TextMetrics2.tokenize(text);
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      if (TextMetrics2.isNewline(token)) {
        if (!collapseNewlines) {
          lines += TextMetrics2.addLine(line);
          canPrependSpaces = !collapseSpaces;
          line = "";
          width = 0;
          continue;
        }
        token = " ";
      }
      if (collapseSpaces) {
        var currIsBreakingSpace = TextMetrics2.isBreakingSpace(token);
        var lastIsBreakingSpace = TextMetrics2.isBreakingSpace(line[line.length - 1]);
        if (currIsBreakingSpace && lastIsBreakingSpace) {
          continue;
        }
      }
      var tokenWidth = TextMetrics2.getFromCache(token, letterSpacing, cache, context2);
      if (tokenWidth > wordWrapWidth) {
        if (line !== "") {
          lines += TextMetrics2.addLine(line);
          line = "";
          width = 0;
        }
        if (TextMetrics2.canBreakWords(token, style.breakWords)) {
          var characters = TextMetrics2.wordWrapSplit(token);
          for (var j = 0; j < characters.length; j++) {
            var char = characters[j];
            var k = 1;
            while (characters[j + k]) {
              var nextChar = characters[j + k];
              var lastChar = char[char.length - 1];
              if (!TextMetrics2.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                char += nextChar;
              } else {
                break;
              }
              k++;
            }
            j += char.length - 1;
            var characterWidth = TextMetrics2.getFromCache(char, letterSpacing, cache, context2);
            if (characterWidth + width > wordWrapWidth) {
              lines += TextMetrics2.addLine(line);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
            line += char;
            width += characterWidth;
          }
        } else {
          if (line.length > 0) {
            lines += TextMetrics2.addLine(line);
            line = "";
            width = 0;
          }
          var isLastToken = i === tokens.length - 1;
          lines += TextMetrics2.addLine(token, !isLastToken);
          canPrependSpaces = false;
          line = "";
          width = 0;
        }
      } else {
        if (tokenWidth + width > wordWrapWidth) {
          canPrependSpaces = false;
          lines += TextMetrics2.addLine(line);
          line = "";
          width = 0;
        }
        if (line.length > 0 || !TextMetrics2.isBreakingSpace(token) || canPrependSpaces) {
          line += token;
          width += tokenWidth;
        }
      }
    }
    lines += TextMetrics2.addLine(line, false);
    return lines;
  };
  TextMetrics2.addLine = function(line, newLine) {
    if (newLine === void 0) {
      newLine = true;
    }
    line = TextMetrics2.trimRight(line);
    line = newLine ? line + "\n" : line;
    return line;
  };
  TextMetrics2.getFromCache = function(key, letterSpacing, cache, context2) {
    var width = cache[key];
    if (typeof width !== "number") {
      var spacing = key.length * letterSpacing;
      width = context2.measureText(key).width + spacing;
      cache[key] = width;
    }
    return width;
  };
  TextMetrics2.collapseSpaces = function(whiteSpace) {
    return whiteSpace === "normal" || whiteSpace === "pre-line";
  };
  TextMetrics2.collapseNewlines = function(whiteSpace) {
    return whiteSpace === "normal";
  };
  TextMetrics2.trimRight = function(text) {
    if (typeof text !== "string") {
      return "";
    }
    for (var i = text.length - 1; i >= 0; i--) {
      var char = text[i];
      if (!TextMetrics2.isBreakingSpace(char)) {
        break;
      }
      text = text.slice(0, -1);
    }
    return text;
  };
  TextMetrics2.isNewline = function(char) {
    if (typeof char !== "string") {
      return false;
    }
    return TextMetrics2._newlines.indexOf(char.charCodeAt(0)) >= 0;
  };
  TextMetrics2.isBreakingSpace = function(char, _nextChar) {
    if (typeof char !== "string") {
      return false;
    }
    return TextMetrics2._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0;
  };
  TextMetrics2.tokenize = function(text) {
    var tokens = [];
    var token = "";
    if (typeof text !== "string") {
      return tokens;
    }
    for (var i = 0; i < text.length; i++) {
      var char = text[i];
      var nextChar = text[i + 1];
      if (TextMetrics2.isBreakingSpace(char, nextChar) || TextMetrics2.isNewline(char)) {
        if (token !== "") {
          tokens.push(token);
          token = "";
        }
        tokens.push(char);
        continue;
      }
      token += char;
    }
    if (token !== "") {
      tokens.push(token);
    }
    return tokens;
  };
  TextMetrics2.canBreakWords = function(_token, breakWords) {
    return breakWords;
  };
  TextMetrics2.canBreakChars = function(_char, _nextChar, _token, _index, _breakWords) {
    return true;
  };
  TextMetrics2.wordWrapSplit = function(token) {
    return token.split("");
  };
  TextMetrics2.measureFont = function(font) {
    if (TextMetrics2._fonts[font]) {
      return TextMetrics2._fonts[font];
    }
    var properties = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    };
    var canvas2 = TextMetrics2._canvas;
    var context2 = TextMetrics2._context;
    context2.font = font;
    var metricsString = TextMetrics2.METRICS_STRING + TextMetrics2.BASELINE_SYMBOL;
    var width = Math.ceil(context2.measureText(metricsString).width);
    var baseline = Math.ceil(context2.measureText(TextMetrics2.BASELINE_SYMBOL).width);
    var height = Math.ceil(TextMetrics2.HEIGHT_MULTIPLIER * baseline);
    baseline = baseline * TextMetrics2.BASELINE_MULTIPLIER | 0;
    canvas2.width = width;
    canvas2.height = height;
    context2.fillStyle = "#f00";
    context2.fillRect(0, 0, width, height);
    context2.font = font;
    context2.textBaseline = "alphabetic";
    context2.fillStyle = "#000";
    context2.fillText(metricsString, 0, baseline);
    var imagedata = context2.getImageData(0, 0, width, height).data;
    var pixels = imagedata.length;
    var line = width * 4;
    var i = 0;
    var idx = 0;
    var stop = false;
    for (i = 0; i < baseline; ++i) {
      for (var j = 0; j < line; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx += line;
      } else {
        break;
      }
    }
    properties.ascent = baseline - i;
    idx = pixels - line;
    stop = false;
    for (i = height; i > baseline; --i) {
      for (var j = 0; j < line; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx -= line;
      } else {
        break;
      }
    }
    properties.descent = i - baseline;
    properties.fontSize = properties.ascent + properties.descent;
    TextMetrics2._fonts[font] = properties;
    return properties;
  };
  TextMetrics2.clearMetrics = function(font) {
    if (font === void 0) {
      font = "";
    }
    if (font) {
      delete TextMetrics2._fonts[font];
    } else {
      TextMetrics2._fonts = {};
    }
  };
  return TextMetrics2;
}();
var canvas = function() {
  try {
    var c = new OffscreenCanvas(0, 0);
    var context2 = c.getContext("2d");
    if (context2 && context2.measureText) {
      return c;
    }
    return document.createElement("canvas");
  } catch (ex) {
    return document.createElement("canvas");
  }
}();
canvas.width = canvas.height = 10;
TextMetrics._canvas = canvas;
TextMetrics._context = canvas.getContext("2d");
TextMetrics._fonts = {};
TextMetrics.METRICS_STRING = "|\xC9q\xC5";
TextMetrics.BASELINE_SYMBOL = "M";
TextMetrics.BASELINE_MULTIPLIER = 1.4;
TextMetrics.HEIGHT_MULTIPLIER = 2;
TextMetrics._newlines = [
  10,
  13
];
TextMetrics._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];
var defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
var Text = function(_super) {
  __extends$c(Text2, _super);
  function Text2(text, style, canvas2) {
    var _this = this;
    var ownCanvas = false;
    if (!canvas2) {
      canvas2 = document.createElement("canvas");
      ownCanvas = true;
    }
    canvas2.width = 3;
    canvas2.height = 3;
    var texture = Texture.from(canvas2);
    texture.orig = new Rectangle();
    texture.trim = new Rectangle();
    _this = _super.call(this, texture) || this;
    _this._ownCanvas = ownCanvas;
    _this.canvas = canvas2;
    _this.context = _this.canvas.getContext("2d");
    _this._resolution = settings.RESOLUTION;
    _this._autoResolution = true;
    _this._text = null;
    _this._style = null;
    _this._styleListener = null;
    _this._font = "";
    _this.text = text;
    _this.style = style;
    _this.localStyleID = -1;
    return _this;
  }
  Text2.prototype.updateText = function(respectDirty) {
    var style = this._style;
    if (this.localStyleID !== style.styleID) {
      this.dirty = true;
      this.localStyleID = style.styleID;
    }
    if (!this.dirty && respectDirty) {
      return;
    }
    this._font = this._style.toFontString();
    var context2 = this.context;
    var measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
    var width = measured.width;
    var height = measured.height;
    var lines = measured.lines;
    var lineHeight = measured.lineHeight;
    var lineWidths = measured.lineWidths;
    var maxLineWidth = measured.maxLineWidth;
    var fontProperties = measured.fontProperties;
    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);
    this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);
    context2.scale(this._resolution, this._resolution);
    context2.clearRect(0, 0, this.canvas.width, this.canvas.height);
    context2.font = this._font;
    context2.lineWidth = style.strokeThickness;
    context2.textBaseline = style.textBaseline;
    context2.lineJoin = style.lineJoin;
    context2.miterLimit = style.miterLimit;
    var linePositionX;
    var linePositionY;
    var passesCount = style.dropShadow ? 2 : 1;
    for (var i = 0; i < passesCount; ++i) {
      var isShadowPass = style.dropShadow && i === 0;
      var dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
      var dsOffsetShadow = dsOffsetText * this._resolution;
      if (isShadowPass) {
        context2.fillStyle = "black";
        context2.strokeStyle = "black";
        var dropShadowColor = style.dropShadowColor;
        var rgb = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
        var dropShadowBlur = style.dropShadowBlur * this._resolution;
        var dropShadowDistance = style.dropShadowDistance * this._resolution;
        context2.shadowColor = "rgba(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + "," + style.dropShadowAlpha + ")";
        context2.shadowBlur = dropShadowBlur;
        context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
        context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
      } else {
        context2.fillStyle = this._generateFillStyle(style, lines, measured);
        context2.strokeStyle = style.stroke;
        context2.shadowColor = "black";
        context2.shadowBlur = 0;
        context2.shadowOffsetX = 0;
        context2.shadowOffsetY = 0;
      }
      var linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
      if (!Text2.nextLineHeightBehavior || lineHeight - fontProperties.fontSize < 0) {
        linePositionYShift = 0;
      }
      for (var i_1 = 0; i_1 < lines.length; i_1++) {
        linePositionX = style.strokeThickness / 2;
        linePositionY = style.strokeThickness / 2 + i_1 * lineHeight + fontProperties.ascent + linePositionYShift;
        if (style.align === "right") {
          linePositionX += maxLineWidth - lineWidths[i_1];
        } else if (style.align === "center") {
          linePositionX += (maxLineWidth - lineWidths[i_1]) / 2;
        }
        if (style.stroke && style.strokeThickness) {
          this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
        }
        if (style.fill) {
          this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
        }
      }
    }
    this.updateTexture();
  };
  Text2.prototype.drawLetterSpacing = function(text, x, y, isStroke) {
    if (isStroke === void 0) {
      isStroke = false;
    }
    var style = this._style;
    var letterSpacing = style.letterSpacing;
    var supportLetterSpacing = "letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype;
    if (letterSpacing === 0 || supportLetterSpacing) {
      if (supportLetterSpacing) {
        this.context.letterSpacing = letterSpacing;
        this.context.textLetterSpacing = letterSpacing;
      }
      if (isStroke) {
        this.context.strokeText(text, x, y);
      } else {
        this.context.fillText(text, x, y);
      }
      return;
    }
    var currentPosition = x;
    var stringArray = Array.from ? Array.from(text) : text.split("");
    var previousWidth = this.context.measureText(text).width;
    var currentWidth = 0;
    for (var i = 0; i < stringArray.length; ++i) {
      var currentChar = stringArray[i];
      if (isStroke) {
        this.context.strokeText(currentChar, currentPosition, y);
      } else {
        this.context.fillText(currentChar, currentPosition, y);
      }
      var textStr = "";
      for (var j = i + 1; j < stringArray.length; ++j) {
        textStr += stringArray[j];
      }
      currentWidth = this.context.measureText(textStr).width;
      currentPosition += previousWidth - currentWidth + letterSpacing;
      previousWidth = currentWidth;
    }
  };
  Text2.prototype.updateTexture = function() {
    var canvas2 = this.canvas;
    if (this._style.trim) {
      var trimmed = trimCanvas(canvas2);
      if (trimmed.data) {
        canvas2.width = trimmed.width;
        canvas2.height = trimmed.height;
        this.context.putImageData(trimmed.data, 0, 0);
      }
    }
    var texture = this._texture;
    var style = this._style;
    var padding = style.trim ? 0 : style.padding;
    var baseTexture = texture.baseTexture;
    texture.trim.width = texture._frame.width = canvas2.width / this._resolution;
    texture.trim.height = texture._frame.height = canvas2.height / this._resolution;
    texture.trim.x = -padding;
    texture.trim.y = -padding;
    texture.orig.width = texture._frame.width - padding * 2;
    texture.orig.height = texture._frame.height - padding * 2;
    this._onTextureUpdate();
    baseTexture.setRealSize(canvas2.width, canvas2.height, this._resolution);
    texture.updateUvs();
    this._recursivePostUpdateTransform();
    this.dirty = false;
  };
  Text2.prototype._render = function(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    _super.prototype._render.call(this, renderer);
  };
  Text2.prototype.getLocalBounds = function(rect) {
    this.updateText(true);
    return _super.prototype.getLocalBounds.call(this, rect);
  };
  Text2.prototype._calculateBounds = function() {
    this.updateText(true);
    this.calculateVertices();
    this._bounds.addQuad(this.vertexData);
  };
  Text2.prototype._generateFillStyle = function(style, lines, metrics) {
    var fillStyle = style.fill;
    if (!Array.isArray(fillStyle)) {
      return fillStyle;
    } else if (fillStyle.length === 1) {
      return fillStyle[0];
    }
    var gradient;
    var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
    var padding = style.padding || 0;
    var width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;
    var height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;
    var fill = fillStyle.slice();
    var fillGradientStops = style.fillGradientStops.slice();
    if (!fillGradientStops.length) {
      var lengthPlus1 = fill.length + 1;
      for (var i = 1; i < lengthPlus1; ++i) {
        fillGradientStops.push(i / lengthPlus1);
      }
    }
    fill.unshift(fillStyle[0]);
    fillGradientStops.unshift(0);
    fill.push(fillStyle[fillStyle.length - 1]);
    fillGradientStops.push(1);
    if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
      gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
      var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
      for (var i = 0; i < lines.length; i++) {
        var lastLineBottom = metrics.lineHeight * (i - 1) + textHeight;
        var thisLineTop = metrics.lineHeight * i;
        var thisLineGradientStart = thisLineTop;
        if (i > 0 && lastLineBottom > thisLineTop) {
          thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;
        }
        var thisLineBottom = thisLineTop + textHeight;
        var nextLineTop = metrics.lineHeight * (i + 1);
        var thisLineGradientEnd = thisLineBottom;
        if (i + 1 < lines.length && nextLineTop < thisLineBottom) {
          thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;
        }
        var gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
        for (var j = 0; j < fill.length; j++) {
          var lineStop = 0;
          if (typeof fillGradientStops[j] === "number") {
            lineStop = fillGradientStops[j];
          } else {
            lineStop = j / fill.length;
          }
          var globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));
          globalStop = Number(globalStop.toFixed(5));
          gradient.addColorStop(globalStop, fill[j]);
        }
      }
    } else {
      gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
      var totalIterations = fill.length + 1;
      var currentIteration = 1;
      for (var i = 0; i < fill.length; i++) {
        var stop = void 0;
        if (typeof fillGradientStops[i] === "number") {
          stop = fillGradientStops[i];
        } else {
          stop = currentIteration / totalIterations;
        }
        gradient.addColorStop(stop, fill[i]);
        currentIteration++;
      }
    }
    return gradient;
  };
  Text2.prototype.destroy = function(options) {
    if (typeof options === "boolean") {
      options = { children: options };
    }
    options = Object.assign({}, defaultDestroyOptions, options);
    _super.prototype.destroy.call(this, options);
    if (this._ownCanvas) {
      this.canvas.height = this.canvas.width = 0;
    }
    this.context = null;
    this.canvas = null;
    this._style = null;
  };
  Object.defineProperty(Text2.prototype, "width", {
    get: function() {
      this.updateText(true);
      return Math.abs(this.scale.x) * this._texture.orig.width;
    },
    set: function(value) {
      this.updateText(true);
      var s = sign(this.scale.x) || 1;
      this.scale.x = s * value / this._texture.orig.width;
      this._width = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Text2.prototype, "height", {
    get: function() {
      this.updateText(true);
      return Math.abs(this.scale.y) * this._texture.orig.height;
    },
    set: function(value) {
      this.updateText(true);
      var s = sign(this.scale.y) || 1;
      this.scale.y = s * value / this._texture.orig.height;
      this._height = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Text2.prototype, "style", {
    get: function() {
      return this._style;
    },
    set: function(style) {
      style = style || {};
      if (style instanceof TextStyle) {
        this._style = style;
      } else {
        this._style = new TextStyle(style);
      }
      this.localStyleID = -1;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Text2.prototype, "text", {
    get: function() {
      return this._text;
    },
    set: function(text) {
      text = String(text === null || text === void 0 ? "" : text);
      if (this._text === text) {
        return;
      }
      this._text = text;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Text2.prototype, "resolution", {
    get: function() {
      return this._resolution;
    },
    set: function(value) {
      this._autoResolution = false;
      if (this._resolution === value) {
        return;
      }
      this._resolution = value;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Text2.nextLineHeightBehavior = false;
  return Text2;
}(Sprite);
/*!
 * @pixi/prepare - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/prepare is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.UPLOADS_PER_FRAME = 4;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$b = function(d, b) {
  extendStatics$b = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$b(d, b);
};
function __extends$b(d, b) {
  extendStatics$b(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var CountLimiter = function() {
  function CountLimiter2(maxItemsPerFrame) {
    this.maxItemsPerFrame = maxItemsPerFrame;
    this.itemsLeft = 0;
  }
  CountLimiter2.prototype.beginFrame = function() {
    this.itemsLeft = this.maxItemsPerFrame;
  };
  CountLimiter2.prototype.allowedToUpload = function() {
    return this.itemsLeft-- > 0;
  };
  return CountLimiter2;
}();
function findMultipleBaseTextures(item, queue) {
  var result = false;
  if (item && item._textures && item._textures.length) {
    for (var i = 0; i < item._textures.length; i++) {
      if (item._textures[i] instanceof Texture) {
        var baseTexture = item._textures[i].baseTexture;
        if (queue.indexOf(baseTexture) === -1) {
          queue.push(baseTexture);
          result = true;
        }
      }
    }
  }
  return result;
}
function findBaseTexture(item, queue) {
  if (item.baseTexture instanceof BaseTexture) {
    var texture = item.baseTexture;
    if (queue.indexOf(texture) === -1) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function findTexture(item, queue) {
  if (item._texture && item._texture instanceof Texture) {
    var texture = item._texture.baseTexture;
    if (queue.indexOf(texture) === -1) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function drawText(_helper, item) {
  if (item instanceof Text) {
    item.updateText(true);
    return true;
  }
  return false;
}
function calculateTextStyle(_helper, item) {
  if (item instanceof TextStyle) {
    var font = item.toFontString();
    TextMetrics.measureFont(font);
    return true;
  }
  return false;
}
function findText(item, queue) {
  if (item instanceof Text) {
    if (queue.indexOf(item.style) === -1) {
      queue.push(item.style);
    }
    if (queue.indexOf(item) === -1) {
      queue.push(item);
    }
    var texture = item._texture.baseTexture;
    if (queue.indexOf(texture) === -1) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function findTextStyle(item, queue) {
  if (item instanceof TextStyle) {
    if (queue.indexOf(item) === -1) {
      queue.push(item);
    }
    return true;
  }
  return false;
}
var BasePrepare = function() {
  function BasePrepare2(renderer) {
    var _this = this;
    this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME);
    this.renderer = renderer;
    this.uploadHookHelper = null;
    this.queue = [];
    this.addHooks = [];
    this.uploadHooks = [];
    this.completes = [];
    this.ticking = false;
    this.delayedTick = function() {
      if (!_this.queue) {
        return;
      }
      _this.prepareItems();
    };
    this.registerFindHook(findText);
    this.registerFindHook(findTextStyle);
    this.registerFindHook(findMultipleBaseTextures);
    this.registerFindHook(findBaseTexture);
    this.registerFindHook(findTexture);
    this.registerUploadHook(drawText);
    this.registerUploadHook(calculateTextStyle);
  }
  BasePrepare2.prototype.upload = function(item, done) {
    if (typeof item === "function") {
      done = item;
      item = null;
    }
    if (item) {
      this.add(item);
    }
    if (this.queue.length) {
      if (done) {
        this.completes.push(done);
      }
      if (!this.ticking) {
        this.ticking = true;
        Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
      }
    } else if (done) {
      done();
    }
  };
  BasePrepare2.prototype.tick = function() {
    setTimeout(this.delayedTick, 0);
  };
  BasePrepare2.prototype.prepareItems = function() {
    this.limiter.beginFrame();
    while (this.queue.length && this.limiter.allowedToUpload()) {
      var item = this.queue[0];
      var uploaded = false;
      if (item && !item._destroyed) {
        for (var i = 0, len = this.uploadHooks.length; i < len; i++) {
          if (this.uploadHooks[i](this.uploadHookHelper, item)) {
            this.queue.shift();
            uploaded = true;
            break;
          }
        }
      }
      if (!uploaded) {
        this.queue.shift();
      }
    }
    if (!this.queue.length) {
      this.ticking = false;
      var completes = this.completes.slice(0);
      this.completes.length = 0;
      for (var i = 0, len = completes.length; i < len; i++) {
        completes[i]();
      }
    } else {
      Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
    }
  };
  BasePrepare2.prototype.registerFindHook = function(addHook) {
    if (addHook) {
      this.addHooks.push(addHook);
    }
    return this;
  };
  BasePrepare2.prototype.registerUploadHook = function(uploadHook) {
    if (uploadHook) {
      this.uploadHooks.push(uploadHook);
    }
    return this;
  };
  BasePrepare2.prototype.add = function(item) {
    for (var i = 0, len = this.addHooks.length; i < len; i++) {
      if (this.addHooks[i](item, this.queue)) {
        break;
      }
    }
    if (item instanceof Container) {
      for (var i = item.children.length - 1; i >= 0; i--) {
        this.add(item.children[i]);
      }
    }
    return this;
  };
  BasePrepare2.prototype.destroy = function() {
    if (this.ticking) {
      Ticker.system.remove(this.tick, this);
    }
    this.ticking = false;
    this.addHooks = null;
    this.uploadHooks = null;
    this.renderer = null;
    this.completes = null;
    this.queue = null;
    this.limiter = null;
    this.uploadHookHelper = null;
  };
  return BasePrepare2;
}();
function uploadBaseTextures(renderer, item) {
  if (item instanceof BaseTexture) {
    if (!item._glTextures[renderer.CONTEXT_UID]) {
      renderer.texture.bind(item);
    }
    return true;
  }
  return false;
}
function uploadGraphics(renderer, item) {
  if (!(item instanceof Graphics)) {
    return false;
  }
  var geometry = item.geometry;
  item.finishPoly();
  geometry.updateBatches();
  var batches = geometry.batches;
  for (var i = 0; i < batches.length; i++) {
    var texture = batches[i].style.texture;
    if (texture) {
      uploadBaseTextures(renderer, texture.baseTexture);
    }
  }
  if (!geometry.batchable) {
    renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));
  }
  return true;
}
function findGraphics(item, queue) {
  if (item instanceof Graphics) {
    queue.push(item);
    return true;
  }
  return false;
}
var Prepare = function(_super) {
  __extends$b(Prepare2, _super);
  function Prepare2(renderer) {
    var _this = _super.call(this, renderer) || this;
    _this.uploadHookHelper = _this.renderer;
    _this.registerFindHook(findGraphics);
    _this.registerUploadHook(uploadBaseTextures);
    _this.registerUploadHook(uploadGraphics);
    return _this;
  }
  return Prepare2;
}(BasePrepare);
/*!
 * @pixi/spritesheet - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/spritesheet is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Spritesheet = function() {
  function Spritesheet2(texture, data, resolutionFilename) {
    if (resolutionFilename === void 0) {
      resolutionFilename = null;
    }
    this._texture = texture instanceof Texture ? texture : null;
    this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;
    this.textures = {};
    this.animations = {};
    this.data = data;
    var resource = this.baseTexture.resource;
    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));
    this._frames = this.data.frames;
    this._frameKeys = Object.keys(this._frames);
    this._batchIndex = 0;
    this._callback = null;
  }
  Spritesheet2.prototype._updateResolution = function(resolutionFilename) {
    if (resolutionFilename === void 0) {
      resolutionFilename = null;
    }
    var scale = this.data.meta.scale;
    var resolution = getResolutionOfUrl(resolutionFilename, null);
    if (resolution === null) {
      resolution = scale !== void 0 ? parseFloat(scale) : 1;
    }
    if (resolution !== 1) {
      this.baseTexture.setResolution(resolution);
    }
    return resolution;
  };
  Spritesheet2.prototype.parse = function(callback) {
    this._batchIndex = 0;
    this._callback = callback;
    if (this._frameKeys.length <= Spritesheet2.BATCH_SIZE) {
      this._processFrames(0);
      this._processAnimations();
      this._parseComplete();
    } else {
      this._nextBatch();
    }
  };
  Spritesheet2.prototype._processFrames = function(initialFrameIndex) {
    var frameIndex = initialFrameIndex;
    var maxFrames = Spritesheet2.BATCH_SIZE;
    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
      var i = this._frameKeys[frameIndex];
      var data = this._frames[i];
      var rect = data.frame;
      if (rect) {
        var frame = null;
        var trim = null;
        var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
        var orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
        if (data.rotated) {
          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
        } else {
          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        if (data.trimmed !== false && data.spriteSourceSize) {
          trim = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        this.textures[i] = new Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor);
        Texture.addToCache(this.textures[i], i);
      }
      frameIndex++;
    }
  };
  Spritesheet2.prototype._processAnimations = function() {
    var animations = this.data.animations || {};
    for (var animName in animations) {
      this.animations[animName] = [];
      for (var i = 0; i < animations[animName].length; i++) {
        var frameName = animations[animName][i];
        this.animations[animName].push(this.textures[frameName]);
      }
    }
  };
  Spritesheet2.prototype._parseComplete = function() {
    var callback = this._callback;
    this._callback = null;
    this._batchIndex = 0;
    callback.call(this, this.textures);
  };
  Spritesheet2.prototype._nextBatch = function() {
    var _this = this;
    this._processFrames(this._batchIndex * Spritesheet2.BATCH_SIZE);
    this._batchIndex++;
    setTimeout(function() {
      if (_this._batchIndex * Spritesheet2.BATCH_SIZE < _this._frameKeys.length) {
        _this._nextBatch();
      } else {
        _this._processAnimations();
        _this._parseComplete();
      }
    }, 0);
  };
  Spritesheet2.prototype.destroy = function(destroyBase) {
    var _a2;
    if (destroyBase === void 0) {
      destroyBase = false;
    }
    for (var i in this.textures) {
      this.textures[i].destroy();
    }
    this._frames = null;
    this._frameKeys = null;
    this.data = null;
    this.textures = null;
    if (destroyBase) {
      (_a2 = this._texture) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      this.baseTexture.destroy();
    }
    this._texture = null;
    this.baseTexture = null;
  };
  Spritesheet2.BATCH_SIZE = 1e3;
  return Spritesheet2;
}();
var SpritesheetLoader = function() {
  function SpritesheetLoader2() {
  }
  SpritesheetLoader2.use = function(resource, next) {
    var _a2, _b2;
    var loader = this;
    var imageResourceName = resource.name + "_image";
    if (!resource.data || resource.type !== LoaderResource.TYPE.JSON || !resource.data.frames || loader.resources[imageResourceName]) {
      next();
      return;
    }
    var multiPacks = (_b2 = (_a2 = resource.data) === null || _a2 === void 0 ? void 0 : _a2.meta) === null || _b2 === void 0 ? void 0 : _b2.related_multi_packs;
    if (Array.isArray(multiPacks)) {
      var _loop_12 = function(item2) {
        if (typeof item2 !== "string") {
          return "continue";
        }
        var itemName = item2.replace(".json", "");
        var itemUrl = url.resolve(resource.url.replace(loader.baseUrl, ""), item2);
        if (loader.resources[itemName] || Object.values(loader.resources).some(function(r) {
          return url.format(url.parse(r.url)) === itemUrl;
        })) {
          return "continue";
        }
        var options = {
          crossOrigin: resource.crossOrigin,
          loadType: LoaderResource.LOAD_TYPE.XHR,
          xhrType: LoaderResource.XHR_RESPONSE_TYPE.JSON,
          parentResource: resource,
          metadata: resource.metadata
        };
        loader.add(itemName, itemUrl, options);
      };
      for (var _i = 0, multiPacks_1 = multiPacks; _i < multiPacks_1.length; _i++) {
        var item = multiPacks_1[_i];
        _loop_12(item);
      }
    }
    var loadOptions = {
      crossOrigin: resource.crossOrigin,
      metadata: resource.metadata.imageMetadata,
      parentResource: resource
    };
    var resourcePath = SpritesheetLoader2.getResourcePath(resource, loader.baseUrl);
    loader.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) {
      if (res.error) {
        next(res.error);
        return;
      }
      var spritesheet = new Spritesheet(res.texture, resource.data, resource.url);
      spritesheet.parse(function() {
        resource.spritesheet = spritesheet;
        resource.textures = spritesheet.textures;
        next();
      });
    });
  };
  SpritesheetLoader2.getResourcePath = function(resource, baseUrl) {
    if (resource.isDataUrl) {
      return resource.data.meta.image;
    }
    return url.resolve(resource.url.replace(baseUrl, ""), resource.data.meta.image);
  };
  return SpritesheetLoader2;
}();
/*!
 * @pixi/sprite-tiling - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/sprite-tiling is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$a = function(d, b) {
  extendStatics$a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$a(d, b);
};
function __extends$a(d, b) {
  extendStatics$a(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var tempPoint$1 = new Point();
(function(_super) {
  __extends$a(TilingSprite, _super);
  function TilingSprite(texture, width, height) {
    if (width === void 0) {
      width = 100;
    }
    if (height === void 0) {
      height = 100;
    }
    var _this = _super.call(this, texture) || this;
    _this.tileTransform = new Transform();
    _this._width = width;
    _this._height = height;
    _this.uvMatrix = _this.texture.uvMatrix || new TextureMatrix(texture);
    _this.pluginName = "tilingSprite";
    _this.uvRespectAnchor = false;
    return _this;
  }
  Object.defineProperty(TilingSprite.prototype, "clampMargin", {
    get: function() {
      return this.uvMatrix.clampMargin;
    },
    set: function(value) {
      this.uvMatrix.clampMargin = value;
      this.uvMatrix.update(true);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TilingSprite.prototype, "tileScale", {
    get: function() {
      return this.tileTransform.scale;
    },
    set: function(value) {
      this.tileTransform.scale.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TilingSprite.prototype, "tilePosition", {
    get: function() {
      return this.tileTransform.position;
    },
    set: function(value) {
      this.tileTransform.position.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  TilingSprite.prototype._onTextureUpdate = function() {
    if (this.uvMatrix) {
      this.uvMatrix.texture = this._texture;
    }
    this._cachedTint = 16777215;
  };
  TilingSprite.prototype._render = function(renderer) {
    var texture = this._texture;
    if (!texture || !texture.valid) {
      return;
    }
    this.tileTransform.updateLocalTransform();
    this.uvMatrix.update();
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    renderer.plugins[this.pluginName].render(this);
  };
  TilingSprite.prototype._calculateBounds = function() {
    var minX = this._width * -this._anchor._x;
    var minY = this._height * -this._anchor._y;
    var maxX = this._width * (1 - this._anchor._x);
    var maxY = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  };
  TilingSprite.prototype.getLocalBounds = function(rect) {
    if (this.children.length === 0) {
      this._bounds.minX = this._width * -this._anchor._x;
      this._bounds.minY = this._height * -this._anchor._y;
      this._bounds.maxX = this._width * (1 - this._anchor._x);
      this._bounds.maxY = this._height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._bounds.getRectangle(rect);
    }
    return _super.prototype.getLocalBounds.call(this, rect);
  };
  TilingSprite.prototype.containsPoint = function(point) {
    this.worldTransform.applyInverse(point, tempPoint$1);
    var width = this._width;
    var height = this._height;
    var x1 = -width * this.anchor._x;
    if (tempPoint$1.x >= x1 && tempPoint$1.x < x1 + width) {
      var y1 = -height * this.anchor._y;
      if (tempPoint$1.y >= y1 && tempPoint$1.y < y1 + height) {
        return true;
      }
    }
    return false;
  };
  TilingSprite.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this, options);
    this.tileTransform = null;
    this.uvMatrix = null;
  };
  TilingSprite.from = function(source, options) {
    var texture = source instanceof Texture ? source : Texture.from(source, options);
    return new TilingSprite(texture, options.width, options.height);
  };
  Object.defineProperty(TilingSprite.prototype, "width", {
    get: function() {
      return this._width;
    },
    set: function(value) {
      this._width = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TilingSprite.prototype, "height", {
    get: function() {
      return this._height;
    },
    set: function(value) {
      this._height = value;
    },
    enumerable: false,
    configurable: true
  });
  return TilingSprite;
})(Sprite);
var fragmentSimpleSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n";
var gl1VertexSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var gl1FragmentSrc = "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n";
var gl2VertexSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var gl2FragmentSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n";
var tempMat = new Matrix();
var TilingSpriteRenderer = function(_super) {
  __extends$a(TilingSpriteRenderer2, _super);
  function TilingSpriteRenderer2(renderer) {
    var _this = _super.call(this, renderer) || this;
    renderer.runners.contextChange.add(_this);
    _this.quad = new QuadUv();
    _this.state = State.for2d();
    return _this;
  }
  TilingSpriteRenderer2.prototype.contextChange = function() {
    var renderer = this.renderer;
    var uniforms = { globals: renderer.globalUniforms };
    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);
    this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);
  };
  TilingSpriteRenderer2.prototype.render = function(ts) {
    var renderer = this.renderer;
    var quad = this.quad;
    var vertices = quad.vertices;
    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
    vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
    vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
    var anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;
    var anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
    vertices = quad.uvs;
    vertices[0] = vertices[6] = -anchorX;
    vertices[1] = vertices[3] = -anchorY;
    vertices[2] = vertices[4] = 1 - anchorX;
    vertices[5] = vertices[7] = 1 - anchorY;
    quad.invalidate();
    var tex = ts._texture;
    var baseTex = tex.baseTexture;
    var lt = ts.tileTransform.localTransform;
    var uv = ts.uvMatrix;
    var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
    if (isSimple) {
      if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
        if (baseTex.wrapMode === WRAP_MODES$3.CLAMP) {
          baseTex.wrapMode = WRAP_MODES$3.REPEAT;
        }
      } else {
        isSimple = baseTex.wrapMode !== WRAP_MODES$3.CLAMP;
      }
    }
    var shader = isSimple ? this.simpleShader : this.shader;
    var w = tex.width;
    var h = tex.height;
    var W = ts._width;
    var H = ts._height;
    tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);
    tempMat.invert();
    if (isSimple) {
      tempMat.prepend(uv.mapCoord);
    } else {
      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
      shader.uniforms.uClampFrame = uv.uClampFrame;
      shader.uniforms.uClampOffset = uv.uClampOffset;
    }
    shader.uniforms.uTransform = tempMat.toArray(true);
    shader.uniforms.uColor = premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, baseTex.alphaMode);
    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
    shader.uniforms.uSampler = tex;
    renderer.shader.bind(shader);
    renderer.geometry.bind(quad);
    this.state.blendMode = correctBlendMode(ts.blendMode, baseTex.alphaMode);
    renderer.state.set(this.state);
    renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
  };
  return TilingSpriteRenderer2;
}(ObjectRenderer);
/*!
 * @pixi/mesh - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/mesh is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$9 = function(d, b) {
  extendStatics$9 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$9(d, b);
};
function __extends$9(d, b) {
  extendStatics$9(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var MeshBatchUvs = function() {
  function MeshBatchUvs2(uvBuffer, uvMatrix) {
    this.uvBuffer = uvBuffer;
    this.uvMatrix = uvMatrix;
    this.data = null;
    this._bufferUpdateId = -1;
    this._textureUpdateId = -1;
    this._updateID = 0;
  }
  MeshBatchUvs2.prototype.update = function(forceUpdate) {
    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
      return;
    }
    this._bufferUpdateId = this.uvBuffer._updateID;
    this._textureUpdateId = this.uvMatrix._updateID;
    var data = this.uvBuffer.data;
    if (!this.data || this.data.length !== data.length) {
      this.data = new Float32Array(data.length);
    }
    this.uvMatrix.multiplyUvs(data, this.data);
    this._updateID++;
  };
  return MeshBatchUvs2;
}();
var tempPoint = new Point();
var tempPolygon = new Polygon();
var Mesh = function(_super) {
  __extends$9(Mesh2, _super);
  function Mesh2(geometry, shader, state, drawMode) {
    if (drawMode === void 0) {
      drawMode = DRAW_MODES$3.TRIANGLES;
    }
    var _this = _super.call(this) || this;
    _this.geometry = geometry;
    _this.shader = shader;
    _this.state = state || State.for2d();
    _this.drawMode = drawMode;
    _this.start = 0;
    _this.size = 0;
    _this.uvs = null;
    _this.indices = null;
    _this.vertexData = new Float32Array(1);
    _this.vertexDirty = -1;
    _this._transformID = -1;
    _this._roundPixels = settings.ROUND_PIXELS;
    _this.batchUvs = null;
    return _this;
  }
  Object.defineProperty(Mesh2.prototype, "geometry", {
    get: function() {
      return this._geometry;
    },
    set: function(value) {
      if (this._geometry === value) {
        return;
      }
      if (this._geometry) {
        this._geometry.refCount--;
        if (this._geometry.refCount === 0) {
          this._geometry.dispose();
        }
      }
      this._geometry = value;
      if (this._geometry) {
        this._geometry.refCount++;
      }
      this.vertexDirty = -1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "uvBuffer", {
    get: function() {
      return this.geometry.buffers[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "verticesBuffer", {
    get: function() {
      return this.geometry.buffers[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "material", {
    get: function() {
      return this.shader;
    },
    set: function(value) {
      this.shader = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    set: function(value) {
      this.state.blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "roundPixels", {
    get: function() {
      return this._roundPixels;
    },
    set: function(value) {
      if (this._roundPixels !== value) {
        this._transformID = -1;
      }
      this._roundPixels = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "tint", {
    get: function() {
      return "tint" in this.shader ? this.shader.tint : null;
    },
    set: function(value) {
      this.shader.tint = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "texture", {
    get: function() {
      return "texture" in this.shader ? this.shader.texture : null;
    },
    set: function(value) {
      this.shader.texture = value;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype._render = function(renderer) {
    var vertices = this.geometry.buffers[0].data;
    var shader = this.shader;
    if (shader.batchable && this.drawMode === DRAW_MODES$3.TRIANGLES && vertices.length < Mesh2.BATCHABLE_SIZE * 2) {
      this._renderToBatch(renderer);
    } else {
      this._renderDefault(renderer);
    }
  };
  Mesh2.prototype._renderDefault = function(renderer) {
    var shader = this.shader;
    shader.alpha = this.worldAlpha;
    if (shader.update) {
      shader.update();
    }
    renderer.batch.flush();
    shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
    renderer.shader.bind(shader);
    renderer.state.set(this.state);
    renderer.geometry.bind(this.geometry, shader);
    renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  };
  Mesh2.prototype._renderToBatch = function(renderer) {
    var geometry = this.geometry;
    var shader = this.shader;
    if (shader.uvMatrix) {
      shader.uvMatrix.update();
      this.calculateUvs();
    }
    this.calculateVertices();
    this.indices = geometry.indexBuffer.data;
    this._tintRGB = shader._tintRGB;
    this._texture = shader.texture;
    var pluginName = this.material.pluginName;
    renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
    renderer.plugins[pluginName].render(this);
  };
  Mesh2.prototype.calculateVertices = function() {
    var geometry = this.geometry;
    var verticesBuffer = geometry.buffers[0];
    var vertices = verticesBuffer.data;
    var vertexDirtyId = verticesBuffer._updateID;
    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
      return;
    }
    this._transformID = this.transform._worldID;
    if (this.vertexData.length !== vertices.length) {
      this.vertexData = new Float32Array(vertices.length);
    }
    var wt = this.transform.worldTransform;
    var a = wt.a;
    var b = wt.b;
    var c = wt.c;
    var d = wt.d;
    var tx = wt.tx;
    var ty = wt.ty;
    var vertexData = this.vertexData;
    for (var i = 0; i < vertexData.length / 2; i++) {
      var x = vertices[i * 2];
      var y = vertices[i * 2 + 1];
      vertexData[i * 2] = a * x + c * y + tx;
      vertexData[i * 2 + 1] = b * x + d * y + ty;
    }
    if (this._roundPixels) {
      var resolution = settings.RESOLUTION;
      for (var i = 0; i < vertexData.length; ++i) {
        vertexData[i] = Math.round((vertexData[i] * resolution | 0) / resolution);
      }
    }
    this.vertexDirty = vertexDirtyId;
  };
  Mesh2.prototype.calculateUvs = function() {
    var geomUvs = this.geometry.buffers[1];
    var shader = this.shader;
    if (!shader.uvMatrix.isSimple) {
      if (!this.batchUvs) {
        this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);
      }
      this.batchUvs.update();
      this.uvs = this.batchUvs.data;
    } else {
      this.uvs = geomUvs.data;
    }
  };
  Mesh2.prototype._calculateBounds = function() {
    this.calculateVertices();
    this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
  };
  Mesh2.prototype.containsPoint = function(point) {
    if (!this.getBounds().contains(point.x, point.y)) {
      return false;
    }
    this.worldTransform.applyInverse(point, tempPoint);
    var vertices = this.geometry.getBuffer("aVertexPosition").data;
    var points = tempPolygon.points;
    var indices2 = this.geometry.getIndex().data;
    var len = indices2.length;
    var step = this.drawMode === 4 ? 3 : 1;
    for (var i = 0; i + 2 < len; i += step) {
      var ind0 = indices2[i] * 2;
      var ind1 = indices2[i + 1] * 2;
      var ind2 = indices2[i + 2] * 2;
      points[0] = vertices[ind0];
      points[1] = vertices[ind0 + 1];
      points[2] = vertices[ind1];
      points[3] = vertices[ind1 + 1];
      points[4] = vertices[ind2];
      points[5] = vertices[ind2 + 1];
      if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
        return true;
      }
    }
    return false;
  };
  Mesh2.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this, options);
    if (this._cachedTexture) {
      this._cachedTexture.destroy();
      this._cachedTexture = null;
    }
    this.geometry = null;
    this.shader = null;
    this.state = null;
    this.uvs = null;
    this.indices = null;
    this.vertexData = null;
  };
  Mesh2.BATCHABLE_SIZE = 100;
  return Mesh2;
}(Container);
var fragment$5 = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";
var vertex$2 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var MeshMaterial = function(_super) {
  __extends$9(MeshMaterial2, _super);
  function MeshMaterial2(uSampler, options) {
    var _this = this;
    var uniforms = {
      uSampler,
      alpha: 1,
      uTextureMatrix: Matrix.IDENTITY,
      uColor: new Float32Array([1, 1, 1, 1])
    };
    options = Object.assign({
      tint: 16777215,
      alpha: 1,
      pluginName: "batch"
    }, options);
    if (options.uniforms) {
      Object.assign(uniforms, options.uniforms);
    }
    _this = _super.call(this, options.program || Program.from(vertex$2, fragment$5), uniforms) || this;
    _this._colorDirty = false;
    _this.uvMatrix = new TextureMatrix(uSampler);
    _this.batchable = options.program === void 0;
    _this.pluginName = options.pluginName;
    _this.tint = options.tint;
    _this.alpha = options.alpha;
    return _this;
  }
  Object.defineProperty(MeshMaterial2.prototype, "texture", {
    get: function() {
      return this.uniforms.uSampler;
    },
    set: function(value) {
      if (this.uniforms.uSampler !== value) {
        this.uniforms.uSampler = value;
        this.uvMatrix.texture = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MeshMaterial2.prototype, "alpha", {
    get: function() {
      return this._alpha;
    },
    set: function(value) {
      if (value === this._alpha) {
        return;
      }
      this._alpha = value;
      this._colorDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MeshMaterial2.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(value) {
      if (value === this._tint) {
        return;
      }
      this._tint = value;
      this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);
      this._colorDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  MeshMaterial2.prototype.update = function() {
    if (this._colorDirty) {
      this._colorDirty = false;
      var baseTexture = this.texture.baseTexture;
      premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.alphaMode);
    }
    if (this.uvMatrix.update()) {
      this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
    }
  };
  return MeshMaterial2;
}(Shader);
var MeshGeometry = function(_super) {
  __extends$9(MeshGeometry2, _super);
  function MeshGeometry2(vertices, uvs, index2) {
    var _this = _super.call(this) || this;
    var verticesBuffer = new Buffer$1(vertices);
    var uvsBuffer = new Buffer$1(uvs, true);
    var indexBuffer = new Buffer$1(index2, true, true);
    _this.addAttribute("aVertexPosition", verticesBuffer, 2, false, TYPES$3.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, TYPES$3.FLOAT).addIndex(indexBuffer);
    _this._updateId = -1;
    return _this;
  }
  Object.defineProperty(MeshGeometry2.prototype, "vertexDirtyId", {
    get: function() {
      return this.buffers[0]._updateID;
    },
    enumerable: false,
    configurable: true
  });
  return MeshGeometry2;
}(Geometry);
/*!
 * @pixi/text-bitmap - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/text-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$8 = function(d, b) {
  extendStatics$8 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$8(d, b);
};
function __extends$8(d, b) {
  extendStatics$8(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var BitmapFontData = function() {
  function BitmapFontData2() {
    this.info = [];
    this.common = [];
    this.page = [];
    this.char = [];
    this.kerning = [];
    this.distanceField = [];
  }
  return BitmapFontData2;
}();
var TextFormat = function() {
  function TextFormat2() {
  }
  TextFormat2.test = function(data) {
    return typeof data === "string" && data.indexOf("info face=") === 0;
  };
  TextFormat2.parse = function(txt) {
    var items = txt.match(/^[a-z]+\s+.+$/gm);
    var rawData = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (var i in items) {
      var name = items[i].match(/^[a-z]+/gm)[0];
      var attributeList = items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
      var itemData = {};
      for (var i_1 in attributeList) {
        var split = attributeList[i_1].split("=");
        var key = split[0];
        var strValue = split[1].replace(/"/gm, "");
        var floatValue = parseFloat(strValue);
        var value = isNaN(floatValue) ? strValue : floatValue;
        itemData[key] = value;
      }
      rawData[name].push(itemData);
    }
    var font = new BitmapFontData();
    rawData.info.forEach(function(info) {
      return font.info.push({
        face: info.face,
        size: parseInt(info.size, 10)
      });
    });
    rawData.common.forEach(function(common) {
      return font.common.push({
        lineHeight: parseInt(common.lineHeight, 10)
      });
    });
    rawData.page.forEach(function(page) {
      return font.page.push({
        id: parseInt(page.id, 10),
        file: page.file
      });
    });
    rawData.char.forEach(function(char) {
      return font.char.push({
        id: parseInt(char.id, 10),
        page: parseInt(char.page, 10),
        x: parseInt(char.x, 10),
        y: parseInt(char.y, 10),
        width: parseInt(char.width, 10),
        height: parseInt(char.height, 10),
        xoffset: parseInt(char.xoffset, 10),
        yoffset: parseInt(char.yoffset, 10),
        xadvance: parseInt(char.xadvance, 10)
      });
    });
    rawData.kerning.forEach(function(kerning) {
      return font.kerning.push({
        first: parseInt(kerning.first, 10),
        second: parseInt(kerning.second, 10),
        amount: parseInt(kerning.amount, 10)
      });
    });
    rawData.distanceField.forEach(function(df) {
      return font.distanceField.push({
        distanceRange: parseInt(df.distanceRange, 10),
        fieldType: df.fieldType
      });
    });
    return font;
  };
  return TextFormat2;
}();
var XMLFormat = function() {
  function XMLFormat2() {
  }
  XMLFormat2.test = function(data) {
    return data instanceof XMLDocument && data.getElementsByTagName("page").length && data.getElementsByTagName("info")[0].getAttribute("face") !== null;
  };
  XMLFormat2.parse = function(xml) {
    var data = new BitmapFontData();
    var info = xml.getElementsByTagName("info");
    var common = xml.getElementsByTagName("common");
    var page = xml.getElementsByTagName("page");
    var char = xml.getElementsByTagName("char");
    var kerning = xml.getElementsByTagName("kerning");
    var distanceField = xml.getElementsByTagName("distanceField");
    for (var i = 0; i < info.length; i++) {
      data.info.push({
        face: info[i].getAttribute("face"),
        size: parseInt(info[i].getAttribute("size"), 10)
      });
    }
    for (var i = 0; i < common.length; i++) {
      data.common.push({
        lineHeight: parseInt(common[i].getAttribute("lineHeight"), 10)
      });
    }
    for (var i = 0; i < page.length; i++) {
      data.page.push({
        id: parseInt(page[i].getAttribute("id"), 10) || 0,
        file: page[i].getAttribute("file")
      });
    }
    for (var i = 0; i < char.length; i++) {
      var letter = char[i];
      data.char.push({
        id: parseInt(letter.getAttribute("id"), 10),
        page: parseInt(letter.getAttribute("page"), 10) || 0,
        x: parseInt(letter.getAttribute("x"), 10),
        y: parseInt(letter.getAttribute("y"), 10),
        width: parseInt(letter.getAttribute("width"), 10),
        height: parseInt(letter.getAttribute("height"), 10),
        xoffset: parseInt(letter.getAttribute("xoffset"), 10),
        yoffset: parseInt(letter.getAttribute("yoffset"), 10),
        xadvance: parseInt(letter.getAttribute("xadvance"), 10)
      });
    }
    for (var i = 0; i < kerning.length; i++) {
      data.kerning.push({
        first: parseInt(kerning[i].getAttribute("first"), 10),
        second: parseInt(kerning[i].getAttribute("second"), 10),
        amount: parseInt(kerning[i].getAttribute("amount"), 10)
      });
    }
    for (var i = 0; i < distanceField.length; i++) {
      data.distanceField.push({
        fieldType: distanceField[i].getAttribute("fieldType"),
        distanceRange: parseInt(distanceField[i].getAttribute("distanceRange"), 10)
      });
    }
    return data;
  };
  return XMLFormat2;
}();
var XMLStringFormat = function() {
  function XMLStringFormat2() {
  }
  XMLStringFormat2.test = function(data) {
    if (typeof data === "string" && data.indexOf("<font>") > -1) {
      var xml = new self.DOMParser().parseFromString(data, "text/xml");
      return XMLFormat.test(xml);
    }
    return false;
  };
  XMLStringFormat2.parse = function(xmlTxt) {
    var xml = new self.DOMParser().parseFromString(xmlTxt, "text/xml");
    return XMLFormat.parse(xml);
  };
  return XMLStringFormat2;
}();
var formats = [
  TextFormat,
  XMLFormat,
  XMLStringFormat
];
function autoDetectFormat(data) {
  for (var i = 0; i < formats.length; i++) {
    if (formats[i].test(data)) {
      return formats[i];
    }
  }
  return null;
}
function generateFillStyle(canvas2, context2, style, resolution, lines, metrics) {
  var fillStyle = style.fill;
  if (!Array.isArray(fillStyle)) {
    return fillStyle;
  } else if (fillStyle.length === 1) {
    return fillStyle[0];
  }
  var gradient;
  var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
  var padding = style.padding || 0;
  var width = canvas2.width / resolution - dropShadowCorrection - padding * 2;
  var height = canvas2.height / resolution - dropShadowCorrection - padding * 2;
  var fill = fillStyle.slice();
  var fillGradientStops = style.fillGradientStops.slice();
  if (!fillGradientStops.length) {
    var lengthPlus1 = fill.length + 1;
    for (var i = 1; i < lengthPlus1; ++i) {
      fillGradientStops.push(i / lengthPlus1);
    }
  }
  fill.unshift(fillStyle[0]);
  fillGradientStops.unshift(0);
  fill.push(fillStyle[fillStyle.length - 1]);
  fillGradientStops.push(1);
  if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
    gradient = context2.createLinearGradient(width / 2, padding, width / 2, height + padding);
    var lastIterationStop = 0;
    var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
    var gradStopLineHeight = textHeight / height;
    for (var i = 0; i < lines.length; i++) {
      var thisLineTop = metrics.lineHeight * i;
      for (var j = 0; j < fill.length; j++) {
        var lineStop = 0;
        if (typeof fillGradientStops[j] === "number") {
          lineStop = fillGradientStops[j];
        } else {
          lineStop = j / fill.length;
        }
        var globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
        var clampedStop = Math.max(lastIterationStop, globalStop);
        clampedStop = Math.min(clampedStop, 1);
        gradient.addColorStop(clampedStop, fill[j]);
        lastIterationStop = clampedStop;
      }
    }
  } else {
    gradient = context2.createLinearGradient(padding, height / 2, width + padding, height / 2);
    var totalIterations = fill.length + 1;
    var currentIteration = 1;
    for (var i = 0; i < fill.length; i++) {
      var stop = void 0;
      if (typeof fillGradientStops[i] === "number") {
        stop = fillGradientStops[i];
      } else {
        stop = currentIteration / totalIterations;
      }
      gradient.addColorStop(stop, fill[i]);
      currentIteration++;
    }
  }
  return gradient;
}
function drawGlyph(canvas2, context2, metrics, x, y, resolution, style) {
  var char = metrics.text;
  var fontProperties = metrics.fontProperties;
  context2.translate(x, y);
  context2.scale(resolution, resolution);
  var tx = style.strokeThickness / 2;
  var ty = -(style.strokeThickness / 2);
  context2.font = style.toFontString();
  context2.lineWidth = style.strokeThickness;
  context2.textBaseline = style.textBaseline;
  context2.lineJoin = style.lineJoin;
  context2.miterLimit = style.miterLimit;
  context2.fillStyle = generateFillStyle(canvas2, context2, style, resolution, [char], metrics);
  context2.strokeStyle = style.stroke;
  if (style.dropShadow) {
    var dropShadowColor = style.dropShadowColor;
    var rgb = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
    var dropShadowBlur = style.dropShadowBlur * resolution;
    var dropShadowDistance = style.dropShadowDistance * resolution;
    context2.shadowColor = "rgba(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + "," + style.dropShadowAlpha + ")";
    context2.shadowBlur = dropShadowBlur;
    context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
    context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
  } else {
    context2.shadowColor = "black";
    context2.shadowBlur = 0;
    context2.shadowOffsetX = 0;
    context2.shadowOffsetY = 0;
  }
  if (style.stroke && style.strokeThickness) {
    context2.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  if (style.fill) {
    context2.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  context2.setTransform(1, 0, 0, 1, 0, 0);
  context2.fillStyle = "rgba(0, 0, 0, 0)";
}
function splitTextToCharacters(text) {
  return Array.from ? Array.from(text) : text.split("");
}
function resolveCharacters(chars) {
  if (typeof chars === "string") {
    chars = [chars];
  }
  var result = [];
  for (var i = 0, j = chars.length; i < j; i++) {
    var item = chars[i];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + item.length + ".");
      }
      var startCode = item[0].charCodeAt(0);
      var endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (var i_1 = startCode, j_1 = endCode; i_1 <= j_1; i_1++) {
        result.push(String.fromCharCode(i_1));
      }
    } else {
      result.push.apply(result, splitTextToCharacters(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}
function extractCharCode(str) {
  return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);
}
var BitmapFont = function() {
  function BitmapFont2(data, textures, ownsTextures) {
    var _a2, _b2;
    var info = data.info[0];
    var common = data.common[0];
    var page = data.page[0];
    var distanceField = data.distanceField[0];
    var res = getResolutionOfUrl(page.file);
    var pageTextures = {};
    this._ownsTextures = ownsTextures;
    this.font = info.face;
    this.size = info.size;
    this.lineHeight = common.lineHeight / res;
    this.chars = {};
    this.pageTextures = pageTextures;
    for (var i = 0; i < data.page.length; i++) {
      var _c2 = data.page[i], id = _c2.id, file = _c2.file;
      pageTextures[id] = textures instanceof Array ? textures[i] : textures[file];
      if ((distanceField === null || distanceField === void 0 ? void 0 : distanceField.fieldType) && distanceField.fieldType !== "none") {
        pageTextures[id].baseTexture.alphaMode = ALPHA_MODES$3.NO_PREMULTIPLIED_ALPHA;
      }
    }
    for (var i = 0; i < data.char.length; i++) {
      var _d = data.char[i], id = _d.id, page_1 = _d.page;
      var _e = data.char[i], x = _e.x, y = _e.y, width = _e.width, height = _e.height, xoffset = _e.xoffset, yoffset = _e.yoffset, xadvance = _e.xadvance;
      x /= res;
      y /= res;
      width /= res;
      height /= res;
      xoffset /= res;
      yoffset /= res;
      xadvance /= res;
      var rect = new Rectangle(x + pageTextures[page_1].frame.x / res, y + pageTextures[page_1].frame.y / res, width, height);
      this.chars[id] = {
        xOffset: xoffset,
        yOffset: yoffset,
        xAdvance: xadvance,
        kerning: {},
        texture: new Texture(pageTextures[page_1].baseTexture, rect),
        page: page_1
      };
    }
    for (var i = 0; i < data.kerning.length; i++) {
      var _f = data.kerning[i], first = _f.first, second = _f.second, amount = _f.amount;
      first /= res;
      second /= res;
      amount /= res;
      if (this.chars[second]) {
        this.chars[second].kerning[first] = amount;
      }
    }
    this.distanceFieldRange = distanceField === null || distanceField === void 0 ? void 0 : distanceField.distanceRange;
    this.distanceFieldType = (_b2 = (_a2 = distanceField === null || distanceField === void 0 ? void 0 : distanceField.fieldType) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) !== null && _b2 !== void 0 ? _b2 : "none";
  }
  BitmapFont2.prototype.destroy = function() {
    for (var id in this.chars) {
      this.chars[id].texture.destroy();
      this.chars[id].texture = null;
    }
    for (var id in this.pageTextures) {
      if (this._ownsTextures) {
        this.pageTextures[id].destroy(true);
      }
      this.pageTextures[id] = null;
    }
    this.chars = null;
    this.pageTextures = null;
  };
  BitmapFont2.install = function(data, textures, ownsTextures) {
    var fontData;
    if (data instanceof BitmapFontData) {
      fontData = data;
    } else {
      var format2 = autoDetectFormat(data);
      if (!format2) {
        throw new Error("Unrecognized data format for font.");
      }
      fontData = format2.parse(data);
    }
    if (textures instanceof Texture) {
      textures = [textures];
    }
    var font = new BitmapFont2(fontData, textures, ownsTextures);
    BitmapFont2.available[font.font] = font;
    return font;
  };
  BitmapFont2.uninstall = function(name) {
    var font = BitmapFont2.available[name];
    if (!font) {
      throw new Error("No font found named '" + name + "'");
    }
    font.destroy();
    delete BitmapFont2.available[name];
  };
  BitmapFont2.from = function(name, textStyle, options) {
    if (!name) {
      throw new Error("[BitmapFont] Property `name` is required.");
    }
    var _a2 = Object.assign({}, BitmapFont2.defaultOptions, options), chars = _a2.chars, padding = _a2.padding, resolution = _a2.resolution, textureWidth = _a2.textureWidth, textureHeight = _a2.textureHeight;
    var charsList = resolveCharacters(chars);
    var style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
    var lineWidth = textureWidth;
    var fontData = new BitmapFontData();
    fontData.info[0] = {
      face: style.fontFamily,
      size: style.fontSize
    };
    fontData.common[0] = {
      lineHeight: style.fontSize
    };
    var positionX = 0;
    var positionY = 0;
    var canvas2;
    var context2;
    var baseTexture;
    var maxCharHeight = 0;
    var textures = [];
    for (var i = 0; i < charsList.length; i++) {
      if (!canvas2) {
        canvas2 = document.createElement("canvas");
        canvas2.width = textureWidth;
        canvas2.height = textureHeight;
        context2 = canvas2.getContext("2d");
        baseTexture = new BaseTexture(canvas2, { resolution });
        textures.push(new Texture(baseTexture));
        fontData.page.push({
          id: textures.length - 1,
          file: ""
        });
      }
      var metrics = TextMetrics.measureText(charsList[i], style, false, canvas2);
      var width = metrics.width;
      var height = Math.ceil(metrics.height);
      var textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
      if (positionY >= textureHeight - height * resolution) {
        if (positionY === 0) {
          throw new Error("[BitmapFont] textureHeight " + textureHeight + "px is " + ("too small for " + style.fontSize + "px fonts"));
        }
        --i;
        canvas2 = null;
        context2 = null;
        baseTexture = null;
        positionY = 0;
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);
      if (textureGlyphWidth * resolution + positionX >= lineWidth) {
        --i;
        positionY += maxCharHeight * resolution;
        positionY = Math.ceil(positionY);
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      drawGlyph(canvas2, context2, metrics, positionX, positionY, resolution, style);
      var id = extractCharCode(metrics.text);
      fontData.char.push({
        id,
        page: textures.length - 1,
        x: positionX / resolution,
        y: positionY / resolution,
        width: textureGlyphWidth,
        height,
        xoffset: 0,
        yoffset: 0,
        xadvance: Math.ceil(width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0))
      });
      positionX += (textureGlyphWidth + 2 * padding) * resolution;
      positionX = Math.ceil(positionX);
    }
    for (var i = 0, len = charsList.length; i < len; i++) {
      var first = charsList[i];
      for (var j = 0; j < len; j++) {
        var second = charsList[j];
        var c1 = context2.measureText(first).width;
        var c2 = context2.measureText(second).width;
        var total = context2.measureText(first + second).width;
        var amount = total - (c1 + c2);
        if (amount) {
          fontData.kerning.push({
            first: extractCharCode(first),
            second: extractCharCode(second),
            amount
          });
        }
      }
    }
    var font = new BitmapFont2(fontData, textures, true);
    if (BitmapFont2.available[name] !== void 0) {
      BitmapFont2.uninstall(name);
    }
    BitmapFont2.available[name] = font;
    return font;
  };
  BitmapFont2.ALPHA = [["a", "z"], ["A", "Z"], " "];
  BitmapFont2.NUMERIC = [["0", "9"]];
  BitmapFont2.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
  BitmapFont2.ASCII = [[" ", "~"]];
  BitmapFont2.defaultOptions = {
    resolution: 1,
    textureWidth: 512,
    textureHeight: 512,
    padding: 4,
    chars: BitmapFont2.ALPHANUMERIC
  };
  BitmapFont2.available = {};
  return BitmapFont2;
}();
var msdfFrag = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r\n\r\n}\r\n";
var msdfVert = "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";
var pageMeshDataDefaultPageMeshData = [];
var pageMeshDataMSDFPageMeshData = [];
var charRenderDataPool = [];
(function(_super) {
  __extends$8(BitmapText, _super);
  function BitmapText(text, style) {
    if (style === void 0) {
      style = {};
    }
    var _this = _super.call(this) || this;
    _this._tint = 16777215;
    var _a2 = Object.assign({}, BitmapText.styleDefaults, style), align = _a2.align, tint = _a2.tint, maxWidth = _a2.maxWidth, letterSpacing = _a2.letterSpacing, fontName = _a2.fontName, fontSize = _a2.fontSize;
    if (!BitmapFont.available[fontName]) {
      throw new Error('Missing BitmapFont "' + fontName + '"');
    }
    _this._activePagesMeshData = [];
    _this._textWidth = 0;
    _this._textHeight = 0;
    _this._align = align;
    _this._tint = tint;
    _this._fontName = fontName;
    _this._fontSize = fontSize || BitmapFont.available[fontName].size;
    _this._text = text;
    _this._maxWidth = maxWidth;
    _this._maxLineHeight = 0;
    _this._letterSpacing = letterSpacing;
    _this._anchor = new ObservablePoint(function() {
      _this.dirty = true;
    }, _this, 0, 0);
    _this._roundPixels = settings.ROUND_PIXELS;
    _this.dirty = true;
    _this._textureCache = {};
    return _this;
  }
  BitmapText.prototype.updateText = function() {
    var _a2;
    var data = BitmapFont.available[this._fontName];
    var scale = this._fontSize / data.size;
    var pos = new Point();
    var chars = [];
    var lineWidths = [];
    var lineSpaces = [];
    var text = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
    var charsInput = splitTextToCharacters(text);
    var maxWidth = this._maxWidth * data.size / this._fontSize;
    var pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    var prevCharCode = null;
    var lastLineWidth = 0;
    var maxLineWidth = 0;
    var line = 0;
    var lastBreakPos = -1;
    var lastBreakWidth = 0;
    var spacesRemoved = 0;
    var maxLineHeight = 0;
    var spaceCount = 0;
    for (var i = 0; i < charsInput.length; i++) {
      var char = charsInput[i];
      var charCode = extractCharCode(char);
      if (/(?:\s)/.test(char)) {
        lastBreakPos = i;
        lastBreakWidth = lastLineWidth;
        spaceCount++;
      }
      if (char === "\r" || char === "\n") {
        lineWidths.push(lastLineWidth);
        lineSpaces.push(-1);
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        ++line;
        ++spacesRemoved;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
        continue;
      }
      var charData = data.chars[charCode];
      if (!charData) {
        continue;
      }
      if (prevCharCode && charData.kerning[prevCharCode]) {
        pos.x += charData.kerning[prevCharCode];
      }
      var charRenderData = charRenderDataPool.pop() || {
        texture: Texture.EMPTY,
        line: 0,
        charCode: 0,
        prevSpaces: 0,
        position: new Point()
      };
      charRenderData.texture = charData.texture;
      charRenderData.line = line;
      charRenderData.charCode = charCode;
      charRenderData.position.x = pos.x + charData.xOffset + this._letterSpacing / 2;
      charRenderData.position.y = pos.y + charData.yOffset;
      charRenderData.prevSpaces = spaceCount;
      chars.push(charRenderData);
      lastLineWidth = charRenderData.position.x + charData.texture.orig.width;
      pos.x += charData.xAdvance + this._letterSpacing;
      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
      prevCharCode = charCode;
      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
        ++spacesRemoved;
        removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);
        i = lastBreakPos;
        lastBreakPos = -1;
        lineWidths.push(lastBreakWidth);
        lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);
        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
        line++;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
      }
    }
    var lastChar = charsInput[charsInput.length - 1];
    if (lastChar !== "\r" && lastChar !== "\n") {
      if (/(?:\s)/.test(lastChar)) {
        lastLineWidth = lastBreakWidth;
      }
      lineWidths.push(lastLineWidth);
      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
      lineSpaces.push(-1);
    }
    var lineAlignOffsets = [];
    for (var i = 0; i <= line; i++) {
      var alignOffset = 0;
      if (this._align === "right") {
        alignOffset = maxLineWidth - lineWidths[i];
      } else if (this._align === "center") {
        alignOffset = (maxLineWidth - lineWidths[i]) / 2;
      } else if (this._align === "justify") {
        alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];
      }
      lineAlignOffsets.push(alignOffset);
    }
    var lenChars = chars.length;
    var pagesMeshData = {};
    var newPagesMeshData = [];
    var activePagesMeshData = this._activePagesMeshData;
    for (var i = 0; i < activePagesMeshData.length; i++) {
      pageMeshDataPool.push(activePagesMeshData[i]);
    }
    for (var i = 0; i < lenChars; i++) {
      var texture = chars[i].texture;
      var baseTextureUid = texture.baseTexture.uid;
      if (!pagesMeshData[baseTextureUid]) {
        var pageMeshData = pageMeshDataPool.pop();
        if (!pageMeshData) {
          var geometry = new MeshGeometry();
          var material = void 0;
          var meshBlendMode = void 0;
          if (data.distanceFieldType === "none") {
            material = new MeshMaterial(Texture.EMPTY);
            meshBlendMode = BLEND_MODES$3.NORMAL;
          } else {
            material = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });
            meshBlendMode = BLEND_MODES$3.NORMAL_NPM;
          }
          var mesh = new Mesh(geometry, material);
          mesh.blendMode = meshBlendMode;
          pageMeshData = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        pageMeshData.index = 0;
        pageMeshData.indexCount = 0;
        pageMeshData.vertexCount = 0;
        pageMeshData.uvsCount = 0;
        pageMeshData.total = 0;
        var _textureCache = this._textureCache;
        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);
        pageMeshData.mesh.texture = _textureCache[baseTextureUid];
        pageMeshData.mesh.tint = this._tint;
        newPagesMeshData.push(pageMeshData);
        pagesMeshData[baseTextureUid] = pageMeshData;
      }
      pagesMeshData[baseTextureUid].total++;
    }
    for (var i = 0; i < activePagesMeshData.length; i++) {
      if (newPagesMeshData.indexOf(activePagesMeshData[i]) === -1) {
        this.removeChild(activePagesMeshData[i].mesh);
      }
    }
    for (var i = 0; i < newPagesMeshData.length; i++) {
      if (newPagesMeshData[i].mesh.parent !== this) {
        this.addChild(newPagesMeshData[i].mesh);
      }
    }
    this._activePagesMeshData = newPagesMeshData;
    for (var i in pagesMeshData) {
      var pageMeshData = pagesMeshData[i];
      var total = pageMeshData.total;
      if (!(((_a2 = pageMeshData.indices) === null || _a2 === void 0 ? void 0 : _a2.length) > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {
        pageMeshData.vertices = new Float32Array(4 * 2 * total);
        pageMeshData.uvs = new Float32Array(4 * 2 * total);
        pageMeshData.indices = new Uint16Array(6 * total);
      } else {
        var total_1 = pageMeshData.total;
        var vertices = pageMeshData.vertices;
        for (var i_1 = total_1 * 4 * 2; i_1 < vertices.length; i_1++) {
          vertices[i_1] = 0;
        }
      }
      pageMeshData.mesh.size = 6 * total;
    }
    for (var i = 0; i < lenChars; i++) {
      var char = chars[i];
      var offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
      if (this._roundPixels) {
        offset = Math.round(offset);
      }
      var xPos = offset * scale;
      var yPos = char.position.y * scale;
      var texture = char.texture;
      var pageMesh = pagesMeshData[texture.baseTexture.uid];
      var textureFrame = texture.frame;
      var textureUvs = texture._uvs;
      var index2 = pageMesh.index++;
      pageMesh.indices[index2 * 6 + 0] = 0 + index2 * 4;
      pageMesh.indices[index2 * 6 + 1] = 1 + index2 * 4;
      pageMesh.indices[index2 * 6 + 2] = 2 + index2 * 4;
      pageMesh.indices[index2 * 6 + 3] = 0 + index2 * 4;
      pageMesh.indices[index2 * 6 + 4] = 2 + index2 * 4;
      pageMesh.indices[index2 * 6 + 5] = 3 + index2 * 4;
      pageMesh.vertices[index2 * 8 + 0] = xPos;
      pageMesh.vertices[index2 * 8 + 1] = yPos;
      pageMesh.vertices[index2 * 8 + 2] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index2 * 8 + 3] = yPos;
      pageMesh.vertices[index2 * 8 + 4] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index2 * 8 + 5] = yPos + textureFrame.height * scale;
      pageMesh.vertices[index2 * 8 + 6] = xPos;
      pageMesh.vertices[index2 * 8 + 7] = yPos + textureFrame.height * scale;
      pageMesh.uvs[index2 * 8 + 0] = textureUvs.x0;
      pageMesh.uvs[index2 * 8 + 1] = textureUvs.y0;
      pageMesh.uvs[index2 * 8 + 2] = textureUvs.x1;
      pageMesh.uvs[index2 * 8 + 3] = textureUvs.y1;
      pageMesh.uvs[index2 * 8 + 4] = textureUvs.x2;
      pageMesh.uvs[index2 * 8 + 5] = textureUvs.y2;
      pageMesh.uvs[index2 * 8 + 6] = textureUvs.x3;
      pageMesh.uvs[index2 * 8 + 7] = textureUvs.y3;
    }
    this._textWidth = maxLineWidth * scale;
    this._textHeight = (pos.y + data.lineHeight) * scale;
    for (var i in pagesMeshData) {
      var pageMeshData = pagesMeshData[i];
      if (this.anchor.x !== 0 || this.anchor.y !== 0) {
        var vertexCount = 0;
        var anchorOffsetX = this._textWidth * this.anchor.x;
        var anchorOffsetY = this._textHeight * this.anchor.y;
        for (var i_2 = 0; i_2 < pageMeshData.total; i_2++) {
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
        }
      }
      this._maxLineHeight = maxLineHeight * scale;
      var vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
      var textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
      var indexBuffer = pageMeshData.mesh.geometry.getIndex();
      vertexBuffer.data = pageMeshData.vertices;
      textureBuffer.data = pageMeshData.uvs;
      indexBuffer.data = pageMeshData.indices;
      vertexBuffer.update();
      textureBuffer.update();
      indexBuffer.update();
    }
    for (var i = 0; i < chars.length; i++) {
      charRenderDataPool.push(chars[i]);
    }
  };
  BitmapText.prototype.updateTransform = function() {
    this.validate();
    this.containerUpdateTransform();
  };
  BitmapText.prototype._render = function(renderer) {
    var _a2 = BitmapFont.available[this._fontName], distanceFieldRange = _a2.distanceFieldRange, distanceFieldType = _a2.distanceFieldType, size = _a2.size;
    if (distanceFieldType !== "none") {
      var _b2 = this.worldTransform, a = _b2.a, b = _b2.b, c = _b2.c, d = _b2.d;
      var dx = Math.sqrt(a * a + b * b);
      var dy = Math.sqrt(c * c + d * d);
      var worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
      var fontScale = this._fontSize / size;
      for (var _i = 0, _c2 = this._activePagesMeshData; _i < _c2.length; _i++) {
        var mesh = _c2[_i];
        mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * renderer.resolution;
      }
    }
    _super.prototype._render.call(this, renderer);
  };
  BitmapText.prototype.getLocalBounds = function() {
    this.validate();
    return _super.prototype.getLocalBounds.call(this);
  };
  BitmapText.prototype.validate = function() {
    if (this.dirty) {
      this.updateText();
      this.dirty = false;
    }
  };
  Object.defineProperty(BitmapText.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(value) {
      if (this._tint === value) {
        return;
      }
      this._tint = value;
      for (var i = 0; i < this._activePagesMeshData.length; i++) {
        this._activePagesMeshData[i].mesh.tint = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "align", {
    get: function() {
      return this._align;
    },
    set: function(value) {
      if (this._align !== value) {
        this._align = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "fontName", {
    get: function() {
      return this._fontName;
    },
    set: function(value) {
      if (!BitmapFont.available[value]) {
        throw new Error('Missing BitmapFont "' + value + '"');
      }
      if (this._fontName !== value) {
        this._fontName = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "fontSize", {
    get: function() {
      return this._fontSize;
    },
    set: function(value) {
      if (this._fontSize !== value) {
        this._fontSize = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "anchor", {
    get: function() {
      return this._anchor;
    },
    set: function(value) {
      if (typeof value === "number") {
        this._anchor.set(value);
      } else {
        this._anchor.copyFrom(value);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "text", {
    get: function() {
      return this._text;
    },
    set: function(text) {
      text = String(text === null || text === void 0 ? "" : text);
      if (this._text === text) {
        return;
      }
      this._text = text;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "maxWidth", {
    get: function() {
      return this._maxWidth;
    },
    set: function(value) {
      if (this._maxWidth === value) {
        return;
      }
      this._maxWidth = value;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "maxLineHeight", {
    get: function() {
      this.validate();
      return this._maxLineHeight;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "textWidth", {
    get: function() {
      this.validate();
      return this._textWidth;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "letterSpacing", {
    get: function() {
      return this._letterSpacing;
    },
    set: function(value) {
      if (this._letterSpacing !== value) {
        this._letterSpacing = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "roundPixels", {
    get: function() {
      return this._roundPixels;
    },
    set: function(value) {
      if (value !== this._roundPixels) {
        this._roundPixels = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "textHeight", {
    get: function() {
      this.validate();
      return this._textHeight;
    },
    enumerable: false,
    configurable: true
  });
  BitmapText.prototype.destroy = function(options) {
    var _textureCache = this._textureCache;
    for (var id in _textureCache) {
      var texture = _textureCache[id];
      texture.destroy();
      delete _textureCache[id];
    }
    this._textureCache = null;
    _super.prototype.destroy.call(this, options);
  };
  BitmapText.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
  };
  return BitmapText;
})(Container);
var BitmapFontLoader = function() {
  function BitmapFontLoader2() {
  }
  BitmapFontLoader2.add = function() {
    LoaderResource.setExtensionXhrType("fnt", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
  };
  BitmapFontLoader2.use = function(resource, next) {
    var format2 = autoDetectFormat(resource.data);
    if (!format2) {
      next();
      return;
    }
    var baseUrl = BitmapFontLoader2.getBaseUrl(this, resource);
    var data = format2.parse(resource.data);
    var textures = {};
    var completed = function(page) {
      textures[page.metadata.pageFile] = page.texture;
      if (Object.keys(textures).length === data.page.length) {
        resource.bitmapFont = BitmapFont.install(data, textures, true);
        next();
      }
    };
    for (var i = 0; i < data.page.length; ++i) {
      var pageFile = data.page[i].file;
      var url2 = baseUrl + pageFile;
      var exists = false;
      for (var name in this.resources) {
        var bitmapResource = this.resources[name];
        if (bitmapResource.url === url2) {
          bitmapResource.metadata.pageFile = pageFile;
          if (bitmapResource.texture) {
            completed(bitmapResource);
          } else {
            bitmapResource.onAfterMiddleware.add(completed);
          }
          exists = true;
          break;
        }
      }
      if (!exists) {
        var options = {
          crossOrigin: resource.crossOrigin,
          loadType: LoaderResource.LOAD_TYPE.IMAGE,
          metadata: Object.assign({ pageFile }, resource.metadata.imageMetadata),
          parentResource: resource
        };
        this.add(url2, options, completed);
      }
    }
  };
  BitmapFontLoader2.getBaseUrl = function(loader, resource) {
    var resUrl = !resource.isDataUrl ? BitmapFontLoader2.dirname(resource.url) : "";
    if (resource.isDataUrl) {
      if (resUrl === ".") {
        resUrl = "";
      }
      if (loader.baseUrl && resUrl) {
        if (loader.baseUrl.charAt(loader.baseUrl.length - 1) === "/") {
          resUrl += "/";
        }
      }
    }
    resUrl = resUrl.replace(loader.baseUrl, "");
    if (resUrl && resUrl.charAt(resUrl.length - 1) !== "/") {
      resUrl += "/";
    }
    return resUrl;
  };
  BitmapFontLoader2.dirname = function(url2) {
    var dir = url2.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
    if (dir === url2) {
      return ".";
    } else if (dir === "") {
      return "/";
    }
    return dir;
  };
  return BitmapFontLoader2;
}();
/*!
 * @pixi/filter-alpha - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/filter-alpha is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$7 = function(d, b) {
  extendStatics$7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$7(d, b);
};
function __extends$7(d, b) {
  extendStatics$7(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var fragment$4 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";
(function(_super) {
  __extends$7(AlphaFilter, _super);
  function AlphaFilter(alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    var _this = _super.call(this, defaultVertex$2, fragment$4, { uAlpha: 1 }) || this;
    _this.alpha = alpha;
    return _this;
  }
  Object.defineProperty(AlphaFilter.prototype, "alpha", {
    get: function() {
      return this.uniforms.uAlpha;
    },
    set: function(value) {
      this.uniforms.uAlpha = value;
    },
    enumerable: false,
    configurable: true
  });
  return AlphaFilter;
})(Filter);
/*!
 * @pixi/filter-blur - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/filter-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$6 = function(d, b) {
  extendStatics$6 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$6(d, b);
};
function __extends$6(d, b) {
  extendStatics$6(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var vertTemplate = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }";
function generateBlurVertSource(kernelSize, x) {
  var halfLength = Math.ceil(kernelSize / 2);
  var vertSource = vertTemplate;
  var blurLoop = "";
  var template;
  if (x) {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";
  } else {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  }
  for (var i = 0; i < kernelSize; i++) {
    var blur = template.replace("%index%", i.toString());
    blur = blur.replace("%sampleIndex%", i - (halfLength - 1) + ".0");
    blurLoop += blur;
    blurLoop += "\n";
  }
  vertSource = vertSource.replace("%blur%", blurLoop);
  vertSource = vertSource.replace("%size%", kernelSize.toString());
  return vertSource;
}
var GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
};
var fragTemplate = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join("\n");
function generateBlurFragSource(kernelSize) {
  var kernel = GAUSSIAN_VALUES[kernelSize];
  var halfLength = kernel.length;
  var fragSource = fragTemplate;
  var blurLoop = "";
  var template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
  var value;
  for (var i = 0; i < kernelSize; i++) {
    var blur = template.replace("%index%", i.toString());
    value = i;
    if (i >= halfLength) {
      value = kernelSize - i - 1;
    }
    blur = blur.replace("%value%", kernel[value].toString());
    blurLoop += blur;
    blurLoop += "\n";
  }
  fragSource = fragSource.replace("%blur%", blurLoop);
  fragSource = fragSource.replace("%size%", kernelSize.toString());
  return fragSource;
}
/*!
 * @pixi/constants - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$1;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV$1 || (ENV$1 = {}));
var RENDERER_TYPE$1;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE$1 || (RENDERER_TYPE$1 = {}));
var BUFFER_BITS$1;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS$1 || (BUFFER_BITS$1 = {}));
var BLEND_MODES$1;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES$1 || (BLEND_MODES$1 = {}));
var DRAW_MODES$1;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$1 || (DRAW_MODES$1 = {}));
var FORMATS$1;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS$1 || (FORMATS$1 = {}));
var TARGETS$1;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$1 || (TARGETS$1 = {}));
var TYPES$1;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES$1 || (TYPES$1 = {}));
var SAMPLER_TYPES$1;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES$1 || (SAMPLER_TYPES$1 = {}));
var SCALE_MODES$1;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES$1 || (SCALE_MODES$1 = {}));
var WRAP_MODES$1;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$1 || (WRAP_MODES$1 = {}));
var MIPMAP_MODES$1;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES$1 || (MIPMAP_MODES$1 = {}));
var ALPHA_MODES$1;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$1 || (ALPHA_MODES$1 = {}));
var CLEAR_MODES$1;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES$1 || (CLEAR_MODES$1 = {}));
var GC_MODES$1;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES$1 || (GC_MODES$1 = {}));
var PRECISION$1;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION$1 || (PRECISION$1 = {}));
var MASK_TYPES$1;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES$1 || (MASK_TYPES$1 = {}));
var MSAA_QUALITY$1;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY$1 || (MSAA_QUALITY$1 = {}));
var BUFFER_TYPE$1;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$1 || (BUFFER_TYPE$1 = {}));
var BlurFilterPass = function(_super) {
  __extends$6(BlurFilterPass2, _super);
  function BlurFilterPass2(horizontal, strength, quality, resolution, kernelSize) {
    if (strength === void 0) {
      strength = 8;
    }
    if (quality === void 0) {
      quality = 4;
    }
    if (resolution === void 0) {
      resolution = settings.FILTER_RESOLUTION;
    }
    if (kernelSize === void 0) {
      kernelSize = 5;
    }
    var _this = this;
    var vertSrc = generateBlurVertSource(kernelSize, horizontal);
    var fragSrc = generateBlurFragSource(kernelSize);
    _this = _super.call(this, vertSrc, fragSrc) || this;
    _this.horizontal = horizontal;
    _this.resolution = resolution;
    _this._quality = 0;
    _this.quality = quality;
    _this.blur = strength;
    return _this;
  }
  BlurFilterPass2.prototype.apply = function(filterManager, input, output, clearMode) {
    if (output) {
      if (this.horizontal) {
        this.uniforms.strength = 1 / output.width * (output.width / input.width);
      } else {
        this.uniforms.strength = 1 / output.height * (output.height / input.height);
      }
    } else {
      if (this.horizontal) {
        this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);
      } else {
        this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);
      }
    }
    this.uniforms.strength *= this.strength;
    this.uniforms.strength /= this.passes;
    if (this.passes === 1) {
      filterManager.applyFilter(this, input, output, clearMode);
    } else {
      var renderTarget = filterManager.getFilterTexture();
      var renderer = filterManager.renderer;
      var flip = input;
      var flop = renderTarget;
      this.state.blend = false;
      filterManager.applyFilter(this, flip, flop, CLEAR_MODES$1.CLEAR);
      for (var i = 1; i < this.passes - 1; i++) {
        filterManager.bindAndClear(flip, CLEAR_MODES$1.BLIT);
        this.uniforms.uSampler = flop;
        var temp2 = flop;
        flop = flip;
        flip = temp2;
        renderer.shader.bind(this);
        renderer.geometry.draw(5);
      }
      this.state.blend = true;
      filterManager.applyFilter(this, flop, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    }
  };
  Object.defineProperty(BlurFilterPass2.prototype, "blur", {
    get: function() {
      return this.strength;
    },
    set: function(value) {
      this.padding = 1 + Math.abs(value) * 2;
      this.strength = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilterPass2.prototype, "quality", {
    get: function() {
      return this._quality;
    },
    set: function(value) {
      this._quality = value;
      this.passes = value;
    },
    enumerable: false,
    configurable: true
  });
  return BlurFilterPass2;
}(Filter);
(function(_super) {
  __extends$6(BlurFilter, _super);
  function BlurFilter(strength, quality, resolution, kernelSize) {
    if (strength === void 0) {
      strength = 8;
    }
    if (quality === void 0) {
      quality = 4;
    }
    if (resolution === void 0) {
      resolution = settings.FILTER_RESOLUTION;
    }
    if (kernelSize === void 0) {
      kernelSize = 5;
    }
    var _this = _super.call(this) || this;
    _this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize);
    _this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize);
    _this.resolution = resolution;
    _this.quality = quality;
    _this.blur = strength;
    _this.repeatEdgePixels = false;
    return _this;
  }
  BlurFilter.prototype.apply = function(filterManager, input, output, clearMode) {
    var xStrength = Math.abs(this.blurXFilter.strength);
    var yStrength = Math.abs(this.blurYFilter.strength);
    if (xStrength && yStrength) {
      var renderTarget = filterManager.getFilterTexture();
      this.blurXFilter.apply(filterManager, input, renderTarget, CLEAR_MODES$1.CLEAR);
      this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    } else if (yStrength) {
      this.blurYFilter.apply(filterManager, input, output, clearMode);
    } else {
      this.blurXFilter.apply(filterManager, input, output, clearMode);
    }
  };
  BlurFilter.prototype.updatePadding = function() {
    if (this._repeatEdgePixels) {
      this.padding = 0;
    } else {
      this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
    }
  };
  Object.defineProperty(BlurFilter.prototype, "blur", {
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(value) {
      this.blurXFilter.blur = this.blurYFilter.blur = value;
      this.updatePadding();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "quality", {
    get: function() {
      return this.blurXFilter.quality;
    },
    set: function(value) {
      this.blurXFilter.quality = this.blurYFilter.quality = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "blurX", {
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(value) {
      this.blurXFilter.blur = value;
      this.updatePadding();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "blurY", {
    get: function() {
      return this.blurYFilter.blur;
    },
    set: function(value) {
      this.blurYFilter.blur = value;
      this.updatePadding();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "blendMode", {
    get: function() {
      return this.blurYFilter.blendMode;
    },
    set: function(value) {
      this.blurYFilter.blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "repeatEdgePixels", {
    get: function() {
      return this._repeatEdgePixels;
    },
    set: function(value) {
      this._repeatEdgePixels = value;
      this.updatePadding();
    },
    enumerable: false,
    configurable: true
  });
  return BlurFilter;
})(Filter);
/*!
 * @pixi/filter-color-matrix - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/filter-color-matrix is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$5 = function(d, b) {
  extendStatics$5 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$5(d, b);
};
function __extends$5(d, b) {
  extendStatics$5(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var fragment$3 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";
var ColorMatrixFilter = function(_super) {
  __extends$5(ColorMatrixFilter2, _super);
  function ColorMatrixFilter2() {
    var _this = this;
    var uniforms = {
      m: new Float32Array([
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]),
      uAlpha: 1
    };
    _this = _super.call(this, defaultFilterVertex, fragment$3, uniforms) || this;
    _this.alpha = 1;
    return _this;
  }
  ColorMatrixFilter2.prototype._loadMatrix = function(matrix, multiply) {
    if (multiply === void 0) {
      multiply = false;
    }
    var newMatrix = matrix;
    if (multiply) {
      this._multiply(newMatrix, this.uniforms.m, matrix);
      newMatrix = this._colorMatrix(newMatrix);
    }
    this.uniforms.m = newMatrix;
  };
  ColorMatrixFilter2.prototype._multiply = function(out, a, b) {
    out[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15];
    out[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16];
    out[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17];
    out[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18];
    out[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4];
    out[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15];
    out[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16];
    out[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17];
    out[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18];
    out[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9];
    out[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15];
    out[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16];
    out[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17];
    out[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18];
    out[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14];
    out[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15];
    out[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16];
    out[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17];
    out[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18];
    out[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19];
    return out;
  };
  ColorMatrixFilter2.prototype._colorMatrix = function(matrix) {
    var m = new Float32Array(matrix);
    m[4] /= 255;
    m[9] /= 255;
    m[14] /= 255;
    m[19] /= 255;
    return m;
  };
  ColorMatrixFilter2.prototype.brightness = function(b, multiply) {
    var matrix = [
      b,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.tint = function(color, multiply) {
    var r = color >> 16 & 255;
    var g = color >> 8 & 255;
    var b = color & 255;
    var matrix = [
      r / 255,
      0,
      0,
      0,
      0,
      0,
      g / 255,
      0,
      0,
      0,
      0,
      0,
      b / 255,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.greyscale = function(scale, multiply) {
    var matrix = [
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.blackAndWhite = function(multiply) {
    var matrix = [
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.hue = function(rotation, multiply) {
    rotation = (rotation || 0) / 180 * Math.PI;
    var cosR = Math.cos(rotation);
    var sinR = Math.sin(rotation);
    var sqrt = Math.sqrt;
    var w = 1 / 3;
    var sqrW = sqrt(w);
    var a00 = cosR + (1 - cosR) * w;
    var a01 = w * (1 - cosR) - sqrW * sinR;
    var a02 = w * (1 - cosR) + sqrW * sinR;
    var a10 = w * (1 - cosR) + sqrW * sinR;
    var a11 = cosR + w * (1 - cosR);
    var a12 = w * (1 - cosR) - sqrW * sinR;
    var a20 = w * (1 - cosR) - sqrW * sinR;
    var a21 = w * (1 - cosR) + sqrW * sinR;
    var a22 = cosR + w * (1 - cosR);
    var matrix = [
      a00,
      a01,
      a02,
      0,
      0,
      a10,
      a11,
      a12,
      0,
      0,
      a20,
      a21,
      a22,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.contrast = function(amount, multiply) {
    var v = (amount || 0) + 1;
    var o = -0.5 * (v - 1);
    var matrix = [
      v,
      0,
      0,
      0,
      o,
      0,
      v,
      0,
      0,
      o,
      0,
      0,
      v,
      0,
      o,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.saturate = function(amount, multiply) {
    if (amount === void 0) {
      amount = 0;
    }
    var x = amount * 2 / 3 + 1;
    var y = (x - 1) * -0.5;
    var matrix = [
      x,
      y,
      y,
      0,
      0,
      y,
      x,
      y,
      0,
      0,
      y,
      y,
      x,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.desaturate = function() {
    this.saturate(-1);
  };
  ColorMatrixFilter2.prototype.negative = function(multiply) {
    var matrix = [
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.sepia = function(multiply) {
    var matrix = [
      0.393,
      0.7689999,
      0.18899999,
      0,
      0,
      0.349,
      0.6859999,
      0.16799999,
      0,
      0,
      0.272,
      0.5339999,
      0.13099999,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.technicolor = function(multiply) {
    var matrix = [
      1.9125277891456083,
      -0.8545344976951645,
      -0.09155508482755585,
      0,
      11.793603434377337,
      -0.3087833385928097,
      1.7658908555458428,
      -0.10601743074722245,
      0,
      -70.35205161461398,
      -0.231103377548616,
      -0.7501899197440212,
      1.847597816108189,
      0,
      30.950940869491138,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.polaroid = function(multiply) {
    var matrix = [
      1.438,
      -0.062,
      -0.062,
      0,
      0,
      -0.122,
      1.378,
      -0.122,
      0,
      0,
      -0.016,
      -0.016,
      1.483,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.toBGR = function(multiply) {
    var matrix = [
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.kodachrome = function(multiply) {
    var matrix = [
      1.1285582396593525,
      -0.3967382283601348,
      -0.03992559172921793,
      0,
      63.72958762196502,
      -0.16404339962244616,
      1.0835251566291304,
      -0.05498805115633132,
      0,
      24.732407896706203,
      -0.16786010706155763,
      -0.5603416277695248,
      1.6014850761964943,
      0,
      35.62982807460946,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.browni = function(multiply) {
    var matrix = [
      0.5997023498159715,
      0.34553243048391263,
      -0.2708298674538042,
      0,
      47.43192855600873,
      -0.037703249837783157,
      0.8609577587992641,
      0.15059552388459913,
      0,
      -36.96841498319127,
      0.24113635128153335,
      -0.07441037908422492,
      0.44972182064877153,
      0,
      -7.562075277591283,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.vintage = function(multiply) {
    var matrix = [
      0.6279345635605994,
      0.3202183420819367,
      -0.03965408211312453,
      0,
      9.651285835294123,
      0.02578397704808868,
      0.6441188644374771,
      0.03259127616149294,
      0,
      7.462829176470591,
      0.0466055556782719,
      -0.0851232987247891,
      0.5241648018700465,
      0,
      5.159190588235296,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.colorTone = function(desaturation, toned, lightColor, darkColor, multiply) {
    desaturation = desaturation || 0.2;
    toned = toned || 0.15;
    lightColor = lightColor || 16770432;
    darkColor = darkColor || 3375104;
    var lR = (lightColor >> 16 & 255) / 255;
    var lG = (lightColor >> 8 & 255) / 255;
    var lB = (lightColor & 255) / 255;
    var dR = (darkColor >> 16 & 255) / 255;
    var dG = (darkColor >> 8 & 255) / 255;
    var dB = (darkColor & 255) / 255;
    var matrix = [
      0.3,
      0.59,
      0.11,
      0,
      0,
      lR,
      lG,
      lB,
      desaturation,
      0,
      dR,
      dG,
      dB,
      toned,
      0,
      lR - dR,
      lG - dG,
      lB - dB,
      0,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.night = function(intensity, multiply) {
    intensity = intensity || 0.1;
    var matrix = [
      intensity * -2,
      -intensity,
      0,
      0,
      0,
      -intensity,
      0,
      intensity,
      0,
      0,
      0,
      intensity,
      intensity * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.predator = function(amount, multiply) {
    var matrix = [
      11.224130630493164 * amount,
      -4.794486999511719 * amount,
      -2.8746118545532227 * amount,
      0 * amount,
      0.40342438220977783 * amount,
      -3.6330697536468506 * amount,
      9.193157196044922 * amount,
      -2.951810836791992 * amount,
      0 * amount,
      -1.316135048866272 * amount,
      -3.2184197902679443 * amount,
      -4.2375030517578125 * amount,
      7.476448059082031 * amount,
      0 * amount,
      0.8044459223747253 * amount,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.lsd = function(multiply) {
    var matrix = [
      2,
      -0.4,
      0.5,
      0,
      0,
      -0.5,
      2,
      -0.4,
      0,
      0,
      -0.4,
      -0.5,
      3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.reset = function() {
    var matrix = [
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, false);
  };
  Object.defineProperty(ColorMatrixFilter2.prototype, "matrix", {
    get: function() {
      return this.uniforms.m;
    },
    set: function(value) {
      this.uniforms.m = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorMatrixFilter2.prototype, "alpha", {
    get: function() {
      return this.uniforms.uAlpha;
    },
    set: function(value) {
      this.uniforms.uAlpha = value;
    },
    enumerable: false,
    configurable: true
  });
  return ColorMatrixFilter2;
}(Filter);
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
/*!
 * @pixi/filter-displacement - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/filter-displacement is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$4 = function(d, b) {
  extendStatics$4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$4(d, b);
};
function __extends$4(d, b) {
  extendStatics$4(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var fragment$2 = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n";
var vertex$1 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n";
(function(_super) {
  __extends$4(DisplacementFilter, _super);
  function DisplacementFilter(sprite, scale) {
    var _this = this;
    var maskMatrix = new Matrix();
    sprite.renderable = false;
    _this = _super.call(this, vertex$1, fragment$2, {
      mapSampler: sprite._texture,
      filterMatrix: maskMatrix,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    }) || this;
    _this.maskSprite = sprite;
    _this.maskMatrix = maskMatrix;
    if (scale === null || scale === void 0) {
      scale = 20;
    }
    _this.scale = new Point(scale, scale);
    return _this;
  }
  DisplacementFilter.prototype.apply = function(filterManager, input, output, clearMode) {
    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
    this.uniforms.scale.x = this.scale.x;
    this.uniforms.scale.y = this.scale.y;
    var wt = this.maskSprite.worldTransform;
    var lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
    var lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
    if (lenX !== 0 && lenY !== 0) {
      this.uniforms.rotation[0] = wt.a / lenX;
      this.uniforms.rotation[1] = wt.b / lenX;
      this.uniforms.rotation[2] = wt.c / lenY;
      this.uniforms.rotation[3] = wt.d / lenY;
    }
    filterManager.applyFilter(this, input, output, clearMode);
  };
  Object.defineProperty(DisplacementFilter.prototype, "map", {
    get: function() {
      return this.uniforms.mapSampler;
    },
    set: function(value) {
      this.uniforms.mapSampler = value;
    },
    enumerable: false,
    configurable: true
  });
  return DisplacementFilter;
})(Filter);
/*!
 * @pixi/filter-fxaa - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/filter-fxaa is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$3 = function(d, b) {
  extendStatics$3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$3(d, b);
};
function __extends$3(d, b) {
  extendStatics$3(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var vertex = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n";
var fragment$1 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
(function(_super) {
  __extends$3(FXAAFilter, _super);
  function FXAAFilter() {
    return _super.call(this, vertex, fragment$1) || this;
  }
  return FXAAFilter;
})(Filter);
/*!
 * @pixi/filter-noise - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/filter-noise is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$2 = function(d, b) {
  extendStatics$2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$2(d, b);
};
function __extends$2(d, b) {
  extendStatics$2(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var fragment = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n";
(function(_super) {
  __extends$2(NoiseFilter, _super);
  function NoiseFilter(noise, seed) {
    if (noise === void 0) {
      noise = 0.5;
    }
    if (seed === void 0) {
      seed = Math.random();
    }
    var _this = _super.call(this, defaultFilterVertex, fragment, {
      uNoise: 0,
      uSeed: 0
    }) || this;
    _this.noise = noise;
    _this.seed = seed;
    return _this;
  }
  Object.defineProperty(NoiseFilter.prototype, "noise", {
    get: function() {
      return this.uniforms.uNoise;
    },
    set: function(value) {
      this.uniforms.uNoise = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NoiseFilter.prototype, "seed", {
    get: function() {
      return this.uniforms.uSeed;
    },
    set: function(value) {
      this.uniforms.uSeed = value;
    },
    enumerable: false,
    configurable: true
  });
  return NoiseFilter;
})(Filter);
/*!
 * @pixi/mixin-cache-as-bitmap - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*!
 * @pixi/constants - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV || (ENV = {}));
var RENDERER_TYPE;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE || (RENDERER_TYPE = {}));
var BUFFER_BITS;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS || (BUFFER_BITS = {}));
var BLEND_MODES;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES || (BLEND_MODES = {}));
var DRAW_MODES;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES || (DRAW_MODES = {}));
var FORMATS;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS || (FORMATS = {}));
var TARGETS;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS || (TARGETS = {}));
var TYPES;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES || (TYPES = {}));
var SAMPLER_TYPES;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES || (SAMPLER_TYPES = {}));
var SCALE_MODES;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES || (SCALE_MODES = {}));
var WRAP_MODES;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES || (WRAP_MODES = {}));
var MIPMAP_MODES;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES || (MIPMAP_MODES = {}));
var ALPHA_MODES;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES || (ALPHA_MODES = {}));
var CLEAR_MODES;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES || (CLEAR_MODES = {}));
var GC_MODES;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES || (GC_MODES = {}));
var PRECISION;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION || (PRECISION = {}));
var MASK_TYPES;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES || (MASK_TYPES = {}));
var MSAA_QUALITY;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY || (MSAA_QUALITY = {}));
var BUFFER_TYPE;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE || (BUFFER_TYPE = {}));
var _tempMatrix = new Matrix();
DisplayObject.prototype._cacheAsBitmap = false;
DisplayObject.prototype._cacheData = null;
DisplayObject.prototype._cacheAsBitmapResolution = null;
DisplayObject.prototype._cacheAsBitmapMultisample = MSAA_QUALITY.NONE;
var CacheData = function() {
  function CacheData2() {
    this.textureCacheId = null;
    this.originalRender = null;
    this.originalRenderCanvas = null;
    this.originalCalculateBounds = null;
    this.originalGetLocalBounds = null;
    this.originalUpdateTransform = null;
    this.originalDestroy = null;
    this.originalMask = null;
    this.originalFilterArea = null;
    this.originalContainsPoint = null;
    this.sprite = null;
  }
  return CacheData2;
}();
Object.defineProperties(DisplayObject.prototype, {
  cacheAsBitmapResolution: {
    get: function() {
      return this._cacheAsBitmapResolution;
    },
    set: function(resolution) {
      if (resolution === this._cacheAsBitmapResolution) {
        return;
      }
      this._cacheAsBitmapResolution = resolution;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmapMultisample: {
    get: function() {
      return this._cacheAsBitmapMultisample;
    },
    set: function(multisample) {
      if (multisample === this._cacheAsBitmapMultisample) {
        return;
      }
      this._cacheAsBitmapMultisample = multisample;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmap: {
    get: function() {
      return this._cacheAsBitmap;
    },
    set: function(value) {
      if (this._cacheAsBitmap === value) {
        return;
      }
      this._cacheAsBitmap = value;
      var data;
      if (value) {
        if (!this._cacheData) {
          this._cacheData = new CacheData();
        }
        data = this._cacheData;
        data.originalRender = this.render;
        data.originalRenderCanvas = this.renderCanvas;
        data.originalUpdateTransform = this.updateTransform;
        data.originalCalculateBounds = this.calculateBounds;
        data.originalGetLocalBounds = this.getLocalBounds;
        data.originalDestroy = this.destroy;
        data.originalContainsPoint = this.containsPoint;
        data.originalMask = this._mask;
        data.originalFilterArea = this.filterArea;
        this.render = this._renderCached;
        this.renderCanvas = this._renderCachedCanvas;
        this.destroy = this._cacheAsBitmapDestroy;
      } else {
        data = this._cacheData;
        if (data.sprite) {
          this._destroyCachedDisplayObject();
        }
        this.render = data.originalRender;
        this.renderCanvas = data.originalRenderCanvas;
        this.calculateBounds = data.originalCalculateBounds;
        this.getLocalBounds = data.originalGetLocalBounds;
        this.destroy = data.originalDestroy;
        this.updateTransform = data.originalUpdateTransform;
        this.containsPoint = data.originalContainsPoint;
        this._mask = data.originalMask;
        this.filterArea = data.originalFilterArea;
      }
    }
  }
});
DisplayObject.prototype._renderCached = function _renderCached(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObject(renderer);
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._render(renderer);
};
DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {
  var _a2;
  if (this._cacheData && this._cacheData.sprite) {
    return;
  }
  var cacheAlpha = this.alpha;
  this.alpha = 1;
  renderer.batch.flush();
  var bounds = this.getLocalBounds(null, true).clone();
  if (this.filters && this.filters.length) {
    var padding = this.filters[0].padding;
    bounds.pad(padding);
  }
  bounds.ceil(settings.RESOLUTION);
  var cachedRenderTexture = renderer.renderTexture.current;
  var cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();
  var cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone();
  var cachedProjectionTransform = renderer.projection.transform;
  var renderTexture = RenderTexture.create({
    width: bounds.width,
    height: bounds.height,
    resolution: this.cacheAsBitmapResolution || renderer.resolution,
    multisample: (_a2 = this.cacheAsBitmapMultisample) !== null && _a2 !== void 0 ? _a2 : renderer.multisample
  });
  var textureCacheId = "cacheAsBitmap_" + uid();
  this._cacheData.textureCacheId = textureCacheId;
  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  Texture.addToCache(renderTexture, textureCacheId);
  var m = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
  this.render = this._cacheData.originalRender;
  renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });
  renderer.framebuffer.blit();
  renderer.projection.transform = cachedProjectionTransform;
  renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);
  this.render = this._renderCached;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  var cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.enableTempParent();
    this.updateTransform();
    this.disableTempParent(null);
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObjectCanvas(renderer);
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._renderCanvas(renderer);
};
DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {
  if (this._cacheData && this._cacheData.sprite) {
    return;
  }
  var bounds = this.getLocalBounds(null, true);
  var cacheAlpha = this.alpha;
  this.alpha = 1;
  var cachedRenderTarget = renderer.context;
  var cachedProjectionTransform = renderer._projTransform;
  bounds.ceil(settings.RESOLUTION);
  var renderTexture = RenderTexture.create({ width: bounds.width, height: bounds.height });
  var textureCacheId = "cacheAsBitmap_" + uid();
  this._cacheData.textureCacheId = textureCacheId;
  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  Texture.addToCache(renderTexture, textureCacheId);
  var m = _tempMatrix;
  this.transform.localTransform.copyTo(m);
  m.invert();
  m.tx -= bounds.x;
  m.ty -= bounds.y;
  this.renderCanvas = this._cacheData.originalRenderCanvas;
  renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });
  renderer.context = cachedRenderTarget;
  renderer._projTransform = cachedProjectionTransform;
  this.renderCanvas = this._renderCachedCanvas;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  var cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.parent = renderer._tempDisplayObjectParent;
    this.updateTransform();
    this.parent = null;
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
  this._bounds.clear();
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite._calculateBounds();
  this._bounds.updateID = this._boundsID;
};
DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
  return this._cacheData.sprite.getLocalBounds(null);
};
DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
  this._cacheData.sprite._texture.destroy(true);
  this._cacheData.sprite = null;
  BaseTexture.removeFromCache(this._cacheData.textureCacheId);
  Texture.removeFromCache(this._cacheData.textureCacheId);
  this._cacheData.textureCacheId = null;
};
DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {
  this.cacheAsBitmap = false;
  this.destroy(options);
};
/*!
 * @pixi/mixin-get-child-by-name - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
DisplayObject.prototype.name = null;
Container.prototype.getChildByName = function getChildByName(name, deep) {
  for (var i = 0, j = this.children.length; i < j; i++) {
    if (this.children[i].name === name) {
      return this.children[i];
    }
  }
  if (deep) {
    for (var i = 0, j = this.children.length; i < j; i++) {
      var child = this.children[i];
      if (!child.getChildByName) {
        continue;
      }
      var target = this.children[i].getChildByName(name, true);
      if (target) {
        return target;
      }
    }
  }
  return null;
};
/*!
 * @pixi/mixin-get-global-position - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/mixin-get-global-position is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
DisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point, skipUpdate) {
  if (point === void 0) {
    point = new Point();
  }
  if (skipUpdate === void 0) {
    skipUpdate = false;
  }
  if (this.parent) {
    this.parent.toGlobal(this.position, point, skipUpdate);
  } else {
    point.x = this.position.x;
    point.y = this.position.y;
  }
  return point;
};
/*!
 * @pixi/mesh-extras - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/mesh-extras is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$1 = function(d, b) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$1(d, b);
};
function __extends$1(d, b) {
  extendStatics$1(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var PlaneGeometry = function(_super) {
  __extends$1(PlaneGeometry2, _super);
  function PlaneGeometry2(width, height, segWidth, segHeight) {
    if (width === void 0) {
      width = 100;
    }
    if (height === void 0) {
      height = 100;
    }
    if (segWidth === void 0) {
      segWidth = 10;
    }
    if (segHeight === void 0) {
      segHeight = 10;
    }
    var _this = _super.call(this) || this;
    _this.segWidth = segWidth;
    _this.segHeight = segHeight;
    _this.width = width;
    _this.height = height;
    _this.build();
    return _this;
  }
  PlaneGeometry2.prototype.build = function() {
    var total = this.segWidth * this.segHeight;
    var verts = [];
    var uvs = [];
    var indices2 = [];
    var segmentsX = this.segWidth - 1;
    var segmentsY = this.segHeight - 1;
    var sizeX = this.width / segmentsX;
    var sizeY = this.height / segmentsY;
    for (var i = 0; i < total; i++) {
      var x = i % this.segWidth;
      var y = i / this.segWidth | 0;
      verts.push(x * sizeX, y * sizeY);
      uvs.push(x / segmentsX, y / segmentsY);
    }
    var totalSub = segmentsX * segmentsY;
    for (var i = 0; i < totalSub; i++) {
      var xpos = i % segmentsX;
      var ypos = i / segmentsX | 0;
      var value = ypos * this.segWidth + xpos;
      var value2 = ypos * this.segWidth + xpos + 1;
      var value3 = (ypos + 1) * this.segWidth + xpos;
      var value4 = (ypos + 1) * this.segWidth + xpos + 1;
      indices2.push(value, value2, value3, value2, value4, value3);
    }
    this.buffers[0].data = new Float32Array(verts);
    this.buffers[1].data = new Float32Array(uvs);
    this.indexBuffer.data = new Uint16Array(indices2);
    this.buffers[0].update();
    this.buffers[1].update();
    this.indexBuffer.update();
  };
  return PlaneGeometry2;
}(MeshGeometry);
var RopeGeometry = function(_super) {
  __extends$1(RopeGeometry2, _super);
  function RopeGeometry2(width, points, textureScale) {
    if (width === void 0) {
      width = 200;
    }
    if (textureScale === void 0) {
      textureScale = 0;
    }
    var _this = _super.call(this, new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6)) || this;
    _this.points = points;
    _this._width = width;
    _this.textureScale = textureScale;
    _this.build();
    return _this;
  }
  Object.defineProperty(RopeGeometry2.prototype, "width", {
    get: function() {
      return this._width;
    },
    enumerable: false,
    configurable: true
  });
  RopeGeometry2.prototype.build = function() {
    var points = this.points;
    if (!points) {
      return;
    }
    var vertexBuffer = this.getBuffer("aVertexPosition");
    var uvBuffer = this.getBuffer("aTextureCoord");
    var indexBuffer = this.getIndex();
    if (points.length < 1) {
      return;
    }
    if (vertexBuffer.data.length / 4 !== points.length) {
      vertexBuffer.data = new Float32Array(points.length * 4);
      uvBuffer.data = new Float32Array(points.length * 4);
      indexBuffer.data = new Uint16Array((points.length - 1) * 6);
    }
    var uvs = uvBuffer.data;
    var indices2 = indexBuffer.data;
    uvs[0] = 0;
    uvs[1] = 0;
    uvs[2] = 0;
    uvs[3] = 1;
    var amount = 0;
    var prev = points[0];
    var textureWidth = this._width * this.textureScale;
    var total = points.length;
    for (var i = 0; i < total; i++) {
      var index2 = i * 4;
      if (this.textureScale > 0) {
        var dx = prev.x - points[i].x;
        var dy = prev.y - points[i].y;
        var distance = Math.sqrt(dx * dx + dy * dy);
        prev = points[i];
        amount += distance / textureWidth;
      } else {
        amount = i / (total - 1);
      }
      uvs[index2] = amount;
      uvs[index2 + 1] = 0;
      uvs[index2 + 2] = amount;
      uvs[index2 + 3] = 1;
    }
    var indexCount = 0;
    for (var i = 0; i < total - 1; i++) {
      var index2 = i * 2;
      indices2[indexCount++] = index2;
      indices2[indexCount++] = index2 + 1;
      indices2[indexCount++] = index2 + 2;
      indices2[indexCount++] = index2 + 2;
      indices2[indexCount++] = index2 + 1;
      indices2[indexCount++] = index2 + 3;
    }
    uvBuffer.update();
    indexBuffer.update();
    this.updateVertices();
  };
  RopeGeometry2.prototype.updateVertices = function() {
    var points = this.points;
    if (points.length < 1) {
      return;
    }
    var lastPoint = points[0];
    var nextPoint;
    var perpX = 0;
    var perpY = 0;
    var vertices = this.buffers[0].data;
    var total = points.length;
    for (var i = 0; i < total; i++) {
      var point = points[i];
      var index2 = i * 4;
      if (i < points.length - 1) {
        nextPoint = points[i + 1];
      } else {
        nextPoint = point;
      }
      perpY = -(nextPoint.x - lastPoint.x);
      perpX = nextPoint.y - lastPoint.y;
      var perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
      var num = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
      perpX /= perpLength;
      perpY /= perpLength;
      perpX *= num;
      perpY *= num;
      vertices[index2] = point.x + perpX;
      vertices[index2 + 1] = point.y + perpY;
      vertices[index2 + 2] = point.x - perpX;
      vertices[index2 + 3] = point.y - perpY;
      lastPoint = point;
    }
    this.buffers[0].update();
  };
  RopeGeometry2.prototype.update = function() {
    if (this.textureScale > 0) {
      this.build();
    } else {
      this.updateVertices();
    }
  };
  return RopeGeometry2;
}(MeshGeometry);
(function(_super) {
  __extends$1(SimpleRope, _super);
  function SimpleRope(texture, points, textureScale) {
    if (textureScale === void 0) {
      textureScale = 0;
    }
    var _this = this;
    var ropeGeometry = new RopeGeometry(texture.height, points, textureScale);
    var meshMaterial = new MeshMaterial(texture);
    if (textureScale > 0) {
      texture.baseTexture.wrapMode = WRAP_MODES$3.REPEAT;
    }
    _this = _super.call(this, ropeGeometry, meshMaterial) || this;
    _this.autoUpdate = true;
    return _this;
  }
  SimpleRope.prototype._render = function(renderer) {
    var geometry = this.geometry;
    if (this.autoUpdate || geometry._width !== this.shader.texture.height) {
      geometry._width = this.shader.texture.height;
      geometry.update();
    }
    _super.prototype._render.call(this, renderer);
  };
  return SimpleRope;
})(Mesh);
var SimplePlane = function(_super) {
  __extends$1(SimplePlane2, _super);
  function SimplePlane2(texture, verticesX, verticesY) {
    var _this = this;
    var planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
    var meshMaterial = new MeshMaterial(Texture.WHITE);
    _this = _super.call(this, planeGeometry, meshMaterial) || this;
    _this.texture = texture;
    _this.autoResize = true;
    return _this;
  }
  SimplePlane2.prototype.textureUpdated = function() {
    this._textureID = this.shader.texture._updateID;
    var geometry = this.geometry;
    var _a2 = this.shader.texture, width = _a2.width, height = _a2.height;
    if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
      geometry.width = this.shader.texture.width;
      geometry.height = this.shader.texture.height;
      geometry.build();
    }
  };
  Object.defineProperty(SimplePlane2.prototype, "texture", {
    get: function() {
      return this.shader.texture;
    },
    set: function(value) {
      if (this.shader.texture === value) {
        return;
      }
      this.shader.texture = value;
      this._textureID = -1;
      if (value.baseTexture.valid) {
        this.textureUpdated();
      } else {
        value.once("update", this.textureUpdated, this);
      }
    },
    enumerable: false,
    configurable: true
  });
  SimplePlane2.prototype._render = function(renderer) {
    if (this._textureID !== this.shader.texture._updateID) {
      this.textureUpdated();
    }
    _super.prototype._render.call(this, renderer);
  };
  SimplePlane2.prototype.destroy = function(options) {
    this.shader.texture.off("update", this.textureUpdated, this);
    _super.prototype.destroy.call(this, options);
  };
  return SimplePlane2;
}(Mesh);
(function(_super) {
  __extends$1(SimpleMesh, _super);
  function SimpleMesh(texture, vertices, uvs, indices2, drawMode) {
    if (texture === void 0) {
      texture = Texture.EMPTY;
    }
    var _this = this;
    var geometry = new MeshGeometry(vertices, uvs, indices2);
    geometry.getBuffer("aVertexPosition").static = false;
    var meshMaterial = new MeshMaterial(texture);
    _this = _super.call(this, geometry, meshMaterial, null, drawMode) || this;
    _this.autoUpdate = true;
    return _this;
  }
  Object.defineProperty(SimpleMesh.prototype, "vertices", {
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(value) {
      this.geometry.getBuffer("aVertexPosition").data = value;
    },
    enumerable: false,
    configurable: true
  });
  SimpleMesh.prototype._render = function(renderer) {
    if (this.autoUpdate) {
      this.geometry.getBuffer("aVertexPosition").update();
    }
    _super.prototype._render.call(this, renderer);
  };
  return SimpleMesh;
})(Mesh);
var DEFAULT_BORDER_SIZE = 10;
(function(_super) {
  __extends$1(NineSlicePlane, _super);
  function NineSlicePlane(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
    if (leftWidth === void 0) {
      leftWidth = DEFAULT_BORDER_SIZE;
    }
    if (topHeight === void 0) {
      topHeight = DEFAULT_BORDER_SIZE;
    }
    if (rightWidth === void 0) {
      rightWidth = DEFAULT_BORDER_SIZE;
    }
    if (bottomHeight === void 0) {
      bottomHeight = DEFAULT_BORDER_SIZE;
    }
    var _this = _super.call(this, Texture.WHITE, 4, 4) || this;
    _this._origWidth = texture.orig.width;
    _this._origHeight = texture.orig.height;
    _this._width = _this._origWidth;
    _this._height = _this._origHeight;
    _this._leftWidth = leftWidth;
    _this._rightWidth = rightWidth;
    _this._topHeight = topHeight;
    _this._bottomHeight = bottomHeight;
    _this.texture = texture;
    return _this;
  }
  NineSlicePlane.prototype.textureUpdated = function() {
    this._textureID = this.shader.texture._updateID;
    this._refresh();
  };
  Object.defineProperty(NineSlicePlane.prototype, "vertices", {
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(value) {
      this.geometry.getBuffer("aVertexPosition").data = value;
    },
    enumerable: false,
    configurable: true
  });
  NineSlicePlane.prototype.updateHorizontalVertices = function() {
    var vertices = this.vertices;
    var scale = this._getMinScale();
    vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
    vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
    vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
  };
  NineSlicePlane.prototype.updateVerticalVertices = function() {
    var vertices = this.vertices;
    var scale = this._getMinScale();
    vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
    vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
    vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
  };
  NineSlicePlane.prototype._getMinScale = function() {
    var w = this._leftWidth + this._rightWidth;
    var scaleW = this._width > w ? 1 : this._width / w;
    var h = this._topHeight + this._bottomHeight;
    var scaleH = this._height > h ? 1 : this._height / h;
    var scale = Math.min(scaleW, scaleH);
    return scale;
  };
  Object.defineProperty(NineSlicePlane.prototype, "width", {
    get: function() {
      return this._width;
    },
    set: function(value) {
      this._width = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "height", {
    get: function() {
      return this._height;
    },
    set: function(value) {
      this._height = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "leftWidth", {
    get: function() {
      return this._leftWidth;
    },
    set: function(value) {
      this._leftWidth = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "rightWidth", {
    get: function() {
      return this._rightWidth;
    },
    set: function(value) {
      this._rightWidth = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "topHeight", {
    get: function() {
      return this._topHeight;
    },
    set: function(value) {
      this._topHeight = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "bottomHeight", {
    get: function() {
      return this._bottomHeight;
    },
    set: function(value) {
      this._bottomHeight = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  NineSlicePlane.prototype._refresh = function() {
    var texture = this.texture;
    var uvs = this.geometry.buffers[1].data;
    this._origWidth = texture.orig.width;
    this._origHeight = texture.orig.height;
    var _uvw = 1 / this._origWidth;
    var _uvh = 1 / this._origHeight;
    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
    this.updateHorizontalVertices();
    this.updateVerticalVertices();
    this.geometry.buffers[0].update();
    this.geometry.buffers[1].update();
  };
  return NineSlicePlane;
})(SimplePlane);
/*!
 * @pixi/sprite-animated - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * @pixi/sprite-animated is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var AnimatedSprite = function(_super) {
  __extends(AnimatedSprite2, _super);
  function AnimatedSprite2(textures, autoUpdate) {
    if (autoUpdate === void 0) {
      autoUpdate = true;
    }
    var _this = _super.call(this, textures[0] instanceof Texture ? textures[0] : textures[0].texture) || this;
    _this._textures = null;
    _this._durations = null;
    _this._autoUpdate = autoUpdate;
    _this._isConnectedToTicker = false;
    _this.animationSpeed = 1;
    _this.loop = true;
    _this.updateAnchor = false;
    _this.onComplete = null;
    _this.onFrameChange = null;
    _this.onLoop = null;
    _this._currentTime = 0;
    _this._playing = false;
    _this._previousFrame = null;
    _this.textures = textures;
    return _this;
  }
  AnimatedSprite2.prototype.stop = function() {
    if (!this._playing) {
      return;
    }
    this._playing = false;
    if (this._autoUpdate && this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  };
  AnimatedSprite2.prototype.play = function() {
    if (this._playing) {
      return;
    }
    this._playing = true;
    if (this._autoUpdate && !this._isConnectedToTicker) {
      Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);
      this._isConnectedToTicker = true;
    }
  };
  AnimatedSprite2.prototype.gotoAndStop = function(frameNumber) {
    this.stop();
    var previousFrame = this.currentFrame;
    this._currentTime = frameNumber;
    if (previousFrame !== this.currentFrame) {
      this.updateTexture();
    }
  };
  AnimatedSprite2.prototype.gotoAndPlay = function(frameNumber) {
    var previousFrame = this.currentFrame;
    this._currentTime = frameNumber;
    if (previousFrame !== this.currentFrame) {
      this.updateTexture();
    }
    this.play();
  };
  AnimatedSprite2.prototype.update = function(deltaTime) {
    if (!this._playing) {
      return;
    }
    var elapsed = this.animationSpeed * deltaTime;
    var previousFrame = this.currentFrame;
    if (this._durations !== null) {
      var lag = this._currentTime % 1 * this._durations[this.currentFrame];
      lag += elapsed / 60 * 1e3;
      while (lag < 0) {
        this._currentTime--;
        lag += this._durations[this.currentFrame];
      }
      var sign2 = Math.sign(this.animationSpeed * deltaTime);
      this._currentTime = Math.floor(this._currentTime);
      while (lag >= this._durations[this.currentFrame]) {
        lag -= this._durations[this.currentFrame] * sign2;
        this._currentTime += sign2;
      }
      this._currentTime += lag / this._durations[this.currentFrame];
    } else {
      this._currentTime += elapsed;
    }
    if (this._currentTime < 0 && !this.loop) {
      this.gotoAndStop(0);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (this._currentTime >= this._textures.length && !this.loop) {
      this.gotoAndStop(this._textures.length - 1);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (previousFrame !== this.currentFrame) {
      if (this.loop && this.onLoop) {
        if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {
          this.onLoop();
        } else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {
          this.onLoop();
        }
      }
      this.updateTexture();
    }
  };
  AnimatedSprite2.prototype.updateTexture = function() {
    var currentFrame = this.currentFrame;
    if (this._previousFrame === currentFrame) {
      return;
    }
    this._previousFrame = currentFrame;
    this._texture = this._textures[currentFrame];
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    this.uvs = this._texture._uvs.uvsFloat32;
    if (this.updateAnchor) {
      this._anchor.copyFrom(this._texture.defaultAnchor);
    }
    if (this.onFrameChange) {
      this.onFrameChange(this.currentFrame);
    }
  };
  AnimatedSprite2.prototype.destroy = function(options) {
    this.stop();
    _super.prototype.destroy.call(this, options);
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
  };
  AnimatedSprite2.fromFrames = function(frames) {
    var textures = [];
    for (var i = 0; i < frames.length; ++i) {
      textures.push(Texture.from(frames[i]));
    }
    return new AnimatedSprite2(textures);
  };
  AnimatedSprite2.fromImages = function(images) {
    var textures = [];
    for (var i = 0; i < images.length; ++i) {
      textures.push(Texture.from(images[i]));
    }
    return new AnimatedSprite2(textures);
  };
  Object.defineProperty(AnimatedSprite2.prototype, "totalFrames", {
    get: function() {
      return this._textures.length;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimatedSprite2.prototype, "textures", {
    get: function() {
      return this._textures;
    },
    set: function(value) {
      if (value[0] instanceof Texture) {
        this._textures = value;
        this._durations = null;
      } else {
        this._textures = [];
        this._durations = [];
        for (var i = 0; i < value.length; i++) {
          this._textures.push(value[i].texture);
          this._durations.push(value[i].time);
        }
      }
      this._previousFrame = null;
      this.gotoAndStop(0);
      this.updateTexture();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimatedSprite2.prototype, "currentFrame", {
    get: function() {
      var currentFrame = Math.floor(this._currentTime) % this._textures.length;
      if (currentFrame < 0) {
        currentFrame += this._textures.length;
      }
      return currentFrame;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimatedSprite2.prototype, "playing", {
    get: function() {
      return this._playing;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimatedSprite2.prototype, "autoUpdate", {
    get: function() {
      return this._autoUpdate;
    },
    set: function(value) {
      if (value !== this._autoUpdate) {
        this._autoUpdate = value;
        if (!this._autoUpdate && this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
          Ticker.shared.add(this.update, this);
          this._isConnectedToTicker = true;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  return AnimatedSprite2;
}(Sprite);
/*!
 * pixi.js - v6.2.2
 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
Renderer$1.registerPlugin("accessibility", AccessibilityManager);
Renderer$1.registerPlugin("extract", Extract);
Renderer$1.registerPlugin("interaction", InteractionManager);
Renderer$1.registerPlugin("particle", ParticleRenderer);
Renderer$1.registerPlugin("prepare", Prepare);
Renderer$1.registerPlugin("batch", BatchRenderer);
Renderer$1.registerPlugin("tilingSprite", TilingSpriteRenderer);
Loader.registerPlugin(BitmapFontLoader);
Loader.registerPlugin(CompressedTextureLoader);
Loader.registerPlugin(DDSLoader);
Loader.registerPlugin(KTXLoader);
Loader.registerPlugin(SpritesheetLoader);
Application.registerPlugin(TickerPlugin);
Application.registerPlugin(AppLoaderPlugin);
const JOINS_SUBDIVISION = 32;
const CENTER_DEPTH = -1;
const EDGE_DEPTH = 1;
const vertexShaderSource = `
    attribute vec3 a_position;

    uniform vec2 u_resolution;
    uniform vec2 u_offset;
    
    void main() {
        // i heard pixi can handle the projection using some uniform but fuck that amirite

        float x = (a_position[0] + u_offset[0]) / u_resolution[0] * 2.0 - 1.0;
        float y = (a_position[1] + u_offset[1]) / u_resolution[1] * 2.0 - 1.0;
        float z = a_position[2];

        gl_Position = vec4(x, y, z, 1);
    }
`;
const fragmentShaderSource = `
    precision mediump float;

    vec4 borderColor = vec4(1,1,1,1);
    
    float contrast = 0.5; // is it really called contrast doe ???
    float brightness = 0.75;

    float bodyEnd = 0.825;
    float borderEnd = 0.925;
    float shadowEnd = 1.0;

    bool isBody(float u){
        return u >= -1.0 && u < bodyEnd;
    }

    bool isBorder(float u){
        return u >= bodyEnd && u < borderEnd;
    }

    bool isShadow(float u){
        return u >= borderEnd && u <= shadowEnd;
    }

    vec4 getBodyColor(float u){
        float u2 = smoothstep(1.0 + contrast, -1.0 - contrast , u) * brightness;
        return vec4(u2,u2,u2, 1.0);
    }

    vec4 getShadowColor(float u){
        float alpha = smoothstep(shadowEnd, borderEnd, u) / 2.0;
        return vec4(0,0,0,alpha);
    }

    void main(){
        float u = gl_FragCoord.z;

        if(isBody(u)){
            gl_FragColor = getBodyColor(u);
            return;
        }

        if(isBorder(u)){
            gl_FragColor = borderColor;
            return;
        }

        if(isShadow(u)){
            gl_FragColor = getShadowColor(u);
            return;
        }
    }

    // oh no!! rough edges????
    // https://www.youtube.com/watch?v=kXLu_x0SRm4
`;
function calculateQuad(points, radius, offset = 0) {
  const positions = [];
  const indices2 = [];
  for (let i = 0; i < points.length - 1; i++) {
    const curr = points[i];
    const next = points[i + 1];
    const vec = Vector2.Subtract(next, curr);
    const normRight = Vector2.PerpendicularRight(vec).normalize().multiply(radius);
    const normLeft = Vector2.PerpendicularLeft(vec).normalize().multiply(radius);
    const p1 = Vector2.Add(curr, normLeft);
    const p2 = Vector2.Add(next, normLeft);
    const p3 = curr.clone();
    const p4 = next.clone();
    const p5 = Vector2.Add(curr, normRight);
    const p6 = Vector2.Add(next, normRight);
    for (let j = 0; j < 4; j++) {
      indices2.push(offset + i * 6 + j + 0);
      indices2.push(offset + i * 6 + j + 1);
      indices2.push(offset + i * 6 + j + 2);
    }
    positions.push(p1[0], p1[1], EDGE_DEPTH, p2[0], p2[1], EDGE_DEPTH, p3[0], p3[1], CENTER_DEPTH, p4[0], p4[1], CENTER_DEPTH, p5[0], p5[1], EDGE_DEPTH, p6[0], p6[1], EDGE_DEPTH);
  }
  return { positions, indices: indices2 };
}
function calculateJoins(points, radius, offset = 0) {
  const positions = [];
  const indices2 = [];
  for (let i = 0; i < points.length; i++) {
    const curr = points[i];
    positions.push(curr[0], curr[1], CENTER_DEPTH);
    for (let j = 0; j < JOINS_SUBDIVISION; j++) {
      const angle = j / JOINS_SUBDIVISION * Math.PI * 2;
      const x = points[i][0] + radius * Math.cos(angle);
      const y = points[i][1] + radius * Math.sin(angle);
      const z = EDGE_DEPTH;
      positions.push(x, y, z);
    }
    const indexOffset = offset + i * (JOINS_SUBDIVISION + 1);
    for (let j = 0; j < JOINS_SUBDIVISION; j++) {
      let index1 = 0;
      let index2 = 0 + j + 1;
      let index3 = (0 + j + 1) % JOINS_SUBDIVISION + 1;
      index1 += indexOffset;
      index2 += indexOffset;
      index3 += indexOffset;
      indices2.push(index1, index2, index3);
    }
  }
  return { positions, indices: indices2 };
}
function calculateSliderVertices(points, radius) {
  let positions = [];
  let indices2 = [];
  const vertX = [];
  const vertY = [];
  let indicesOffset = 0;
  const quads = calculateQuad(points, radius, indicesOffset);
  positions = positions.concat(quads.positions);
  indices2 = indices2.concat(quads.indices);
  indicesOffset += positions.length / 3;
  const joins = calculateJoins(points, radius, indicesOffset);
  positions = positions.concat(joins.positions);
  indices2 = indices2.concat(joins.indices);
  for (let i = 0; i < positions.length; i += 2) {
    vertX.push(positions[i]);
    vertY.push(positions[i + 1]);
  }
  const positionBuffer = new Float32Array(positions);
  const indexBuffer = new Uint16Array(indices2);
  return { positionBuffer, indexBuffer };
}
function calculateMinMax(positions) {
  let tempMinX = positions[0];
  let tempMaxX = positions[0];
  let tempMinY = positions[1];
  let tempMaxY = positions[1];
  for (let i = 3; i < positions.length; i += 3) {
    if (positions[i] > tempMaxX) {
      tempMaxX = positions[i];
    } else if (positions[i] < tempMinX) {
      tempMinX = positions[i];
    }
    if (positions[i + 1] > tempMaxY) {
      tempMaxY = positions[i + 1];
    } else if (positions[i + 1] < tempMinY) {
      tempMinY = positions[i + 1];
    }
  }
  return [tempMinX, tempMaxX, tempMinY, tempMaxY];
}
const _SliderTextureGenerator = class {
  static createTexture(points, radius) {
    const { positionBuffer, indexBuffer } = calculateSliderVertices(points, radius);
    const [minX, maxX, minY, maxY] = calculateMinMax(positionBuffer);
    const width = maxX - minX;
    const height = maxY - minY;
    const geometry = new Geometry();
    geometry.addAttribute("a_position", positionBuffer, 3);
    geometry.addIndex(indexBuffer);
    const uniform = {
      u_resolution: [width, height],
      u_offset: [-minX, -minY]
    };
    const shader = Shader.from(vertexShaderSource, fragmentShaderSource, uniform);
    const mesh = new Mesh(geometry, shader);
    mesh.state.depthTest = true;
    const texture = RenderTexture.create({ width, height });
    texture.framebuffer.enableDepth();
    const renderer = this.renderer;
    renderer.render(mesh, { renderTexture: texture });
    return texture;
  }
};
let SliderTextureGenerator = _SliderTextureGenerator;
SliderTextureGenerator.setRenderer = (renderer) => {
  _SliderTextureGenerator.renderer = renderer;
};
const getFileExtension = (filename) => {
  return filename.split(".").pop() || "";
};
const omitFileExtension = (filename) => {
  return filename.split(".").slice(0, -1).join(".") || filename;
};
const compareNameOnly = (a, b) => {
  return omitFileExtension(a) === omitFileExtension(b);
};
function getFileType(fileName) {
  const fileExt = getFileExtension(fileName);
  return getExtensionType(fileExt);
}
function getExtensionType(extension) {
  const audioFormats = ["mp3", "wav", "ogg", "mpga"];
  const imageFormats = ["png", "jpg", "jpeg", "gif", "bmp", "webp"];
  const videoFormats = ["mp4", "webm", "mkv", "mpeg", "avi"];
  if (audioFormats.includes(extension)) {
    return "audio";
  } else if (imageFormats.includes(extension)) {
    return "image";
  } else if (videoFormats.includes(extension)) {
    return "video";
  }
  return "unknown";
}
function isRetinaFile(filename) {
  return filename.includes("@2x");
}
const image = [
  {
    name: "approachcircle",
    animatable: false
  },
  {
    name: "hitcircle",
    animatable: false
  },
  {
    name: "hitcircleoverlay",
    animatable: false
  },
  {
    name: "followpoint",
    animatable: true
  },
  {
    name: "reversearrow",
    animatable: false
  },
  {
    name: "sliderfollowcircle",
    animatable: true
  },
  {
    name: "sliderb",
    animatable: true,
    nohyphen: true
  },
  {
    name: "sliderscorepoint",
    animatable: false
  },
  {
    name: "spinner-background",
    animatable: false
  },
  {
    name: "spinner-circle",
    animatable: false
  },
  {
    name: "spinner-clear",
    animatable: false
  },
  {
    name: "spinner-metre",
    animatable: false
  },
  {
    name: "spinner-middle",
    animatable: false
  },
  {
    name: "spinner-spin",
    animatable: false
  },
  {
    name: "cursor",
    animatable: false
  }
];
const audio = [
  {
    name: "drum-hitnormal",
    type: "hitsound"
  },
  {
    name: "drum-hitclap",
    type: "hitsound"
  },
  {
    name: "drum-hitfinish",
    type: "hitsound"
  },
  {
    name: "drum-hitwhistle",
    type: "hitsound"
  },
  {
    name: "drum-slidertick",
    type: "hitsound"
  },
  {
    name: "drum-sliderslide",
    type: "hitsound"
  },
  {
    name: "drum-sliderwhistle",
    type: "hitsound"
  },
  {
    name: "normal-hitnormal",
    type: "hitsound"
  },
  {
    name: "normal-hitclap",
    type: "hitsound"
  },
  {
    name: "normal-hitfinish",
    type: "hitsound"
  },
  {
    name: "normal-hitwhistle",
    type: "hitsound"
  },
  {
    name: "normal-slidertick",
    type: "hitsound"
  },
  {
    name: "normal-sliderslide",
    type: "hitsound"
  },
  {
    name: "normal-sliderwhistle",
    type: "hitsound"
  },
  {
    name: "soft-hitnormal",
    type: "hitsound"
  },
  {
    name: "soft-hitclap",
    type: "hitsound"
  },
  {
    name: "soft-hitfinish",
    type: "hitsound"
  },
  {
    name: "soft-hitwhistle",
    type: "hitsound"
  },
  {
    name: "soft-slidertick",
    type: "hitsound"
  },
  {
    name: "soft-sliderslide",
    type: "hitsound"
  },
  {
    name: "soft-sliderwhistle",
    type: "hitsound"
  }
];
var assetsDeps = {
  image,
  audio
};
function createAnimatable(filename, resources2) {
  var _a2, _b2;
  const filesWithExtension = Object.keys(resources2);
  const filesWithoutExtension = filesWithExtension.map(omitFileExtension);
  const normalizedFilenames = filesWithoutExtension.map((name) => name.replace("@2x", ""));
  const animationTextures = [];
  const singleSpriteIndex = normalizedFilenames.findIndex((assetName) => assetName === filename);
  if (singleSpriteIndex > -1) {
    const key = filesWithExtension[singleSpriteIndex];
    const resource = resources2[key];
    animationTextures.push((_a2 = resource.texture) != null ? _a2 : Texture.EMPTY);
  } else {
    for (let i = 0; i < normalizedFilenames.length; i++) {
      const targetName = filename + i.toString();
      const spriteIndex = normalizedFilenames.findIndex((assetName) => assetName === targetName);
      if (spriteIndex === -1)
        break;
      const key = filesWithExtension[spriteIndex];
      const resource = resources2[key];
      animationTextures.push((_b2 = resource.texture) != null ? _b2 : Texture.EMPTY);
    }
  }
  return new AnimatedSprite(animationTextures);
}
function getAnimationAssets(assets, imageDep) {
  const mixedSequence = assets.filter((skinAsset) => {
    const skinAssetName = omitFileExtension(skinAsset.name);
    const substr = skinAssetName.substring(0, imageDep.name.length);
    if (substr !== imageDep.name)
      return false;
    const normalizedName = skinAssetName.replace("@2x", "");
    if (normalizedName === imageDep.name)
      return true;
    const hyphen = imageDep.nohyphen ? "" : "-";
    const indexString = normalizedName.replace(imageDep.name + hyphen, "");
    return !isNaN(parseInt(indexString));
  });
  let sequence = mixedSequence.filter((sequence2) => isRetinaFile(sequence2.name));
  if (sequence.length === 0) {
    sequence = mixedSequence;
  }
  let orderedSequence = [];
  for (let i = 0; i < sequence.length; i++) {
    const image2 = sequence.find((sequence2) => {
      const normalizedName = omitFileExtension(sequence2.name).replace("@2x", "");
      const hyphen = imageDep.nohyphen ? "" : "-";
      const matchingString = imageDep.name + hyphen + i.toString();
      return normalizedName === matchingString;
    });
    if (!image2)
      break;
    const fileExtension = getFileExtension(image2.name);
    const retinaTag = isRetinaFile(image2.name) ? "@2x" : "";
    image2.name = imageDep.name + i.toString() + retinaTag + "." + fileExtension;
    image2.sequenceIndex = i;
    orderedSequence.push(image2);
  }
  if (orderedSequence.length === 0) {
    const image2 = sequence.find((sequence2) => {
      const normalizedName = omitFileExtension(sequence2.name).replace("@2x", "");
      return imageDep.name === normalizedName;
    });
    if (image2) {
      const fileExtension = getFileExtension(image2.name);
      const retinaTag = isRetinaFile(image2.name) ? "@2x" : "";
      image2.name = imageDep.name + retinaTag + "." + fileExtension;
      image2.sequenceIndex = 0;
      orderedSequence.push(image2);
    }
  }
  return orderedSequence;
}
function addImageDependencies(assets, result, missingAssets) {
  const imageDeps = assetsDeps.image;
  imageDeps.forEach((imageDep) => {
    if (imageDep.animatable) {
      const animationAssets = getAnimationAssets(assets, imageDep);
      result.push(...animationAssets);
      return;
    }
    let assetReference = assets.find((asset) => compareNameOnly(asset.name, imageDep.name + "@2x"));
    assetReference = assetReference != null ? assetReference : assets.find((asset) => compareNameOnly(asset.name, imageDep.name));
    if (assetReference) {
      result.push(assetReference);
    } else {
      missingAssets.push(imageDep.name);
    }
  });
}
function addAudioDependencies(assets, result, missingAssets) {
  const audioDeps = assetsDeps.audio;
  audioDeps.forEach((audioDep) => {
    let assetReference = assets.find((asset) => compareNameOnly(asset.name, audioDep.name));
    if (assetReference) {
      result.push(assetReference);
    } else {
      missingAssets.push(audioDep.name);
    }
  });
}
class AssetsLoader {
  constructor() {
    this.skinLoader = new Loader();
    this.beatmapLoader = new Loader();
    this._cachedTextures = {};
    this.ignoreBeatmapSkins = false;
  }
  static get instance() {
    var _a2;
    return (_a2 = this._instance) != null ? _a2 : this._instance = new AssetsLoader();
  }
  use(fn) {
    this.skinLoader.use(fn);
    this.beatmapLoader.use(fn);
  }
  get resources() {
    let resources2 = {};
    if (this.ignoreBeatmapSkins) {
      resources2 = __spreadValues(__spreadValues({}, this.beatmapLoader.resources), this.skinLoader.resources);
    } else {
      resources2 = __spreadValues(__spreadValues({}, this.skinLoader.resources), this.beatmapLoader.resources);
    }
    return resources2;
  }
  loadSkin(skinElements) {
    return load(this.skinLoader, skinElements);
  }
  resetSkin() {
    clearTextureCache();
    this.skinLoader.reset();
  }
  loadBeatmap(beatmapAssets) {
    return load(this.beatmapLoader, beatmapAssets);
  }
  resetBeatmap() {
    clearTextureCache();
    this.beatmapLoader.reset();
  }
  async onComplete(callbackFn) {
    await Promise.all([promisifyLoader(this.skinLoader), promisifyLoader(this.beatmapLoader)]);
    callbackFn(this.resources);
  }
  _getCachedTexture(name) {
    return this._cachedTextures[name];
  }
  _setCachedTexture(name, texture) {
    this._cachedTextures[name] = texture;
  }
  getTexture(name) {
    var _a2;
    const cached = this._getCachedTexture(name);
    let nameWithExtension = "";
    if (!cached || !cached.valid) {
      nameWithExtension = this.findAssetFullName(name + "@2x", this.resources);
      if (!nameWithExtension) {
        nameWithExtension = this.findAssetFullName(name, this.resources);
      }
      const texture = (((_a2 = this.resources[nameWithExtension]) == null ? void 0 : _a2.texture) || Texture.EMPTY).clone();
      this._setCachedTexture(nameWithExtension, texture);
    }
    return this._getCachedTexture(nameWithExtension);
  }
  getAnimation(name) {
    return createAnimatable(name, this.resources);
  }
  findAssetFullName(name, resource) {
    const filesWithExtension = Object.keys(resource);
    const filesWithoutExtension = filesWithExtension.map(omitFileExtension);
    let index2 = filesWithoutExtension.indexOf(name);
    return filesWithExtension[index2];
  }
}
function promisifyLoader(loader) {
  return new Promise((resolve2, reject2) => {
    loader.onComplete.add(() => {
      resolve2();
    });
    loader.onError.add(() => {
      reject2();
    });
  });
}
function load(loader, assets) {
  return new Promise((resolve2, reject2) => {
    assets.forEach((element) => {
      const { name, url: url2, mimeType, sequenceIndex } = element;
      let metadata = { mimeType };
      metadata = __spreadProps(__spreadValues({}, metadata), {
        resolution: isRetinaFile(name) ? 2 : 1,
        resourceOptions: { sequenceIndex }
      });
      loader.add(name, url2, { xhrType: LoaderResource.XHR_RESPONSE_TYPE.BLOB, metadata });
    });
    loader.onError.add((error) => {
      reject2(error.message);
    });
    loader.load(() => {
      resolve2();
    });
  });
}
function getBeatmapDependencies(beatmapAssets, beatmap) {
  const dependencies = [];
  const beatmapDeps = beatmap.getAssetsFilename();
  beatmapDeps.forEach((depFilename) => {
    let assetReference = beatmapAssets.find((asset) => compareNameOnly(asset.name, depFilename + "@2x"));
    assetReference = assetReference != null ? assetReference : beatmapAssets.find((asset) => compareNameOnly(asset.name, depFilename));
    if (assetReference) {
      dependencies.push(assetReference);
    }
  });
  return dependencies;
}
function getSkinDependencies(skinAssets) {
  const dependencies = [];
  const missingAssets = [];
  addImageDependencies(skinAssets, dependencies, missingAssets);
  addAudioDependencies(skinAssets, dependencies, missingAssets);
  if (missingAssets.length > 0) {
    console.warn(`Missing assets: ${missingAssets.join(", ")}`);
  }
  return dependencies;
}
class Background extends Container {
  constructor(application, backgroundConfig) {
    super();
    this.application = application;
    this.blackRect = new Graphics();
    this.backgroundSprite = new Sprite();
    this._brightness = 1;
    this.fit = "none";
    this.blackRect.beginFill(0);
    this.blackRect.drawRect(0, 0, this.canvasWidth, this.canvasHeight);
    const bgAnchorX = this.canvasWidth / 2;
    const bgAnchorY = this.canvasHeight / 2;
    this.backgroundSprite.transform.position.set(bgAnchorX, bgAnchorY);
    this.backgroundSprite.anchor.set(0.5, 0.5);
    this.addChild(this.blackRect);
    this.addChild(this.backgroundSprite);
    if (!backgroundConfig)
      return;
    const { texture, brightness, fit } = backgroundConfig;
    this._brightness = brightness != null ? brightness : 1;
    fit && (this.fit = fit);
    texture && this.setImage(texture);
  }
  get brightness() {
    return this._brightness;
  }
  set brightness(brightnessValue) {
    if (brightnessValue > 1) {
      this._brightness = 1;
    } else if (brightnessValue < 0) {
      this._brightness = 0;
    } else {
      this._brightness = brightnessValue;
    }
    this.backgroundSprite.alpha = this.brightness;
  }
  get canvasWidth() {
    return this.application.view.width;
  }
  get canvasHeight() {
    return this.application.view.height;
  }
  setImage(texture) {
    this.backgroundSprite.alpha = this.brightness;
    this.backgroundSprite.texture = texture;
    switch (this.fit) {
      case "horizontal": {
        const scale = this.canvasWidth / texture.width;
        this.backgroundSprite.scale.set(scale);
        break;
      }
      case "vertical": {
        const scale = this.canvasHeight / texture.height;
        this.backgroundSprite.scale.set(scale);
        break;
      }
    }
  }
  loadBeatmap(beatmap) {
    const fullFileName = beatmap.getBackgroundFileNames()[0] || "";
    const fileName = omitFileExtension(fullFileName);
    const texture = AssetsLoader.instance.getTexture(fileName);
    this.setImage(texture);
  }
  draw(timestamp) {
  }
}
function getPlayfieldScale(screenWidth, screenHeight) {
  const widthRatio = screenWidth / 512;
  const heightRatio = screenHeight / 384;
  return Math.min(widthRatio, heightRatio);
}
function calculateFitRatio(fromWidth, fromHeight, toWidth, toHeight) {
  const widthRatio = fromWidth / toWidth;
  const heightRatio = fromHeight / toHeight;
  return Math.min(widthRatio, heightRatio);
}
function hexToInt(hex) {
  if (hex.charAt(0) === "#") {
    hex = hex.slice(1);
  }
  if (hex.length != 6) {
    return NaN;
  }
  return parseInt(hex, 16);
}
function intToRGB(i) {
  const r = i >> 16 & 255;
  const g = i >> 8 & 255;
  const b = i & 255;
  return [r, g, b];
}
function rgbToInt(r, g, b) {
  return (r << 16) + (g << 8) + b;
}
const RGBToHSB = (r, g, b) => {
  r /= 255;
  g /= 255;
  b /= 255;
  const v = Math.max(r, g, b), n = v - Math.min(r, g, b);
  const h = n === 0 ? 0 : n && v === r ? (g - b) / n : v === g ? 2 + (b - r) / n : 4 + (r - g) / n;
  return [60 * (h < 0 ? h + 6 : h), v && n / v * 100, v * 100];
};
const HSBToRGB = (h, s, b) => {
  s /= 100;
  b /= 100;
  const k = (n) => (n + h / 60) % 6;
  const f = (n) => b * (1 - s * Math.max(0, Math.min(k(n), 4 - k(n), 1)));
  return [255 * f(5), 255 * f(3), 255 * f(1)];
};
function createCircle(hitCircle, scale) {
  const { comboCount, colour } = hitCircle;
  const texture = AssetsLoader.instance.getTexture("hitcircle");
  const hitCircleSprite = new Sprite(texture);
  hitCircleSprite.scale.set(scale);
  hitCircleSprite.tint = hexToInt(colour);
  hitCircleSprite.anchor.set(0.5, 0.5);
  const hcOverlayTexture = AssetsLoader.instance.getTexture("hitcircleoverlay");
  const sHCOverlay = new Sprite(hcOverlayTexture);
  sHCOverlay.scale.set(scale);
  sHCOverlay.anchor.set(0.5, 0.5);
  const style = new TextStyle({
    fill: "white",
    fontSize: scale * 56,
    strokeThickness: 3
  });
  const circleNumber = new Text(comboCount.toString(), style);
  circleNumber.anchor.set(0.5, 0.5);
  const circle = new Container();
  circle.addChild(hitCircleSprite);
  circle.addChild(sHCOverlay);
  circle.addChild(circleNumber);
  circle.alpha = 0.8;
  return circle;
}
function createApproachCircle$1(scale) {
  const texture = AssetsLoader.instance.getTexture("approachcircle");
  const ac = new Sprite(texture);
  ac.scale.set(scale);
  ac.anchor.set(0.5, 0.5);
  const acContainer = new Container();
  acContainer.addChild(ac);
  return acContainer;
}
class DrawableHitCircle extends Container {
  constructor(hitCircle, fieldScale) {
    super();
    this.hitCircle = hitCircle;
    const startPos = hitCircle.getStackedStartPos();
    const x = startPos[0] * fieldScale;
    const y = startPos[1] * fieldScale;
    this.origin = [x, y];
    const hitCirclePixelRadius = hitCircle.difficulty.getObjectRadius() * fieldScale;
    this.textureScale = hitCirclePixelRadius / 64;
    this.circle = createCircle(hitCircle, this.textureScale);
    this.approachCircle = createApproachCircle$1(this.textureScale);
    this.addChild(this.circle);
    this.addChild(this.approachCircle);
    this.position.set(x, y);
    this.visible = false;
  }
  draw(timestamp) {
    const visible = this.hitCircle.isVisibleAt(timestamp);
    this.visible = visible;
    if (!visible)
      return;
    const { opacity, scale, approachCircleScale, approachCircleOpacity, positionOffset } = this.hitCircle.drawable;
    this.circle.alpha = opacity.value;
    this.circle.scale.set(scale.value);
    this.approachCircle.alpha = approachCircleOpacity.value;
    this.approachCircle.scale.set(approachCircleScale.value);
    this.position.x = this.origin[0] + positionOffset.x.value;
    this.position.y = this.origin[1] + positionOffset.y.value;
  }
}
function createSliderBody(path, radius) {
  const points = path.points;
  let minPoint = [points[0][0], points[0][1]];
  for (let i = 1; i < points.length; i++) {
    if (points[i][0] < minPoint[0])
      minPoint[0] = points[i][0];
    if (points[i][1] < minPoint[1])
      minPoint[1] = points[i][1];
  }
  minPoint[0] -= radius;
  minPoint[1] -= radius;
  const texture = SliderTextureGenerator.createTexture(path.points, radius);
  const sprite = new Sprite(texture);
  sprite.position.set(minPoint[0], minPoint[1]);
  sprite.alpha = 0.8;
  return sprite;
}
function createSliderHead(slider, textureScale) {
  const color = hexToInt(slider.colour);
  const count = slider.comboCount;
  const hitTexture = AssetsLoader.instance.getTexture("hitcircle");
  const hitSprite = new Sprite(hitTexture);
  hitSprite.tint = color;
  hitSprite.anchor.set(0.5);
  hitSprite.scale.set(textureScale);
  const overlayTexture = AssetsLoader.instance.getTexture("hitcircleoverlay");
  const overlaySprite = new Sprite(overlayTexture);
  overlaySprite.anchor.set(0.5, 0.5);
  overlaySprite.scale.set(textureScale);
  const style = new TextStyle({
    fill: "white",
    fontSize: textureScale * 56,
    strokeThickness: 3
  });
  const number = new Text(count.toString(), style);
  number.anchor.set(0.5, 0.5);
  const sliderHead = new Container();
  sliderHead.addChild(hitSprite);
  sliderHead.addChild(overlaySprite);
  sliderHead.addChild(number);
  return sliderHead;
}
function createSliderBall(textureScale) {
  const sliderBall = AssetsLoader.instance.getAnimation("sliderb");
  sliderBall.anchor.set(0.5, 0.5);
  sliderBall.scale.set(textureScale);
  sliderBall.alpha = 0;
  sliderBall.play();
  return sliderBall;
}
function createSliderFollower(textureScale) {
  const sliderFollower = AssetsLoader.instance.getAnimation("sliderfollowcircle");
  sliderFollower.anchor.set(0.5, 0.5);
  sliderFollower.scale.set(textureScale);
  sliderFollower.play();
  const sliderFollowerContainer = new Container();
  sliderFollowerContainer.alpha = 0;
  sliderFollowerContainer.addChild(sliderFollower);
  return sliderFollowerContainer;
}
function createApproachCircle(textureScale) {
  const texture = AssetsLoader.instance.getTexture("approachcircle");
  const approachCircle = new Sprite(texture);
  approachCircle.scale.set(textureScale);
  approachCircle.anchor.set(0.5, 0.5);
  const approachCircleContainer = new Container();
  approachCircleContainer.addChild(approachCircle);
  return approachCircleContainer;
}
function createSliderReverses(slider, textureScale, fieldScale) {
  const stackedSliderReverses = slider.getStackedReverseTicks();
  const sliderReverses = new Container();
  for (const sliderReverse of stackedSliderReverses) {
    const reverseTexture = AssetsLoader.instance.getTexture("reversearrow");
    const reverse = new Sprite(reverseTexture);
    reverse.scale.set(textureScale);
    reverse.anchor.set(0.5);
    const relativePos = [
      (sliderReverse.position[0] - slider.startPos[0]) * fieldScale,
      (sliderReverse.position[1] - slider.startPos[1]) * fieldScale
    ];
    const reverseContainer = new Container();
    reverseContainer.addChild(reverse);
    reverseContainer.position.set(relativePos[0], relativePos[1]);
    reverseContainer.rotation = sliderReverse.isReversed ? slider.endAngle : slider.startAngle;
    sliderReverses.addChild(reverseContainer);
  }
  return sliderReverses;
}
function createSliderTicks(slider, textureScale, fieldScale) {
  const stackedSliderTicks = slider.getStackedSliderTicks();
  const tickTexture = AssetsLoader.instance.getTexture("sliderscorepoint");
  const sliderTicks = new Container();
  for (const sliderTick of stackedSliderTicks) {
    const tick = new Sprite(tickTexture);
    tick.scale.set(textureScale);
    tick.anchor.set(0.5, 0.5);
    const relativeTickPos = [
      (sliderTick.position[0] - slider.getStackedStartPos()[0]) * fieldScale,
      (sliderTick.position[1] - slider.getStackedStartPos()[1]) * fieldScale
    ];
    const tickContainer = new Container();
    tickContainer.addChild(tick);
    tickContainer.position.set(relativeTickPos[0], relativeTickPos[1]);
    sliderTicks.addChild(tickContainer);
  }
  return sliderTicks;
}
class DrawableSlider extends Container {
  constructor(slider, fieldScale) {
    super();
    this.slider = slider;
    this.fieldScale = fieldScale;
    const startPos = slider.getStackedStartPos();
    const x = startPos[0] * fieldScale;
    const y = startPos[1] * fieldScale;
    this.linePath = slider.getStackedCurvePath();
    const hitCirclePixelRadius = slider.difficulty.getObjectRadius() * fieldScale;
    this.textureScale = hitCirclePixelRadius / 64;
    this.linePath.scale(fieldScale);
    this.linePath.translate(-this.linePath.points[0][0], -this.linePath.points[0][1]);
    this.sliderBody = createSliderBody(this.linePath, hitCirclePixelRadius);
    this.sliderApproachCircle = createApproachCircle(this.textureScale);
    this.sliderHead = createSliderHead(this.slider, this.textureScale);
    this.sliderBall = createSliderBall(this.textureScale);
    this.sliderFollower = createSliderFollower(this.textureScale);
    this.sliderReverses = createSliderReverses(this.slider, this.textureScale, this.fieldScale);
    this.sliderTicks = createSliderTicks(this.slider, this.textureScale, this.fieldScale);
    this.addChild(this.sliderBody);
    this.addChild(this.sliderReverses);
    this.addChild(this.sliderBall);
    this.addChild(this.sliderHead);
    this.addChild(this.sliderTicks);
    this.addChild(this.sliderFollower);
    this.addChild(this.sliderApproachCircle);
    this.position.set(x, y);
    this.visible = false;
  }
  draw(timestamp) {
    const visible = this.slider.isVisibleAt(timestamp);
    this.visible = visible;
    if (!visible)
      return;
    const {
      progressPosition,
      bodyOpacity,
      headOpacity,
      ballOpacity,
      ballRotation,
      approachCircleOpacity,
      approachCircleScale,
      followCircleOpacity,
      followCircleScale
    } = this.slider.drawable;
    this.sliderBody.alpha = bodyOpacity.value;
    this.sliderHead.alpha = headOpacity.value;
    this.sliderApproachCircle.alpha = approachCircleOpacity.value;
    this.sliderApproachCircle.scale.set(approachCircleScale.value);
    const ballPos = [
      (progressPosition[0] - this.slider.getStackedStartPos()[0]) * this.fieldScale,
      (progressPosition[1] - this.slider.getStackedStartPos()[1]) * this.fieldScale
    ];
    this.sliderBall.transform.position.set(ballPos[0], ballPos[1]);
    this.sliderBall.alpha = ballOpacity.value;
    this.sliderBall.rotation = ballRotation;
    this.sliderFollower.transform.position.set(ballPos[0], ballPos[1]);
    this.sliderFollower.alpha = followCircleOpacity.value;
    this.sliderFollower.scale.set(followCircleScale.value);
    for (let i = 0; i < this.slider.reverseTicks.length; i++) {
      const reverseTick = this.slider.reverseTicks[i];
      const opacity = reverseTick.drawable.opacity.value;
      const scale = reverseTick.drawable.scale.value;
      this.sliderReverses.children[i].alpha = opacity;
      this.sliderReverses.children[i].scale.set(scale);
    }
    for (let i = 0; i < this.slider.sliderTicks.length; i++) {
      const sliderTick = this.slider.sliderTicks[i];
      const opacity = sliderTick.drawable.opacity.value;
      const scale = sliderTick.drawable.scale.value;
      this.sliderTicks.children[i].alpha = opacity;
      this.sliderTicks.children[i].scale.set(scale);
    }
  }
}
const NODE_SCALE = 0.1;
const NODE_COUNT_AFTER = 0;
const NODE_COUNT_BEFORE = 0;
function createCursorNodes(size) {
  const nodeSprites = [];
  for (let i = 0; i < NODE_COUNT_BEFORE + NODE_COUNT_AFTER + 1; i++) {
    const texture = AssetsLoader.instance.getTexture("cursornode");
    const sprite = new Sprite(texture);
    sprite.anchor.set(0.5);
    sprite.scale.set(size);
    nodeSprites.push(sprite);
  }
  return nodeSprites;
}
class CursorNode extends Container {
  constructor(replay, fieldScale) {
    super();
    this.replay = replay;
    this.fieldScale = fieldScale;
    this.nodeSprites = createCursorNodes(fieldScale * NODE_SCALE);
    this.nodeLine = new Graphics();
    this.addChild(this.nodeLine);
    this.nodeSprites.forEach((nodeSprite) => this.addChild(nodeSprite));
    this.visible = true;
  }
  draw(timestamp) {
    const index2 = this.replay.replayData.getIndexNear(timestamp);
    const indexStart = Math.max(0, index2 - NODE_COUNT_BEFORE);
    const indexEnd = Math.min(this.replay.replayData.length - 1, index2 + NODE_COUNT_AFTER);
    const count = indexEnd - indexStart + 1;
    for (let i = indexStart; i <= indexEnd; i++) {
      const node = this.replay.replayData[i];
      const nodeSprite = this.nodeSprites[i - indexStart];
      let alpha = 1 - Math.abs(index2 - i) / count * 2;
      if (node.isPressing("K1") || node.isPressing("M1")) {
        nodeSprite.tint = 16776960;
      } else if (node.isPressing("K2") || node.isPressing("M2")) {
        nodeSprite.tint = 16711935;
      } else {
        nodeSprite.tint = 16777215;
        nodeSprite.scale.set(this.fieldScale * NODE_SCALE);
      }
      nodeSprite.alpha = alpha;
      nodeSprite.position.set(node.x * this.fieldScale, node.y * this.fieldScale);
    }
    const line = this.nodeLine;
    line.clear();
    line.lineStyle({ color: 16777215, width: 2 * this.fieldScale });
    for (let i = 0; i < count - 1; i++) {
      const curr = this.nodeSprites[i];
      const next = this.nodeSprites[i + 1];
      const startPos = [curr.x, curr.y];
      const endPos = [next.x, next.y];
      line.lineStyle({
        color: 16777215,
        width: 2 * this.fieldScale,
        alpha: 1 - Math.abs(i - count / 2) / count * 2
      });
      line.moveTo(startPos[0], startPos[1]).lineTo(endPos[0], endPos[1]);
    }
  }
}
const CURSOR_SCALE = 70;
function createMainCursor(size) {
  const texture = AssetsLoader.instance.getTexture("cursor");
  const mainCursor = new Sprite(texture);
  mainCursor.width = size;
  mainCursor.height = size;
  mainCursor.anchor.set(0.5);
  return mainCursor;
}
class MainCursor extends Container {
  constructor(replay, fieldScale) {
    super();
    this.replay = replay;
    this.fieldScale = fieldScale;
    const x = replay.replayData[0].x * fieldScale;
    const y = replay.replayData[0].y * fieldScale;
    this.mainCursor = createMainCursor(fieldScale * CURSOR_SCALE);
    this.addChild(this.mainCursor);
    this.alpha = 1;
    this.position.set(x, y);
  }
  draw(timestamp) {
    const [x, y] = this.replay.replayData.getPositionAt(timestamp, true);
    this.position.set(x * this.fieldScale, y * this.fieldScale);
  }
}
class Grid extends Graphics {
  constructor(width, height, gridSize, color, alpha) {
    super();
    let cellSize = 4;
    switch (gridSize) {
      case "PIXEL":
        cellSize = 1;
        break;
      case "TINY":
        cellSize = 4;
        break;
      case "SMALL":
        cellSize = 8;
        break;
      case "MEDIUM":
        cellSize = 16;
        break;
      case "LARGE":
        cellSize = 32;
        break;
    }
    const horizontalScale = width / 512;
    const verticalScale = height / 384;
    const scale = Math.min(horizontalScale, verticalScale);
    cellSize *= scale;
    const horizontalGridCount = Math.floor(width / cellSize);
    const verticalGridCount = Math.floor(height / cellSize);
    this.lineStyle(1, color, alpha);
    for (let i = 0; i <= horizontalGridCount; i++) {
      this.moveTo(i * cellSize, 0);
      this.lineTo(i * cellSize, height);
    }
    for (let i = 0; i <= verticalGridCount; i++) {
      this.moveTo(0, i * cellSize);
      this.lineTo(width, i * cellSize);
    }
    this.lineStyle(2, color, alpha);
    this.moveTo(width / 2, 0);
    this.lineTo(width / 2, height);
    this.moveTo(0, height / 2);
    this.lineTo(width, height / 2);
    this.endFill();
  }
}
const ADJUSTMENT_SCALE = 1 / 0.9;
function createSpinnerBackground(fieldScale) {
  const texture = AssetsLoader.instance.getTexture("spinner-background");
  const playfieldWidth = 512 * fieldScale;
  const playfieldHeight = 384 * fieldScale;
  const sprite = new Sprite(texture);
  sprite.scale.set(ADJUSTMENT_SCALE);
  sprite.position.set(playfieldWidth / 2, playfieldHeight / 2);
  sprite.anchor.set(0.5);
  sprite.blendMode = BLEND_MODES$3.MULTIPLY;
  return sprite;
}
function createSpinnerMeter(fieldScale) {
  const texture = AssetsLoader.instance.getTexture("spinner-metre");
  const playfieldWidth = 512 * fieldScale;
  const playfieldHeight = 384 * fieldScale;
  const sprite = new Sprite(texture);
  sprite.scale.set(ADJUSTMENT_SCALE);
  sprite.position.set(playfieldWidth / 2, (playfieldHeight - 7) / 2);
  sprite.anchor.set(0.5);
  return sprite;
}
function createSpinnerMeterMask(fieldScale) {
  const texture = AssetsLoader.instance.getTexture("spinner-metre");
  const playfieldWidth = 512 * fieldScale;
  const playfieldHeight = 384 * fieldScale;
  const mask = new Sprite(Texture.WHITE);
  mask.width = texture.width;
  mask.height = texture.height;
  mask.y = 0;
  mask.x = 0;
  mask.position.set(playfieldWidth / 2, playfieldHeight);
  mask.anchor.set(0.5, 1);
  return mask;
}
function createSpinnerCircle(fieldScale) {
  const texture = AssetsLoader.instance.getTexture("spinner-circle");
  const playfieldWidth = 512 * fieldScale;
  const playfieldHeight = 384 * fieldScale;
  const sprite = new Sprite(texture);
  sprite.scale.set(ADJUSTMENT_SCALE);
  sprite.position.set(playfieldWidth / 2, playfieldHeight / 2);
  sprite.anchor.set(0.5);
  return sprite;
}
function createSpinnerSpin(fieldScale) {
  const texture = AssetsLoader.instance.getTexture("spinner-spin");
  const playfieldWidth = 512 * fieldScale;
  const playfieldHeight = 384 * fieldScale;
  const sprite = new Sprite(texture);
  sprite.scale.set(ADJUSTMENT_SCALE);
  sprite.position.set(playfieldWidth / 2, playfieldHeight * 3 / 4);
  sprite.anchor.set(0.5, 0.25);
  return sprite;
}
class DrawableSpinner extends Container {
  constructor(spinner, fieldScale) {
    super();
    this.spinner = spinner;
    this.spinnerBackground = createSpinnerBackground(fieldScale);
    this.spinnerMeter = createSpinnerMeter(fieldScale);
    this.spinnerCircle = createSpinnerCircle(fieldScale);
    this.spinnerSpin = createSpinnerSpin(fieldScale);
    this.spinnerMeterMask = createSpinnerMeterMask(fieldScale);
    this.spinnerMeter.mask = this.spinnerMeterMask;
    this.addChild(this.spinnerMeterMask);
    this.addChild(this.spinnerBackground);
    this.addChild(this.spinnerSpin);
    this.addChild(this.spinnerCircle);
    this.addChild(this.spinnerMeter);
    this.visible = false;
  }
  draw(timestamp) {
    const visible = this.spinner.isVisibleAt(timestamp);
    this.visible = visible;
    if (!visible)
      return;
    const { opacity, fakeRotation, fakeMeter } = this.spinner.drawable;
    this.alpha = opacity.value;
    this.spinnerMeterMask.height = this.spinnerMeter.texture.baseTexture.realHeight * Math.min(Math.abs(fakeMeter.value), 1);
    this.spinnerCircle.rotation = fakeRotation.value;
  }
}
class DrawableGenerator {
  static CreateGrid(width, height, gridSize, color, alpha) {
    return new Grid(width, height, gridSize, color, alpha);
  }
  static CreateHitObject(hitObject, fieldScale) {
    if (hitObject.isHitCircle()) {
      return new DrawableHitCircle(hitObject, fieldScale);
    } else if (hitObject.isSlider()) {
      return new DrawableSlider(hitObject, fieldScale);
    } else {
      return new DrawableSpinner(hitObject, fieldScale);
    }
  }
}
class BeatmapField extends Container {
  constructor(application) {
    super();
    this.application = application;
    this.hitObjectDrawables = [];
    const canvasWidth = this.application.view.width;
    const canvasHeight = this.application.view.height;
    const playfieldScale = 4 / 5;
    if (canvasHeight > canvasWidth / 4 * 3) {
      this.playfieldResolution = [canvasWidth * playfieldScale, canvasWidth / 4 * 3 * playfieldScale];
    } else {
      this.playfieldResolution = [canvasHeight / 3 * 4 * playfieldScale, canvasHeight * playfieldScale];
    }
    const translateX = (canvasWidth - this.playfieldResolution[0]) / 2;
    const translateY = (canvasHeight - this.playfieldResolution[1]) / 2;
    const grid = DrawableGenerator.CreateGrid(this.playfieldResolution[0], this.playfieldResolution[1], "LARGE", 16777215, 0.25);
    this.addChild(grid);
    this.position.set(translateX, translateY);
  }
  loadBeatmap(beatmap) {
    this.hitObjectDrawables.forEach((obj) => obj.destroy({ texture: false, baseTexture: false, children: true }));
    this.hitObjectDrawables = [];
    this.beatmap = beatmap;
    const hitObjects = this.beatmap.hitObjects;
    const scale = getPlayfieldScale(this.playfieldResolution[0], this.playfieldResolution[1]);
    hitObjects.objects.forEach((hitObject) => {
      const drawable = DrawableGenerator.CreateHitObject(hitObject, scale);
      this.hitObjectDrawables.push(drawable);
    });
    const objectCount = this.hitObjectDrawables.length;
    for (let i = objectCount - 1; i >= 0; i--) {
      this.addChild(this.hitObjectDrawables[i]);
    }
  }
  draw(timestamp) {
    for (let i = 0; i < this.hitObjectDrawables.length; i++) {
      this.hitObjectDrawables[i].draw(timestamp);
    }
  }
}
class ReplayField extends Container {
  constructor(application) {
    super();
    this.application = application;
    const canvasWidth = this.application.view.width;
    const canvasHeight = this.application.view.height;
    const playfieldScale = 4 / 5;
    if (canvasHeight > canvasWidth / 4 * 3) {
      this.playfieldResolution = [canvasWidth * playfieldScale, canvasWidth / 4 * 3 * playfieldScale];
    } else {
      this.playfieldResolution = [canvasHeight / 3 * 4 * playfieldScale, canvasHeight * playfieldScale];
    }
    const translateX = (canvasWidth - this.playfieldResolution[0]) / 2;
    const translateY = (canvasHeight - this.playfieldResolution[1]) / 2;
    this.position.set(translateX, translateY);
  }
  loadReplay(replay) {
    var _a2, _b2;
    const scale = getPlayfieldScale(this.playfieldResolution[0], this.playfieldResolution[1]);
    (_a2 = this.mainCursor) == null ? void 0 : _a2.destroy();
    (_b2 = this.cursorNode) == null ? void 0 : _b2.destroy();
    this.mainCursor = new MainCursor(replay, scale);
    this.cursorNode = new CursorNode(replay, scale);
    this.addChild(this.cursorNode);
    this.addChild(this.mainCursor);
  }
  draw(timestamp) {
    var _a2, _b2;
    (_a2 = this.mainCursor) == null ? void 0 : _a2.draw(timestamp);
    (_b2 = this.cursorNode) == null ? void 0 : _b2.draw(timestamp);
  }
}
class Renderer {
  constructor(querySelector) {
    this._timestamp = 0;
    this.pixi = new Application({
      powerPreference: "high-performance",
      antialias: true,
      width: Settings.get("AppWidth"),
      height: Settings.get("AppHeight"),
      backgroundColor: 16777215
    });
    this.ticker = Ticker.shared;
    this.ticker.autoStart = false;
    this.ticker.stop();
    SliderTextureGenerator.setRenderer(this.pixi.renderer);
    this.background = new Background(this.pixi, { brightness: 0.25, fit: "horizontal" });
    this.background.interactiveChildren = false;
    this.pixi.stage.addChild(this.background);
    this.beatmapField = new BeatmapField(this.pixi);
    this.beatmapField.interactiveChildren = false;
    this.pixi.stage.addChild(this.beatmapField);
    this.replayField = new ReplayField(this.pixi);
    this.replayField.interactiveChildren = false;
    this.pixi.stage.addChild(this.replayField);
    const view = document.querySelector(querySelector);
    view && view.appendChild(this.pixi.view);
  }
  get timestamp() {
    return this._timestamp;
  }
  set timestamp(time) {
    this._timestamp = time;
    this.ticker.update(time);
    this.background.draw(time);
    this.beatmapField.draw(time);
    this.replayField.draw(time);
  }
  loadBeatmap(beatmap) {
    this.beatmapField.loadBeatmap(beatmap);
    this.background.loadBeatmap(beatmap);
  }
  loadReplay(replay) {
    this.replayField.loadReplay(replay);
  }
}
var howler = {};
/*!
 *  howler.js v2.2.3
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */
(function(exports) {
  (function() {
    var HowlerGlobal2 = function() {
      this.init();
    };
    HowlerGlobal2.prototype = {
      init: function() {
        var self2 = this || Howler2;
        self2._counter = 1e3;
        self2._html5AudioPool = [];
        self2.html5PoolSize = 10;
        self2._codecs = {};
        self2._howls = [];
        self2._muted = false;
        self2._volume = 1;
        self2._canPlayEvent = "canplaythrough";
        self2._navigator = typeof window !== "undefined" && window.navigator ? window.navigator : null;
        self2.masterGain = null;
        self2.noAudio = false;
        self2.usingWebAudio = true;
        self2.autoSuspend = true;
        self2.ctx = null;
        self2.autoUnlock = true;
        self2._setup();
        return self2;
      },
      volume: function(vol) {
        var self2 = this || Howler2;
        vol = parseFloat(vol);
        if (!self2.ctx) {
          setupAudioContext();
        }
        if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
          self2._volume = vol;
          if (self2._muted) {
            return self2;
          }
          if (self2.usingWebAudio) {
            self2.masterGain.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
          }
          for (var i = 0; i < self2._howls.length; i++) {
            if (!self2._howls[i]._webAudio) {
              var ids = self2._howls[i]._getSoundIds();
              for (var j = 0; j < ids.length; j++) {
                var sound = self2._howls[i]._soundById(ids[j]);
                if (sound && sound._node) {
                  sound._node.volume = sound._volume * vol;
                }
              }
            }
          }
          return self2;
        }
        return self2._volume;
      },
      mute: function(muted) {
        var self2 = this || Howler2;
        if (!self2.ctx) {
          setupAudioContext();
        }
        self2._muted = muted;
        if (self2.usingWebAudio) {
          self2.masterGain.gain.setValueAtTime(muted ? 0 : self2._volume, Howler2.ctx.currentTime);
        }
        for (var i = 0; i < self2._howls.length; i++) {
          if (!self2._howls[i]._webAudio) {
            var ids = self2._howls[i]._getSoundIds();
            for (var j = 0; j < ids.length; j++) {
              var sound = self2._howls[i]._soundById(ids[j]);
              if (sound && sound._node) {
                sound._node.muted = muted ? true : sound._muted;
              }
            }
          }
        }
        return self2;
      },
      stop: function() {
        var self2 = this || Howler2;
        for (var i = 0; i < self2._howls.length; i++) {
          self2._howls[i].stop();
        }
        return self2;
      },
      unload: function() {
        var self2 = this || Howler2;
        for (var i = self2._howls.length - 1; i >= 0; i--) {
          self2._howls[i].unload();
        }
        if (self2.usingWebAudio && self2.ctx && typeof self2.ctx.close !== "undefined") {
          self2.ctx.close();
          self2.ctx = null;
          setupAudioContext();
        }
        return self2;
      },
      codecs: function(ext) {
        return (this || Howler2)._codecs[ext.replace(/^x-/, "")];
      },
      _setup: function() {
        var self2 = this || Howler2;
        self2.state = self2.ctx ? self2.ctx.state || "suspended" : "suspended";
        self2._autoSuspend();
        if (!self2.usingWebAudio) {
          if (typeof Audio !== "undefined") {
            try {
              var test = new Audio();
              if (typeof test.oncanplaythrough === "undefined") {
                self2._canPlayEvent = "canplay";
              }
            } catch (e2) {
              self2.noAudio = true;
            }
          } else {
            self2.noAudio = true;
          }
        }
        try {
          var test = new Audio();
          if (test.muted) {
            self2.noAudio = true;
          }
        } catch (e2) {
        }
        if (!self2.noAudio) {
          self2._setupCodecs();
        }
        return self2;
      },
      _setupCodecs: function() {
        var self2 = this || Howler2;
        var audioTest = null;
        try {
          audioTest = typeof Audio !== "undefined" ? new Audio() : null;
        } catch (err) {
          return self2;
        }
        if (!audioTest || typeof audioTest.canPlayType !== "function") {
          return self2;
        }
        var mpegTest = audioTest.canPlayType("audio/mpeg;").replace(/^no$/, "");
        var ua = self2._navigator ? self2._navigator.userAgent : "";
        var checkOpera = ua.match(/OPR\/([0-6].)/g);
        var isOldOpera = checkOpera && parseInt(checkOpera[0].split("/")[1], 10) < 33;
        var checkSafari = ua.indexOf("Safari") !== -1 && ua.indexOf("Chrome") === -1;
        var safariVersion = ua.match(/Version\/(.*?) /);
        var isOldSafari = checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15;
        self2._codecs = {
          mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType("audio/mp3;").replace(/^no$/, ""))),
          mpeg: !!mpegTest,
          opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
          ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
          oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
          wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType("audio/wav")).replace(/^no$/, ""),
          aac: !!audioTest.canPlayType("audio/aac;").replace(/^no$/, ""),
          caf: !!audioTest.canPlayType("audio/x-caf;").replace(/^no$/, ""),
          m4a: !!(audioTest.canPlayType("audio/x-m4a;") || audioTest.canPlayType("audio/m4a;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
          m4b: !!(audioTest.canPlayType("audio/x-m4b;") || audioTest.canPlayType("audio/m4b;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
          mp4: !!(audioTest.canPlayType("audio/x-mp4;") || audioTest.canPlayType("audio/mp4;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
          weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
          webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
          dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
          flac: !!(audioTest.canPlayType("audio/x-flac;") || audioTest.canPlayType("audio/flac;")).replace(/^no$/, "")
        };
        return self2;
      },
      _unlockAudio: function() {
        var self2 = this || Howler2;
        if (self2._audioUnlocked || !self2.ctx) {
          return;
        }
        self2._audioUnlocked = false;
        self2.autoUnlock = false;
        if (!self2._mobileUnloaded && self2.ctx.sampleRate !== 44100) {
          self2._mobileUnloaded = true;
          self2.unload();
        }
        self2._scratchBuffer = self2.ctx.createBuffer(1, 1, 22050);
        var unlock = function(e2) {
          while (self2._html5AudioPool.length < self2.html5PoolSize) {
            try {
              var audioNode = new Audio();
              audioNode._unlocked = true;
              self2._releaseHtml5Audio(audioNode);
            } catch (e3) {
              self2.noAudio = true;
              break;
            }
          }
          for (var i = 0; i < self2._howls.length; i++) {
            if (!self2._howls[i]._webAudio) {
              var ids = self2._howls[i]._getSoundIds();
              for (var j = 0; j < ids.length; j++) {
                var sound = self2._howls[i]._soundById(ids[j]);
                if (sound && sound._node && !sound._node._unlocked) {
                  sound._node._unlocked = true;
                  sound._node.load();
                }
              }
            }
          }
          self2._autoResume();
          var source = self2.ctx.createBufferSource();
          source.buffer = self2._scratchBuffer;
          source.connect(self2.ctx.destination);
          if (typeof source.start === "undefined") {
            source.noteOn(0);
          } else {
            source.start(0);
          }
          if (typeof self2.ctx.resume === "function") {
            self2.ctx.resume();
          }
          source.onended = function() {
            source.disconnect(0);
            self2._audioUnlocked = true;
            document.removeEventListener("touchstart", unlock, true);
            document.removeEventListener("touchend", unlock, true);
            document.removeEventListener("click", unlock, true);
            document.removeEventListener("keydown", unlock, true);
            for (var i2 = 0; i2 < self2._howls.length; i2++) {
              self2._howls[i2]._emit("unlock");
            }
          };
        };
        document.addEventListener("touchstart", unlock, true);
        document.addEventListener("touchend", unlock, true);
        document.addEventListener("click", unlock, true);
        document.addEventListener("keydown", unlock, true);
        return self2;
      },
      _obtainHtml5Audio: function() {
        var self2 = this || Howler2;
        if (self2._html5AudioPool.length) {
          return self2._html5AudioPool.pop();
        }
        var testPlay = new Audio().play();
        if (testPlay && typeof Promise !== "undefined" && (testPlay instanceof Promise || typeof testPlay.then === "function")) {
          testPlay.catch(function() {
            console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
          });
        }
        return new Audio();
      },
      _releaseHtml5Audio: function(audio2) {
        var self2 = this || Howler2;
        if (audio2._unlocked) {
          self2._html5AudioPool.push(audio2);
        }
        return self2;
      },
      _autoSuspend: function() {
        var self2 = this;
        if (!self2.autoSuspend || !self2.ctx || typeof self2.ctx.suspend === "undefined" || !Howler2.usingWebAudio) {
          return;
        }
        for (var i = 0; i < self2._howls.length; i++) {
          if (self2._howls[i]._webAudio) {
            for (var j = 0; j < self2._howls[i]._sounds.length; j++) {
              if (!self2._howls[i]._sounds[j]._paused) {
                return self2;
              }
            }
          }
        }
        if (self2._suspendTimer) {
          clearTimeout(self2._suspendTimer);
        }
        self2._suspendTimer = setTimeout(function() {
          if (!self2.autoSuspend) {
            return;
          }
          self2._suspendTimer = null;
          self2.state = "suspending";
          var handleSuspension = function() {
            self2.state = "suspended";
            if (self2._resumeAfterSuspend) {
              delete self2._resumeAfterSuspend;
              self2._autoResume();
            }
          };
          self2.ctx.suspend().then(handleSuspension, handleSuspension);
        }, 3e4);
        return self2;
      },
      _autoResume: function() {
        var self2 = this;
        if (!self2.ctx || typeof self2.ctx.resume === "undefined" || !Howler2.usingWebAudio) {
          return;
        }
        if (self2.state === "running" && self2.ctx.state !== "interrupted" && self2._suspendTimer) {
          clearTimeout(self2._suspendTimer);
          self2._suspendTimer = null;
        } else if (self2.state === "suspended" || self2.state === "running" && self2.ctx.state === "interrupted") {
          self2.ctx.resume().then(function() {
            self2.state = "running";
            for (var i = 0; i < self2._howls.length; i++) {
              self2._howls[i]._emit("resume");
            }
          });
          if (self2._suspendTimer) {
            clearTimeout(self2._suspendTimer);
            self2._suspendTimer = null;
          }
        } else if (self2.state === "suspending") {
          self2._resumeAfterSuspend = true;
        }
        return self2;
      }
    };
    var Howler2 = new HowlerGlobal2();
    var Howl2 = function(o) {
      var self2 = this;
      if (!o.src || o.src.length === 0) {
        console.error("An array of source files must be passed with any new Howl.");
        return;
      }
      self2.init(o);
    };
    Howl2.prototype = {
      init: function(o) {
        var self2 = this;
        if (!Howler2.ctx) {
          setupAudioContext();
        }
        self2._autoplay = o.autoplay || false;
        self2._format = typeof o.format !== "string" ? o.format : [o.format];
        self2._html5 = o.html5 || false;
        self2._muted = o.mute || false;
        self2._loop = o.loop || false;
        self2._pool = o.pool || 5;
        self2._preload = typeof o.preload === "boolean" || o.preload === "metadata" ? o.preload : true;
        self2._rate = o.rate || 1;
        self2._sprite = o.sprite || {};
        self2._src = typeof o.src !== "string" ? o.src : [o.src];
        self2._volume = o.volume !== void 0 ? o.volume : 1;
        self2._xhr = {
          method: o.xhr && o.xhr.method ? o.xhr.method : "GET",
          headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
          withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false
        };
        self2._duration = 0;
        self2._state = "unloaded";
        self2._sounds = [];
        self2._endTimers = {};
        self2._queue = [];
        self2._playLock = false;
        self2._onend = o.onend ? [{ fn: o.onend }] : [];
        self2._onfade = o.onfade ? [{ fn: o.onfade }] : [];
        self2._onload = o.onload ? [{ fn: o.onload }] : [];
        self2._onloaderror = o.onloaderror ? [{ fn: o.onloaderror }] : [];
        self2._onplayerror = o.onplayerror ? [{ fn: o.onplayerror }] : [];
        self2._onpause = o.onpause ? [{ fn: o.onpause }] : [];
        self2._onplay = o.onplay ? [{ fn: o.onplay }] : [];
        self2._onstop = o.onstop ? [{ fn: o.onstop }] : [];
        self2._onmute = o.onmute ? [{ fn: o.onmute }] : [];
        self2._onvolume = o.onvolume ? [{ fn: o.onvolume }] : [];
        self2._onrate = o.onrate ? [{ fn: o.onrate }] : [];
        self2._onseek = o.onseek ? [{ fn: o.onseek }] : [];
        self2._onunlock = o.onunlock ? [{ fn: o.onunlock }] : [];
        self2._onresume = [];
        self2._webAudio = Howler2.usingWebAudio && !self2._html5;
        if (typeof Howler2.ctx !== "undefined" && Howler2.ctx && Howler2.autoUnlock) {
          Howler2._unlockAudio();
        }
        Howler2._howls.push(self2);
        if (self2._autoplay) {
          self2._queue.push({
            event: "play",
            action: function() {
              self2.play();
            }
          });
        }
        if (self2._preload && self2._preload !== "none") {
          self2.load();
        }
        return self2;
      },
      load: function() {
        var self2 = this;
        var url2 = null;
        if (Howler2.noAudio) {
          self2._emit("loaderror", null, "No audio support.");
          return;
        }
        if (typeof self2._src === "string") {
          self2._src = [self2._src];
        }
        for (var i = 0; i < self2._src.length; i++) {
          var ext, str;
          if (self2._format && self2._format[i]) {
            ext = self2._format[i];
          } else {
            str = self2._src[i];
            if (typeof str !== "string") {
              self2._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
              continue;
            }
            ext = /^data:audio\/([^;,]+);/i.exec(str);
            if (!ext) {
              ext = /\.([^.]+)$/.exec(str.split("?", 1)[0]);
            }
            if (ext) {
              ext = ext[1].toLowerCase();
            }
          }
          if (!ext) {
            console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
          }
          if (ext && Howler2.codecs(ext)) {
            url2 = self2._src[i];
            break;
          }
        }
        if (!url2) {
          self2._emit("loaderror", null, "No codec support for selected audio sources.");
          return;
        }
        self2._src = url2;
        self2._state = "loading";
        if (window.location.protocol === "https:" && url2.slice(0, 5) === "http:") {
          self2._html5 = true;
          self2._webAudio = false;
        }
        new Sound2(self2);
        if (self2._webAudio) {
          loadBuffer(self2);
        }
        return self2;
      },
      play: function(sprite, internal) {
        var self2 = this;
        var id = null;
        if (typeof sprite === "number") {
          id = sprite;
          sprite = null;
        } else if (typeof sprite === "string" && self2._state === "loaded" && !self2._sprite[sprite]) {
          return null;
        } else if (typeof sprite === "undefined") {
          sprite = "__default";
          if (!self2._playLock) {
            var num = 0;
            for (var i = 0; i < self2._sounds.length; i++) {
              if (self2._sounds[i]._paused && !self2._sounds[i]._ended) {
                num++;
                id = self2._sounds[i]._id;
              }
            }
            if (num === 1) {
              sprite = null;
            } else {
              id = null;
            }
          }
        }
        var sound = id ? self2._soundById(id) : self2._inactiveSound();
        if (!sound) {
          return null;
        }
        if (id && !sprite) {
          sprite = sound._sprite || "__default";
        }
        if (self2._state !== "loaded") {
          sound._sprite = sprite;
          sound._ended = false;
          var soundId = sound._id;
          self2._queue.push({
            event: "play",
            action: function() {
              self2.play(soundId);
            }
          });
          return soundId;
        }
        if (id && !sound._paused) {
          if (!internal) {
            self2._loadQueue("play");
          }
          return sound._id;
        }
        if (self2._webAudio) {
          Howler2._autoResume();
        }
        var seek = Math.max(0, sound._seek > 0 ? sound._seek : self2._sprite[sprite][0] / 1e3);
        var duration = Math.max(0, (self2._sprite[sprite][0] + self2._sprite[sprite][1]) / 1e3 - seek);
        var timeout = duration * 1e3 / Math.abs(sound._rate);
        var start = self2._sprite[sprite][0] / 1e3;
        var stop = (self2._sprite[sprite][0] + self2._sprite[sprite][1]) / 1e3;
        sound._sprite = sprite;
        sound._ended = false;
        var setParams = function() {
          sound._paused = false;
          sound._seek = seek;
          sound._start = start;
          sound._stop = stop;
          sound._loop = !!(sound._loop || self2._sprite[sprite][2]);
        };
        if (seek >= stop) {
          self2._ended(sound);
          return;
        }
        var node = sound._node;
        if (self2._webAudio) {
          var playWebAudio = function() {
            self2._playLock = false;
            setParams();
            self2._refreshBuffer(sound);
            var vol = sound._muted || self2._muted ? 0 : sound._volume;
            node.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
            sound._playStart = Howler2.ctx.currentTime;
            if (typeof node.bufferSource.start === "undefined") {
              sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
            } else {
              sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
            }
            if (timeout !== Infinity) {
              self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
            }
            if (!internal) {
              setTimeout(function() {
                self2._emit("play", sound._id);
                self2._loadQueue();
              }, 0);
            }
          };
          if (Howler2.state === "running" && Howler2.ctx.state !== "interrupted") {
            playWebAudio();
          } else {
            self2._playLock = true;
            self2.once("resume", playWebAudio);
            self2._clearTimer(sound._id);
          }
        } else {
          var playHtml5 = function() {
            node.currentTime = seek;
            node.muted = sound._muted || self2._muted || Howler2._muted || node.muted;
            node.volume = sound._volume * Howler2.volume();
            node.playbackRate = sound._rate;
            try {
              var play = node.play();
              if (play && typeof Promise !== "undefined" && (play instanceof Promise || typeof play.then === "function")) {
                self2._playLock = true;
                setParams();
                play.then(function() {
                  self2._playLock = false;
                  node._unlocked = true;
                  if (!internal) {
                    self2._emit("play", sound._id);
                  } else {
                    self2._loadQueue();
                  }
                }).catch(function() {
                  self2._playLock = false;
                  self2._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                  sound._ended = true;
                  sound._paused = true;
                });
              } else if (!internal) {
                self2._playLock = false;
                setParams();
                self2._emit("play", sound._id);
              }
              node.playbackRate = sound._rate;
              if (node.paused) {
                self2._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                return;
              }
              if (sprite !== "__default" || sound._loop) {
                self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
              } else {
                self2._endTimers[sound._id] = function() {
                  self2._ended(sound);
                  node.removeEventListener("ended", self2._endTimers[sound._id], false);
                };
                node.addEventListener("ended", self2._endTimers[sound._id], false);
              }
            } catch (err) {
              self2._emit("playerror", sound._id, err);
            }
          };
          if (node.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA") {
            node.src = self2._src;
            node.load();
          }
          var loadedNoReadyState = window && window.ejecta || !node.readyState && Howler2._navigator.isCocoonJS;
          if (node.readyState >= 3 || loadedNoReadyState) {
            playHtml5();
          } else {
            self2._playLock = true;
            self2._state = "loading";
            var listener = function() {
              self2._state = "loaded";
              playHtml5();
              node.removeEventListener(Howler2._canPlayEvent, listener, false);
            };
            node.addEventListener(Howler2._canPlayEvent, listener, false);
            self2._clearTimer(sound._id);
          }
        }
        return sound._id;
      },
      pause: function(id) {
        var self2 = this;
        if (self2._state !== "loaded" || self2._playLock) {
          self2._queue.push({
            event: "pause",
            action: function() {
              self2.pause(id);
            }
          });
          return self2;
        }
        var ids = self2._getSoundIds(id);
        for (var i = 0; i < ids.length; i++) {
          self2._clearTimer(ids[i]);
          var sound = self2._soundById(ids[i]);
          if (sound && !sound._paused) {
            sound._seek = self2.seek(ids[i]);
            sound._rateSeek = 0;
            sound._paused = true;
            self2._stopFade(ids[i]);
            if (sound._node) {
              if (self2._webAudio) {
                if (!sound._node.bufferSource) {
                  continue;
                }
                if (typeof sound._node.bufferSource.stop === "undefined") {
                  sound._node.bufferSource.noteOff(0);
                } else {
                  sound._node.bufferSource.stop(0);
                }
                self2._cleanBuffer(sound._node);
              } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                sound._node.pause();
              }
            }
          }
          if (!arguments[1]) {
            self2._emit("pause", sound ? sound._id : null);
          }
        }
        return self2;
      },
      stop: function(id, internal) {
        var self2 = this;
        if (self2._state !== "loaded" || self2._playLock) {
          self2._queue.push({
            event: "stop",
            action: function() {
              self2.stop(id);
            }
          });
          return self2;
        }
        var ids = self2._getSoundIds(id);
        for (var i = 0; i < ids.length; i++) {
          self2._clearTimer(ids[i]);
          var sound = self2._soundById(ids[i]);
          if (sound) {
            sound._seek = sound._start || 0;
            sound._rateSeek = 0;
            sound._paused = true;
            sound._ended = true;
            self2._stopFade(ids[i]);
            if (sound._node) {
              if (self2._webAudio) {
                if (sound._node.bufferSource) {
                  if (typeof sound._node.bufferSource.stop === "undefined") {
                    sound._node.bufferSource.noteOff(0);
                  } else {
                    sound._node.bufferSource.stop(0);
                  }
                  self2._cleanBuffer(sound._node);
                }
              } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                sound._node.currentTime = sound._start || 0;
                sound._node.pause();
                if (sound._node.duration === Infinity) {
                  self2._clearSound(sound._node);
                }
              }
            }
            if (!internal) {
              self2._emit("stop", sound._id);
            }
          }
        }
        return self2;
      },
      mute: function(muted, id) {
        var self2 = this;
        if (self2._state !== "loaded" || self2._playLock) {
          self2._queue.push({
            event: "mute",
            action: function() {
              self2.mute(muted, id);
            }
          });
          return self2;
        }
        if (typeof id === "undefined") {
          if (typeof muted === "boolean") {
            self2._muted = muted;
          } else {
            return self2._muted;
          }
        }
        var ids = self2._getSoundIds(id);
        for (var i = 0; i < ids.length; i++) {
          var sound = self2._soundById(ids[i]);
          if (sound) {
            sound._muted = muted;
            if (sound._interval) {
              self2._stopFade(sound._id);
            }
            if (self2._webAudio && sound._node) {
              sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler2.ctx.currentTime);
            } else if (sound._node) {
              sound._node.muted = Howler2._muted ? true : muted;
            }
            self2._emit("mute", sound._id);
          }
        }
        return self2;
      },
      volume: function() {
        var self2 = this;
        var args = arguments;
        var vol, id;
        if (args.length === 0) {
          return self2._volume;
        } else if (args.length === 1 || args.length === 2 && typeof args[1] === "undefined") {
          var ids = self2._getSoundIds();
          var index2 = ids.indexOf(args[0]);
          if (index2 >= 0) {
            id = parseInt(args[0], 10);
          } else {
            vol = parseFloat(args[0]);
          }
        } else if (args.length >= 2) {
          vol = parseFloat(args[0]);
          id = parseInt(args[1], 10);
        }
        var sound;
        if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "volume",
              action: function() {
                self2.volume.apply(self2, args);
              }
            });
            return self2;
          }
          if (typeof id === "undefined") {
            self2._volume = vol;
          }
          id = self2._getSoundIds(id);
          for (var i = 0; i < id.length; i++) {
            sound = self2._soundById(id[i]);
            if (sound) {
              sound._volume = vol;
              if (!args[2]) {
                self2._stopFade(id[i]);
              }
              if (self2._webAudio && sound._node && !sound._muted) {
                sound._node.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
              } else if (sound._node && !sound._muted) {
                sound._node.volume = vol * Howler2.volume();
              }
              self2._emit("volume", sound._id);
            }
          }
        } else {
          sound = id ? self2._soundById(id) : self2._sounds[0];
          return sound ? sound._volume : 0;
        }
        return self2;
      },
      fade: function(from, to, len, id) {
        var self2 = this;
        if (self2._state !== "loaded" || self2._playLock) {
          self2._queue.push({
            event: "fade",
            action: function() {
              self2.fade(from, to, len, id);
            }
          });
          return self2;
        }
        from = Math.min(Math.max(0, parseFloat(from)), 1);
        to = Math.min(Math.max(0, parseFloat(to)), 1);
        len = parseFloat(len);
        self2.volume(from, id);
        var ids = self2._getSoundIds(id);
        for (var i = 0; i < ids.length; i++) {
          var sound = self2._soundById(ids[i]);
          if (sound) {
            if (!id) {
              self2._stopFade(ids[i]);
            }
            if (self2._webAudio && !sound._muted) {
              var currentTime = Howler2.ctx.currentTime;
              var end = currentTime + len / 1e3;
              sound._volume = from;
              sound._node.gain.setValueAtTime(from, currentTime);
              sound._node.gain.linearRampToValueAtTime(to, end);
            }
            self2._startFadeInterval(sound, from, to, len, ids[i], typeof id === "undefined");
          }
        }
        return self2;
      },
      _startFadeInterval: function(sound, from, to, len, id, isGroup) {
        var self2 = this;
        var vol = from;
        var diff = to - from;
        var steps = Math.abs(diff / 0.01);
        var stepLen = Math.max(4, steps > 0 ? len / steps : len);
        var lastTick = Date.now();
        sound._fadeTo = to;
        sound._interval = setInterval(function() {
          var tick = (Date.now() - lastTick) / len;
          lastTick = Date.now();
          vol += diff * tick;
          vol = Math.round(vol * 100) / 100;
          if (diff < 0) {
            vol = Math.max(to, vol);
          } else {
            vol = Math.min(to, vol);
          }
          if (self2._webAudio) {
            sound._volume = vol;
          } else {
            self2.volume(vol, sound._id, true);
          }
          if (isGroup) {
            self2._volume = vol;
          }
          if (to < from && vol <= to || to > from && vol >= to) {
            clearInterval(sound._interval);
            sound._interval = null;
            sound._fadeTo = null;
            self2.volume(to, sound._id);
            self2._emit("fade", sound._id);
          }
        }, stepLen);
      },
      _stopFade: function(id) {
        var self2 = this;
        var sound = self2._soundById(id);
        if (sound && sound._interval) {
          if (self2._webAudio) {
            sound._node.gain.cancelScheduledValues(Howler2.ctx.currentTime);
          }
          clearInterval(sound._interval);
          sound._interval = null;
          self2.volume(sound._fadeTo, id);
          sound._fadeTo = null;
          self2._emit("fade", id);
        }
        return self2;
      },
      loop: function() {
        var self2 = this;
        var args = arguments;
        var loop, id, sound;
        if (args.length === 0) {
          return self2._loop;
        } else if (args.length === 1) {
          if (typeof args[0] === "boolean") {
            loop = args[0];
            self2._loop = loop;
          } else {
            sound = self2._soundById(parseInt(args[0], 10));
            return sound ? sound._loop : false;
          }
        } else if (args.length === 2) {
          loop = args[0];
          id = parseInt(args[1], 10);
        }
        var ids = self2._getSoundIds(id);
        for (var i = 0; i < ids.length; i++) {
          sound = self2._soundById(ids[i]);
          if (sound) {
            sound._loop = loop;
            if (self2._webAudio && sound._node && sound._node.bufferSource) {
              sound._node.bufferSource.loop = loop;
              if (loop) {
                sound._node.bufferSource.loopStart = sound._start || 0;
                sound._node.bufferSource.loopEnd = sound._stop;
                if (self2.playing(ids[i])) {
                  self2.pause(ids[i], true);
                  self2.play(ids[i], true);
                }
              }
            }
          }
        }
        return self2;
      },
      rate: function() {
        var self2 = this;
        var args = arguments;
        var rate, id;
        if (args.length === 0) {
          id = self2._sounds[0]._id;
        } else if (args.length === 1) {
          var ids = self2._getSoundIds();
          var index2 = ids.indexOf(args[0]);
          if (index2 >= 0) {
            id = parseInt(args[0], 10);
          } else {
            rate = parseFloat(args[0]);
          }
        } else if (args.length === 2) {
          rate = parseFloat(args[0]);
          id = parseInt(args[1], 10);
        }
        var sound;
        if (typeof rate === "number") {
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "rate",
              action: function() {
                self2.rate.apply(self2, args);
              }
            });
            return self2;
          }
          if (typeof id === "undefined") {
            self2._rate = rate;
          }
          id = self2._getSoundIds(id);
          for (var i = 0; i < id.length; i++) {
            sound = self2._soundById(id[i]);
            if (sound) {
              if (self2.playing(id[i])) {
                sound._rateSeek = self2.seek(id[i]);
                sound._playStart = self2._webAudio ? Howler2.ctx.currentTime : sound._playStart;
              }
              sound._rate = rate;
              if (self2._webAudio && sound._node && sound._node.bufferSource) {
                sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler2.ctx.currentTime);
              } else if (sound._node) {
                sound._node.playbackRate = rate;
              }
              var seek = self2.seek(id[i]);
              var duration = (self2._sprite[sound._sprite][0] + self2._sprite[sound._sprite][1]) / 1e3 - seek;
              var timeout = duration * 1e3 / Math.abs(sound._rate);
              if (self2._endTimers[id[i]] || !sound._paused) {
                self2._clearTimer(id[i]);
                self2._endTimers[id[i]] = setTimeout(self2._ended.bind(self2, sound), timeout);
              }
              self2._emit("rate", sound._id);
            }
          }
        } else {
          sound = self2._soundById(id);
          return sound ? sound._rate : self2._rate;
        }
        return self2;
      },
      seek: function() {
        var self2 = this;
        var args = arguments;
        var seek, id;
        if (args.length === 0) {
          if (self2._sounds.length) {
            id = self2._sounds[0]._id;
          }
        } else if (args.length === 1) {
          var ids = self2._getSoundIds();
          var index2 = ids.indexOf(args[0]);
          if (index2 >= 0) {
            id = parseInt(args[0], 10);
          } else if (self2._sounds.length) {
            id = self2._sounds[0]._id;
            seek = parseFloat(args[0]);
          }
        } else if (args.length === 2) {
          seek = parseFloat(args[0]);
          id = parseInt(args[1], 10);
        }
        if (typeof id === "undefined") {
          return 0;
        }
        if (typeof seek === "number" && (self2._state !== "loaded" || self2._playLock)) {
          self2._queue.push({
            event: "seek",
            action: function() {
              self2.seek.apply(self2, args);
            }
          });
          return self2;
        }
        var sound = self2._soundById(id);
        if (sound) {
          if (typeof seek === "number" && seek >= 0) {
            var playing = self2.playing(id);
            if (playing) {
              self2.pause(id, true);
            }
            sound._seek = seek;
            sound._ended = false;
            self2._clearTimer(id);
            if (!self2._webAudio && sound._node && !isNaN(sound._node.duration)) {
              sound._node.currentTime = seek;
            }
            var seekAndEmit = function() {
              if (playing) {
                self2.play(id, true);
              }
              self2._emit("seek", id);
            };
            if (playing && !self2._webAudio) {
              var emitSeek = function() {
                if (!self2._playLock) {
                  seekAndEmit();
                } else {
                  setTimeout(emitSeek, 0);
                }
              };
              setTimeout(emitSeek, 0);
            } else {
              seekAndEmit();
            }
          } else {
            if (self2._webAudio) {
              var realTime = self2.playing(id) ? Howler2.ctx.currentTime - sound._playStart : 0;
              var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
              return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
            } else {
              return sound._node.currentTime;
            }
          }
        }
        return self2;
      },
      playing: function(id) {
        var self2 = this;
        if (typeof id === "number") {
          var sound = self2._soundById(id);
          return sound ? !sound._paused : false;
        }
        for (var i = 0; i < self2._sounds.length; i++) {
          if (!self2._sounds[i]._paused) {
            return true;
          }
        }
        return false;
      },
      duration: function(id) {
        var self2 = this;
        var duration = self2._duration;
        var sound = self2._soundById(id);
        if (sound) {
          duration = self2._sprite[sound._sprite][1] / 1e3;
        }
        return duration;
      },
      state: function() {
        return this._state;
      },
      unload: function() {
        var self2 = this;
        var sounds = self2._sounds;
        for (var i = 0; i < sounds.length; i++) {
          if (!sounds[i]._paused) {
            self2.stop(sounds[i]._id);
          }
          if (!self2._webAudio) {
            self2._clearSound(sounds[i]._node);
            sounds[i]._node.removeEventListener("error", sounds[i]._errorFn, false);
            sounds[i]._node.removeEventListener(Howler2._canPlayEvent, sounds[i]._loadFn, false);
            sounds[i]._node.removeEventListener("ended", sounds[i]._endFn, false);
            Howler2._releaseHtml5Audio(sounds[i]._node);
          }
          delete sounds[i]._node;
          self2._clearTimer(sounds[i]._id);
        }
        var index2 = Howler2._howls.indexOf(self2);
        if (index2 >= 0) {
          Howler2._howls.splice(index2, 1);
        }
        var remCache = true;
        for (i = 0; i < Howler2._howls.length; i++) {
          if (Howler2._howls[i]._src === self2._src || self2._src.indexOf(Howler2._howls[i]._src) >= 0) {
            remCache = false;
            break;
          }
        }
        if (cache && remCache) {
          delete cache[self2._src];
        }
        Howler2.noAudio = false;
        self2._state = "unloaded";
        self2._sounds = [];
        self2 = null;
        return null;
      },
      on: function(event, fn, id, once) {
        var self2 = this;
        var events = self2["_on" + event];
        if (typeof fn === "function") {
          events.push(once ? { id, fn, once } : { id, fn });
        }
        return self2;
      },
      off: function(event, fn, id) {
        var self2 = this;
        var events = self2["_on" + event];
        var i = 0;
        if (typeof fn === "number") {
          id = fn;
          fn = null;
        }
        if (fn || id) {
          for (i = 0; i < events.length; i++) {
            var isId = id === events[i].id;
            if (fn === events[i].fn && isId || !fn && isId) {
              events.splice(i, 1);
              break;
            }
          }
        } else if (event) {
          self2["_on" + event] = [];
        } else {
          var keys = Object.keys(self2);
          for (i = 0; i < keys.length; i++) {
            if (keys[i].indexOf("_on") === 0 && Array.isArray(self2[keys[i]])) {
              self2[keys[i]] = [];
            }
          }
        }
        return self2;
      },
      once: function(event, fn, id) {
        var self2 = this;
        self2.on(event, fn, id, 1);
        return self2;
      },
      _emit: function(event, id, msg) {
        var self2 = this;
        var events = self2["_on" + event];
        for (var i = events.length - 1; i >= 0; i--) {
          if (!events[i].id || events[i].id === id || event === "load") {
            setTimeout(function(fn) {
              fn.call(this, id, msg);
            }.bind(self2, events[i].fn), 0);
            if (events[i].once) {
              self2.off(event, events[i].fn, events[i].id);
            }
          }
        }
        self2._loadQueue(event);
        return self2;
      },
      _loadQueue: function(event) {
        var self2 = this;
        if (self2._queue.length > 0) {
          var task = self2._queue[0];
          if (task.event === event) {
            self2._queue.shift();
            self2._loadQueue();
          }
          if (!event) {
            task.action();
          }
        }
        return self2;
      },
      _ended: function(sound) {
        var self2 = this;
        var sprite = sound._sprite;
        if (!self2._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
          setTimeout(self2._ended.bind(self2, sound), 100);
          return self2;
        }
        var loop = !!(sound._loop || self2._sprite[sprite][2]);
        self2._emit("end", sound._id);
        if (!self2._webAudio && loop) {
          self2.stop(sound._id, true).play(sound._id);
        }
        if (self2._webAudio && loop) {
          self2._emit("play", sound._id);
          sound._seek = sound._start || 0;
          sound._rateSeek = 0;
          sound._playStart = Howler2.ctx.currentTime;
          var timeout = (sound._stop - sound._start) * 1e3 / Math.abs(sound._rate);
          self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
        }
        if (self2._webAudio && !loop) {
          sound._paused = true;
          sound._ended = true;
          sound._seek = sound._start || 0;
          sound._rateSeek = 0;
          self2._clearTimer(sound._id);
          self2._cleanBuffer(sound._node);
          Howler2._autoSuspend();
        }
        if (!self2._webAudio && !loop) {
          self2.stop(sound._id, true);
        }
        return self2;
      },
      _clearTimer: function(id) {
        var self2 = this;
        if (self2._endTimers[id]) {
          if (typeof self2._endTimers[id] !== "function") {
            clearTimeout(self2._endTimers[id]);
          } else {
            var sound = self2._soundById(id);
            if (sound && sound._node) {
              sound._node.removeEventListener("ended", self2._endTimers[id], false);
            }
          }
          delete self2._endTimers[id];
        }
        return self2;
      },
      _soundById: function(id) {
        var self2 = this;
        for (var i = 0; i < self2._sounds.length; i++) {
          if (id === self2._sounds[i]._id) {
            return self2._sounds[i];
          }
        }
        return null;
      },
      _inactiveSound: function() {
        var self2 = this;
        self2._drain();
        for (var i = 0; i < self2._sounds.length; i++) {
          if (self2._sounds[i]._ended) {
            return self2._sounds[i].reset();
          }
        }
        return new Sound2(self2);
      },
      _drain: function() {
        var self2 = this;
        var limit = self2._pool;
        var cnt = 0;
        var i = 0;
        if (self2._sounds.length < limit) {
          return;
        }
        for (i = 0; i < self2._sounds.length; i++) {
          if (self2._sounds[i]._ended) {
            cnt++;
          }
        }
        for (i = self2._sounds.length - 1; i >= 0; i--) {
          if (cnt <= limit) {
            return;
          }
          if (self2._sounds[i]._ended) {
            if (self2._webAudio && self2._sounds[i]._node) {
              self2._sounds[i]._node.disconnect(0);
            }
            self2._sounds.splice(i, 1);
            cnt--;
          }
        }
      },
      _getSoundIds: function(id) {
        var self2 = this;
        if (typeof id === "undefined") {
          var ids = [];
          for (var i = 0; i < self2._sounds.length; i++) {
            ids.push(self2._sounds[i]._id);
          }
          return ids;
        } else {
          return [id];
        }
      },
      _refreshBuffer: function(sound) {
        var self2 = this;
        sound._node.bufferSource = Howler2.ctx.createBufferSource();
        sound._node.bufferSource.buffer = cache[self2._src];
        if (sound._panner) {
          sound._node.bufferSource.connect(sound._panner);
        } else {
          sound._node.bufferSource.connect(sound._node);
        }
        sound._node.bufferSource.loop = sound._loop;
        if (sound._loop) {
          sound._node.bufferSource.loopStart = sound._start || 0;
          sound._node.bufferSource.loopEnd = sound._stop || 0;
        }
        sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler2.ctx.currentTime);
        return self2;
      },
      _cleanBuffer: function(node) {
        var self2 = this;
        var isIOS = Howler2._navigator && Howler2._navigator.vendor.indexOf("Apple") >= 0;
        if (Howler2._scratchBuffer && node.bufferSource) {
          node.bufferSource.onended = null;
          node.bufferSource.disconnect(0);
          if (isIOS) {
            try {
              node.bufferSource.buffer = Howler2._scratchBuffer;
            } catch (e2) {
            }
          }
        }
        node.bufferSource = null;
        return self2;
      },
      _clearSound: function(node) {
        var checkIE = /MSIE |Trident\//.test(Howler2._navigator && Howler2._navigator.userAgent);
        if (!checkIE) {
          node.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA";
        }
      }
    };
    var Sound2 = function(howl) {
      this._parent = howl;
      this.init();
    };
    Sound2.prototype = {
      init: function() {
        var self2 = this;
        var parent = self2._parent;
        self2._muted = parent._muted;
        self2._loop = parent._loop;
        self2._volume = parent._volume;
        self2._rate = parent._rate;
        self2._seek = 0;
        self2._paused = true;
        self2._ended = true;
        self2._sprite = "__default";
        self2._id = ++Howler2._counter;
        parent._sounds.push(self2);
        self2.create();
        return self2;
      },
      create: function() {
        var self2 = this;
        var parent = self2._parent;
        var volume = Howler2._muted || self2._muted || self2._parent._muted ? 0 : self2._volume;
        if (parent._webAudio) {
          self2._node = typeof Howler2.ctx.createGain === "undefined" ? Howler2.ctx.createGainNode() : Howler2.ctx.createGain();
          self2._node.gain.setValueAtTime(volume, Howler2.ctx.currentTime);
          self2._node.paused = true;
          self2._node.connect(Howler2.masterGain);
        } else if (!Howler2.noAudio) {
          self2._node = Howler2._obtainHtml5Audio();
          self2._errorFn = self2._errorListener.bind(self2);
          self2._node.addEventListener("error", self2._errorFn, false);
          self2._loadFn = self2._loadListener.bind(self2);
          self2._node.addEventListener(Howler2._canPlayEvent, self2._loadFn, false);
          self2._endFn = self2._endListener.bind(self2);
          self2._node.addEventListener("ended", self2._endFn, false);
          self2._node.src = parent._src;
          self2._node.preload = parent._preload === true ? "auto" : parent._preload;
          self2._node.volume = volume * Howler2.volume();
          self2._node.load();
        }
        return self2;
      },
      reset: function() {
        var self2 = this;
        var parent = self2._parent;
        self2._muted = parent._muted;
        self2._loop = parent._loop;
        self2._volume = parent._volume;
        self2._rate = parent._rate;
        self2._seek = 0;
        self2._rateSeek = 0;
        self2._paused = true;
        self2._ended = true;
        self2._sprite = "__default";
        self2._id = ++Howler2._counter;
        return self2;
      },
      _errorListener: function() {
        var self2 = this;
        self2._parent._emit("loaderror", self2._id, self2._node.error ? self2._node.error.code : 0);
        self2._node.removeEventListener("error", self2._errorFn, false);
      },
      _loadListener: function() {
        var self2 = this;
        var parent = self2._parent;
        parent._duration = Math.ceil(self2._node.duration * 10) / 10;
        if (Object.keys(parent._sprite).length === 0) {
          parent._sprite = { __default: [0, parent._duration * 1e3] };
        }
        if (parent._state !== "loaded") {
          parent._state = "loaded";
          parent._emit("load");
          parent._loadQueue();
        }
        self2._node.removeEventListener(Howler2._canPlayEvent, self2._loadFn, false);
      },
      _endListener: function() {
        var self2 = this;
        var parent = self2._parent;
        if (parent._duration === Infinity) {
          parent._duration = Math.ceil(self2._node.duration * 10) / 10;
          if (parent._sprite.__default[1] === Infinity) {
            parent._sprite.__default[1] = parent._duration * 1e3;
          }
          parent._ended(self2);
        }
        self2._node.removeEventListener("ended", self2._endFn, false);
      }
    };
    var cache = {};
    var loadBuffer = function(self2) {
      var url2 = self2._src;
      if (cache[url2]) {
        self2._duration = cache[url2].duration;
        loadSound(self2);
        return;
      }
      if (/^data:[^;]+;base64,/.test(url2)) {
        var data = atob(url2.split(",")[1]);
        var dataView = new Uint8Array(data.length);
        for (var i = 0; i < data.length; ++i) {
          dataView[i] = data.charCodeAt(i);
        }
        decodeAudioData(dataView.buffer, self2);
      } else {
        var xhr = new XMLHttpRequest();
        xhr.open(self2._xhr.method, url2, true);
        xhr.withCredentials = self2._xhr.withCredentials;
        xhr.responseType = "arraybuffer";
        if (self2._xhr.headers) {
          Object.keys(self2._xhr.headers).forEach(function(key) {
            xhr.setRequestHeader(key, self2._xhr.headers[key]);
          });
        }
        xhr.onload = function() {
          var code2 = (xhr.status + "")[0];
          if (code2 !== "0" && code2 !== "2" && code2 !== "3") {
            self2._emit("loaderror", null, "Failed loading audio file with status: " + xhr.status + ".");
            return;
          }
          decodeAudioData(xhr.response, self2);
        };
        xhr.onerror = function() {
          if (self2._webAudio) {
            self2._html5 = true;
            self2._webAudio = false;
            self2._sounds = [];
            delete cache[url2];
            self2.load();
          }
        };
        safeXhrSend(xhr);
      }
    };
    var safeXhrSend = function(xhr) {
      try {
        xhr.send();
      } catch (e2) {
        xhr.onerror();
      }
    };
    var decodeAudioData = function(arraybuffer, self2) {
      var error = function() {
        self2._emit("loaderror", null, "Decoding audio data failed.");
      };
      var success = function(buffer2) {
        if (buffer2 && self2._sounds.length > 0) {
          cache[self2._src] = buffer2;
          loadSound(self2, buffer2);
        } else {
          error();
        }
      };
      if (typeof Promise !== "undefined" && Howler2.ctx.decodeAudioData.length === 1) {
        Howler2.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
      } else {
        Howler2.ctx.decodeAudioData(arraybuffer, success, error);
      }
    };
    var loadSound = function(self2, buffer2) {
      if (buffer2 && !self2._duration) {
        self2._duration = buffer2.duration;
      }
      if (Object.keys(self2._sprite).length === 0) {
        self2._sprite = { __default: [0, self2._duration * 1e3] };
      }
      if (self2._state !== "loaded") {
        self2._state = "loaded";
        self2._emit("load");
        self2._loadQueue();
      }
    };
    var setupAudioContext = function() {
      if (!Howler2.usingWebAudio) {
        return;
      }
      try {
        if (typeof AudioContext !== "undefined") {
          Howler2.ctx = new AudioContext();
        } else if (typeof webkitAudioContext !== "undefined") {
          Howler2.ctx = new webkitAudioContext();
        } else {
          Howler2.usingWebAudio = false;
        }
      } catch (e2) {
        Howler2.usingWebAudio = false;
      }
      if (!Howler2.ctx) {
        Howler2.usingWebAudio = false;
      }
      var iOS = /iP(hone|od|ad)/.test(Howler2._navigator && Howler2._navigator.platform);
      var appVersion = Howler2._navigator && Howler2._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
      var version = appVersion ? parseInt(appVersion[1], 10) : null;
      if (iOS && version && version < 9) {
        var safari = /safari/.test(Howler2._navigator && Howler2._navigator.userAgent.toLowerCase());
        if (Howler2._navigator && !safari) {
          Howler2.usingWebAudio = false;
        }
      }
      if (Howler2.usingWebAudio) {
        Howler2.masterGain = typeof Howler2.ctx.createGain === "undefined" ? Howler2.ctx.createGainNode() : Howler2.ctx.createGain();
        Howler2.masterGain.gain.setValueAtTime(Howler2._muted ? 0 : Howler2._volume, Howler2.ctx.currentTime);
        Howler2.masterGain.connect(Howler2.ctx.destination);
      }
      Howler2._setup();
    };
    {
      exports.Howler = Howler2;
      exports.Howl = Howl2;
    }
    if (typeof commonjsGlobal !== "undefined") {
      commonjsGlobal.HowlerGlobal = HowlerGlobal2;
      commonjsGlobal.Howler = Howler2;
      commonjsGlobal.Howl = Howl2;
      commonjsGlobal.Sound = Sound2;
    } else if (typeof window !== "undefined") {
      window.HowlerGlobal = HowlerGlobal2;
      window.Howler = Howler2;
      window.Howl = Howl2;
      window.Sound = Sound2;
    }
  })();
  /*!
   *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
   *  
   *  howler.js v2.2.3
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   */
  (function() {
    HowlerGlobal.prototype._pos = [0, 0, 0];
    HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];
    HowlerGlobal.prototype.stereo = function(pan) {
      var self2 = this;
      if (!self2.ctx || !self2.ctx.listener) {
        return self2;
      }
      for (var i = self2._howls.length - 1; i >= 0; i--) {
        self2._howls[i].stereo(pan);
      }
      return self2;
    };
    HowlerGlobal.prototype.pos = function(x, y, z) {
      var self2 = this;
      if (!self2.ctx || !self2.ctx.listener) {
        return self2;
      }
      y = typeof y !== "number" ? self2._pos[1] : y;
      z = typeof z !== "number" ? self2._pos[2] : z;
      if (typeof x === "number") {
        self2._pos = [x, y, z];
        if (typeof self2.ctx.listener.positionX !== "undefined") {
          self2.ctx.listener.positionX.setTargetAtTime(self2._pos[0], Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.positionY.setTargetAtTime(self2._pos[1], Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.positionZ.setTargetAtTime(self2._pos[2], Howler.ctx.currentTime, 0.1);
        } else {
          self2.ctx.listener.setPosition(self2._pos[0], self2._pos[1], self2._pos[2]);
        }
      } else {
        return self2._pos;
      }
      return self2;
    };
    HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
      var self2 = this;
      if (!self2.ctx || !self2.ctx.listener) {
        return self2;
      }
      var or = self2._orientation;
      y = typeof y !== "number" ? or[1] : y;
      z = typeof z !== "number" ? or[2] : z;
      xUp = typeof xUp !== "number" ? or[3] : xUp;
      yUp = typeof yUp !== "number" ? or[4] : yUp;
      zUp = typeof zUp !== "number" ? or[5] : zUp;
      if (typeof x === "number") {
        self2._orientation = [x, y, z, xUp, yUp, zUp];
        if (typeof self2.ctx.listener.forwardX !== "undefined") {
          self2.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
        } else {
          self2.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
        }
      } else {
        return or;
      }
      return self2;
    };
    Howl.prototype.init = function(_super) {
      return function(o) {
        var self2 = this;
        self2._orientation = o.orientation || [1, 0, 0];
        self2._stereo = o.stereo || null;
        self2._pos = o.pos || null;
        self2._pannerAttr = {
          coneInnerAngle: typeof o.coneInnerAngle !== "undefined" ? o.coneInnerAngle : 360,
          coneOuterAngle: typeof o.coneOuterAngle !== "undefined" ? o.coneOuterAngle : 360,
          coneOuterGain: typeof o.coneOuterGain !== "undefined" ? o.coneOuterGain : 0,
          distanceModel: typeof o.distanceModel !== "undefined" ? o.distanceModel : "inverse",
          maxDistance: typeof o.maxDistance !== "undefined" ? o.maxDistance : 1e4,
          panningModel: typeof o.panningModel !== "undefined" ? o.panningModel : "HRTF",
          refDistance: typeof o.refDistance !== "undefined" ? o.refDistance : 1,
          rolloffFactor: typeof o.rolloffFactor !== "undefined" ? o.rolloffFactor : 1
        };
        self2._onstereo = o.onstereo ? [{ fn: o.onstereo }] : [];
        self2._onpos = o.onpos ? [{ fn: o.onpos }] : [];
        self2._onorientation = o.onorientation ? [{ fn: o.onorientation }] : [];
        return _super.call(this, o);
      };
    }(Howl.prototype.init);
    Howl.prototype.stereo = function(pan, id) {
      var self2 = this;
      if (!self2._webAudio) {
        return self2;
      }
      if (self2._state !== "loaded") {
        self2._queue.push({
          event: "stereo",
          action: function() {
            self2.stereo(pan, id);
          }
        });
        return self2;
      }
      var pannerType = typeof Howler.ctx.createStereoPanner === "undefined" ? "spatial" : "stereo";
      if (typeof id === "undefined") {
        if (typeof pan === "number") {
          self2._stereo = pan;
          self2._pos = [pan, 0, 0];
        } else {
          return self2._stereo;
        }
      }
      var ids = self2._getSoundIds(id);
      for (var i = 0; i < ids.length; i++) {
        var sound = self2._soundById(ids[i]);
        if (sound) {
          if (typeof pan === "number") {
            sound._stereo = pan;
            sound._pos = [pan, 0, 0];
            if (sound._node) {
              sound._pannerAttr.panningModel = "equalpower";
              if (!sound._panner || !sound._panner.pan) {
                setupPanner(sound, pannerType);
              }
              if (pannerType === "spatial") {
                if (typeof sound._panner.positionX !== "undefined") {
                  sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                  sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                  sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
                } else {
                  sound._panner.setPosition(pan, 0, 0);
                }
              } else {
                sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
              }
            }
            self2._emit("stereo", sound._id);
          } else {
            return sound._stereo;
          }
        }
      }
      return self2;
    };
    Howl.prototype.pos = function(x, y, z, id) {
      var self2 = this;
      if (!self2._webAudio) {
        return self2;
      }
      if (self2._state !== "loaded") {
        self2._queue.push({
          event: "pos",
          action: function() {
            self2.pos(x, y, z, id);
          }
        });
        return self2;
      }
      y = typeof y !== "number" ? 0 : y;
      z = typeof z !== "number" ? -0.5 : z;
      if (typeof id === "undefined") {
        if (typeof x === "number") {
          self2._pos = [x, y, z];
        } else {
          return self2._pos;
        }
      }
      var ids = self2._getSoundIds(id);
      for (var i = 0; i < ids.length; i++) {
        var sound = self2._soundById(ids[i]);
        if (sound) {
          if (typeof x === "number") {
            sound._pos = [x, y, z];
            if (sound._node) {
              if (!sound._panner || sound._panner.pan) {
                setupPanner(sound, "spatial");
              }
              if (typeof sound._panner.positionX !== "undefined") {
                sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
                sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
                sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
              } else {
                sound._panner.setPosition(x, y, z);
              }
            }
            self2._emit("pos", sound._id);
          } else {
            return sound._pos;
          }
        }
      }
      return self2;
    };
    Howl.prototype.orientation = function(x, y, z, id) {
      var self2 = this;
      if (!self2._webAudio) {
        return self2;
      }
      if (self2._state !== "loaded") {
        self2._queue.push({
          event: "orientation",
          action: function() {
            self2.orientation(x, y, z, id);
          }
        });
        return self2;
      }
      y = typeof y !== "number" ? self2._orientation[1] : y;
      z = typeof z !== "number" ? self2._orientation[2] : z;
      if (typeof id === "undefined") {
        if (typeof x === "number") {
          self2._orientation = [x, y, z];
        } else {
          return self2._orientation;
        }
      }
      var ids = self2._getSoundIds(id);
      for (var i = 0; i < ids.length; i++) {
        var sound = self2._soundById(ids[i]);
        if (sound) {
          if (typeof x === "number") {
            sound._orientation = [x, y, z];
            if (sound._node) {
              if (!sound._panner) {
                if (!sound._pos) {
                  sound._pos = self2._pos || [0, 0, -0.5];
                }
                setupPanner(sound, "spatial");
              }
              if (typeof sound._panner.orientationX !== "undefined") {
                sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
                sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
                sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
              } else {
                sound._panner.setOrientation(x, y, z);
              }
            }
            self2._emit("orientation", sound._id);
          } else {
            return sound._orientation;
          }
        }
      }
      return self2;
    };
    Howl.prototype.pannerAttr = function() {
      var self2 = this;
      var args = arguments;
      var o, id, sound;
      if (!self2._webAudio) {
        return self2;
      }
      if (args.length === 0) {
        return self2._pannerAttr;
      } else if (args.length === 1) {
        if (typeof args[0] === "object") {
          o = args[0];
          if (typeof id === "undefined") {
            if (!o.pannerAttr) {
              o.pannerAttr = {
                coneInnerAngle: o.coneInnerAngle,
                coneOuterAngle: o.coneOuterAngle,
                coneOuterGain: o.coneOuterGain,
                distanceModel: o.distanceModel,
                maxDistance: o.maxDistance,
                refDistance: o.refDistance,
                rolloffFactor: o.rolloffFactor,
                panningModel: o.panningModel
              };
            }
            self2._pannerAttr = {
              coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== "undefined" ? o.pannerAttr.coneInnerAngle : self2._coneInnerAngle,
              coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== "undefined" ? o.pannerAttr.coneOuterAngle : self2._coneOuterAngle,
              coneOuterGain: typeof o.pannerAttr.coneOuterGain !== "undefined" ? o.pannerAttr.coneOuterGain : self2._coneOuterGain,
              distanceModel: typeof o.pannerAttr.distanceModel !== "undefined" ? o.pannerAttr.distanceModel : self2._distanceModel,
              maxDistance: typeof o.pannerAttr.maxDistance !== "undefined" ? o.pannerAttr.maxDistance : self2._maxDistance,
              refDistance: typeof o.pannerAttr.refDistance !== "undefined" ? o.pannerAttr.refDistance : self2._refDistance,
              rolloffFactor: typeof o.pannerAttr.rolloffFactor !== "undefined" ? o.pannerAttr.rolloffFactor : self2._rolloffFactor,
              panningModel: typeof o.pannerAttr.panningModel !== "undefined" ? o.pannerAttr.panningModel : self2._panningModel
            };
          }
        } else {
          sound = self2._soundById(parseInt(args[0], 10));
          return sound ? sound._pannerAttr : self2._pannerAttr;
        }
      } else if (args.length === 2) {
        o = args[0];
        id = parseInt(args[1], 10);
      }
      var ids = self2._getSoundIds(id);
      for (var i = 0; i < ids.length; i++) {
        sound = self2._soundById(ids[i]);
        if (sound) {
          var pa = sound._pannerAttr;
          pa = {
            coneInnerAngle: typeof o.coneInnerAngle !== "undefined" ? o.coneInnerAngle : pa.coneInnerAngle,
            coneOuterAngle: typeof o.coneOuterAngle !== "undefined" ? o.coneOuterAngle : pa.coneOuterAngle,
            coneOuterGain: typeof o.coneOuterGain !== "undefined" ? o.coneOuterGain : pa.coneOuterGain,
            distanceModel: typeof o.distanceModel !== "undefined" ? o.distanceModel : pa.distanceModel,
            maxDistance: typeof o.maxDistance !== "undefined" ? o.maxDistance : pa.maxDistance,
            refDistance: typeof o.refDistance !== "undefined" ? o.refDistance : pa.refDistance,
            rolloffFactor: typeof o.rolloffFactor !== "undefined" ? o.rolloffFactor : pa.rolloffFactor,
            panningModel: typeof o.panningModel !== "undefined" ? o.panningModel : pa.panningModel
          };
          var panner = sound._panner;
          if (panner) {
            panner.coneInnerAngle = pa.coneInnerAngle;
            panner.coneOuterAngle = pa.coneOuterAngle;
            panner.coneOuterGain = pa.coneOuterGain;
            panner.distanceModel = pa.distanceModel;
            panner.maxDistance = pa.maxDistance;
            panner.refDistance = pa.refDistance;
            panner.rolloffFactor = pa.rolloffFactor;
            panner.panningModel = pa.panningModel;
          } else {
            if (!sound._pos) {
              sound._pos = self2._pos || [0, 0, -0.5];
            }
            setupPanner(sound, "spatial");
          }
        }
      }
      return self2;
    };
    Sound.prototype.init = function(_super) {
      return function() {
        var self2 = this;
        var parent = self2._parent;
        self2._orientation = parent._orientation;
        self2._stereo = parent._stereo;
        self2._pos = parent._pos;
        self2._pannerAttr = parent._pannerAttr;
        _super.call(this);
        if (self2._stereo) {
          parent.stereo(self2._stereo);
        } else if (self2._pos) {
          parent.pos(self2._pos[0], self2._pos[1], self2._pos[2], self2._id);
        }
      };
    }(Sound.prototype.init);
    Sound.prototype.reset = function(_super) {
      return function() {
        var self2 = this;
        var parent = self2._parent;
        self2._orientation = parent._orientation;
        self2._stereo = parent._stereo;
        self2._pos = parent._pos;
        self2._pannerAttr = parent._pannerAttr;
        if (self2._stereo) {
          parent.stereo(self2._stereo);
        } else if (self2._pos) {
          parent.pos(self2._pos[0], self2._pos[1], self2._pos[2], self2._id);
        } else if (self2._panner) {
          self2._panner.disconnect(0);
          self2._panner = void 0;
          parent._refreshBuffer(self2);
        }
        return _super.call(this);
      };
    }(Sound.prototype.reset);
    var setupPanner = function(sound, type) {
      type = type || "spatial";
      if (type === "spatial") {
        sound._panner = Howler.ctx.createPanner();
        sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
        sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
        sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
        sound._panner.distanceModel = sound._pannerAttr.distanceModel;
        sound._panner.maxDistance = sound._pannerAttr.maxDistance;
        sound._panner.refDistance = sound._pannerAttr.refDistance;
        sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
        sound._panner.panningModel = sound._pannerAttr.panningModel;
        if (typeof sound._panner.positionX !== "undefined") {
          sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
          sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
          sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
        } else {
          sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
        }
        if (typeof sound._panner.orientationX !== "undefined") {
          sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
          sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
          sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
        } else {
          sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
        }
      } else {
        sound._panner = Howler.ctx.createStereoPanner();
        sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
      }
      sound._panner.connect(sound._node);
      if (!sound._paused) {
        sound._parent.pause(sound._id, true).play(sound._id, true);
      }
    };
  })();
})(howler);
class AudioHandler {
  constructor() {
    this.loadedAudio = {};
  }
  find(name) {
    const audio2 = this.loadedAudio[name];
    if (!audio2) {
      const fullFileNames = Object.keys(this.loadedAudio);
      const fileNamesOnly = fullFileNames.map(omitFileExtension);
      const index2 = fileNamesOnly.findIndex((key) => key === name);
      if (index2 > -1) {
        return this.loadedAudio[Object.keys(this.loadedAudio)[index2]];
      }
      return void 0;
    }
    return audio2;
  }
  add(name, instance, url2) {
    var _a2;
    (_a2 = this.find(name)) == null ? void 0 : _a2.instance.stop();
    this.loadedAudio[name] = { instance, url: url2 };
  }
  async getHTMLAudio(name) {
    var _a2;
    const url2 = (_a2 = this.find(name)) == null ? void 0 : _a2.url;
    if (url2 === void 0)
      return;
    const audio2 = await new Promise((resolve2) => {
      const howl = new howler.Howl({
        src: url2,
        format: ["mp3", "wav", "mpga", "ogg"],
        onload: () => {
          resolve2(howl);
        },
        onloaderror: () => {
          resolve2(howl);
        },
        html5: true
      });
    });
    return { instance: audio2, url: url2 };
  }
  play(name) {
    var _a2;
    (_a2 = this.find(name)) == null ? void 0 : _a2.instance.play();
  }
  playOnce(name) {
    var _a2, _b2;
    (_a2 = this.find(name)) == null ? void 0 : _a2.instance.pause();
    (_b2 = this.find(name)) == null ? void 0 : _b2.instance.play();
  }
  playOnceAsync(name) {
    return new Promise((resolve2) => {
      var _a2, _b2, _c2;
      (_a2 = this.find(name)) == null ? void 0 : _a2.instance.once("play", resolve2);
      (_b2 = this.find(name)) == null ? void 0 : _b2.instance.pause();
      (_c2 = this.find(name)) == null ? void 0 : _c2.instance.play();
    });
  }
  pause(name) {
    var _a2;
    (_a2 = this.find(name)) == null ? void 0 : _a2.instance.pause();
  }
  stop(name) {
    var _a2;
    (_a2 = this.find(name)) == null ? void 0 : _a2.instance.stop();
  }
  seek(name, time) {
    var _a2;
    (_a2 = this.find(name)) == null ? void 0 : _a2.instance.seek(time);
  }
  getCurrentTime(name) {
    var _a2, _b2;
    return ((_b2 = (_a2 = this.find(name)) == null ? void 0 : _a2.instance.seek()) != null ? _b2 : 0) * 1e3;
  }
}
function Mime$1() {
  this._types = /* @__PURE__ */ Object.create(null);
  this._extensions = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < arguments.length; i++) {
    this.define(arguments[i]);
  }
  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getExtension = this.getExtension.bind(this);
}
Mime$1.prototype.define = function(typeMap, force) {
  for (let type in typeMap) {
    let extensions = typeMap[type].map(function(t) {
      return t.toLowerCase();
    });
    type = type.toLowerCase();
    for (let i = 0; i < extensions.length; i++) {
      const ext = extensions[i];
      if (ext[0] === "*") {
        continue;
      }
      if (!force && ext in this._types) {
        throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
      }
      this._types[ext] = type;
    }
    if (force || !this._extensions[type]) {
      const ext = extensions[0];
      this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
    }
  }
};
Mime$1.prototype.getType = function(path) {
  path = String(path);
  let last = path.replace(/^.*[/\\]/, "").toLowerCase();
  let ext = last.replace(/^.*\./, "").toLowerCase();
  let hasPath = last.length < path.length;
  let hasDot = ext.length < last.length - 1;
  return (hasDot || !hasPath) && this._types[ext] || null;
};
Mime$1.prototype.getExtension = function(type) {
  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
  return type && this._extensions[type.toLowerCase()] || null;
};
var Mime_1 = Mime$1;
var standard = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
let Mime = Mime_1;
var lite = new Mime(standard);
function audioMiddleware(audioHandler) {
  return async function _audioMiddleware(resource, next) {
    var _a2;
    let { mimeType } = resource.metadata;
    if (mimeType) {
      if (Array.isArray(mimeType)) {
        mimeType = mimeType[0];
      }
      const extension = (_a2 = lite.getExtension(mimeType)) != null ? _a2 : "";
      const fileType = getExtensionType(extension);
      if (fileType === "audio") {
        const audio2 = await new Promise((resolve2) => {
          const howl = new howler.Howl({
            src: resource.url,
            format: ["mp3", "wav", "mpga", "ogg"],
            onload: () => {
              resolve2(howl);
            },
            onloaderror: () => {
              resolve2(howl);
            }
          });
        });
        audioHandler.add(resource.name, audio2, resource.url);
      }
    }
    next();
  };
}
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e2, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer2[offset + i];
  i += d;
  e2 = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  m = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e2 - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e2, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e2)) < 1) {
      e2--;
      c *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e2++;
      c /= 2;
    }
    if (e2 + eBias >= eMax) {
      m = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e2 & 255, i += d, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer3;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer3.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer3.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function Buffer3(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer3.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer3.from(valueOf, encodingOrOffset, length);
    }
    const b = fromObject(value);
    if (b)
      return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer3.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer3, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc2(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer3.alloc = function(size, fill, encoding) {
    return alloc2(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer3.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer3.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer3.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer3.alloc(+length);
  }
  Buffer3.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer3.prototype;
  };
  Buffer3.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array))
      a = Buffer3.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array))
      b = Buffer3.from(b, b.offset, b.byteLength);
    if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b)
      return 0;
    let x = a.length;
    let y = b.length;
    for (let i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer3.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer3.concat = function concat2(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer3.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    const buffer2 = Buffer3.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer3.isBuffer(buf))
            buf = Buffer3.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer3.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer3.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.prototype._isBuffer = true;
  function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  Buffer3.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer3.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer3.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer3.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
  Buffer3.prototype.equals = function equals2(b) {
    if (!Buffer3.isBuffer(b))
      throw new TypeError("Argument must be a Buffer");
    if (this === b)
      return true;
    return Buffer3.compare(this, b) === 0;
  };
  Buffer3.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
  }
  Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer3.from(target, target.offset, target.byteLength);
    }
    if (!Buffer3.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer3.from(val, encoding);
    }
    if (Buffer3.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read2(arr, i + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer3.prototype.write = function write2(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer3.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer3.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer3.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer3.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer3.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer3.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  const errors = {};
  function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) {
      return `${name} is outside of buffer bounds`;
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength3) {
    if (value > max || value < min) {
      const n = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      } else {
        range = `>= ${min}${n} and <= ${max}${n}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length)
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table2 = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j = 0; j < 16; ++j) {
        table2[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table2;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
class ReplayNode {
  constructor(timestamp, deltaTime, x, y, numericKeys) {
    this.prev = null;
    this.next = null;
    this.deltaTime = deltaTime;
    this.x = x;
    this.y = y;
    this.keypress = numericKeys;
    this.timestamp = timestamp;
  }
  translate(x, y) {
    this.x += x;
    this.y += y;
  }
  translateX(x) {
    this.x += x;
  }
  translateY(y) {
    this.y += y;
  }
  isHolding(key, exclusive = false) {
    if (exclusive) {
      switch (key) {
        case "K1": {
          return this.keypress === (4 | 1);
        }
        case "K2": {
          return this.keypress === (8 | 2);
        }
        case "M1": {
          return this.keypress === 1;
        }
        case "M2": {
          return this.keypress === 2;
        }
        default: {
          return this.keypress !== 0;
        }
      }
    }
    switch (key) {
      case "K1": {
        return (this.keypress & 4) === 4;
      }
      case "K2": {
        return (this.keypress & 8) === 8;
      }
      case "M1": {
        return (this.keypress & 1) === 1;
      }
      case "M2": {
        return (this.keypress & 2) === 2;
      }
      case "SMOKE": {
        return (this.keypress & 16) === 16;
      }
      default: {
        return (this.keypress & ~(this.keypress & 16)) > 0;
      }
    }
  }
  isPressing(key, exclusive = false) {
    if (key === void 0) {
      const KEYS = ["K1", "K2", "M1", "M2"];
      return KEYS.some((key2) => this.isPressing(key2, exclusive));
    }
    if (this.prev === null) {
      return this.isHolding(key, exclusive);
    }
    return !this.prev.isHolding(key, exclusive) && this.isHolding(key, exclusive);
  }
  isReleasing(key, exclusive = false) {
    if (this.next === null) {
      return this.isHolding(key, exclusive);
    }
    return !this.next.isHolding(key, exclusive) && this.isHolding(key, exclusive);
  }
  setKeypress(...keys) {
    this.keypress = 0;
    this.addKeypress(...keys);
  }
  addKeypress(...keys) {
    keys.forEach((key) => this.keypress |= key);
  }
  removeKeypress(key) {
    this.keypress = this.keypress & ~(this.keypress & key);
  }
  clone() {
    return new ReplayNode(this.timestamp, this.deltaTime, this.x, this.y, this.keypress);
  }
}
class ReplayData extends Array {
  constructor(replayData) {
    if (replayData === void 0) {
      super();
      return;
    }
    let nodes = [];
    if (typeof replayData === "string") {
      const parsedReplayData = replayData.split(",").slice(0, -1).map((row) => row.split("|").map(Number));
      let accumulatedTime = 0;
      for (let i = 0; i < parsedReplayData.length; i++) {
        const data = parsedReplayData[i];
        const [deltaTime, x, y, numericKeys] = data;
        accumulatedTime += deltaTime;
        const node = new ReplayNode(accumulatedTime, deltaTime, x, y, numericKeys);
        nodes.push(node);
      }
      for (let i = 0; i < parsedReplayData.length; i++) {
        if (i > 0)
          nodes[i].prev = nodes[i - 1];
        if (i < parsedReplayData.length - 1) {
          nodes[i].next = nodes[i + 1];
        }
      }
    } else if (replayData instanceof ReplayNode) {
      nodes = replayData;
    }
    super(nodes.length);
    for (let i = 0; i < nodes.length; i++) {
      this[i] = nodes[i];
    }
  }
  toString() {
    let str = "";
    this.forEach((node) => {
      str += `${node.deltaTime}|${node.x}|${node.y}|${node.keypress},`;
    });
    return str;
  }
  getMultipleNear(timestamp, prevCount = 0, nextCount = 0) {
    const index2 = this.getIndexNear(timestamp);
    const startIndex = Math.max(index2 - prevCount, 0);
    const endIndex = Math.min(index2 + nextCount + 1, this.length);
    return this.slice(startIndex, endIndex);
  }
  getMultiple(from, to) {
    const startIndex = this.getIndexNear(from);
    const endIndex = this.getIndexNear(to);
    return this.slice(startIndex, endIndex);
  }
  getIndexNear(timestamp) {
    let mid;
    let lo = 0;
    let hi = this.length - 1;
    while (hi - lo > 1) {
      mid = Math.floor((lo + hi) / 2);
      if (this[mid].timestamp < timestamp) {
        lo = mid;
      } else {
        hi = mid;
      }
    }
    if (timestamp - this[lo].timestamp <= this[hi].timestamp - timestamp) {
      return lo;
    }
    return hi;
  }
  getNear(timestamp) {
    return this[this.getIndexNear(timestamp)];
  }
  getPositionAt(timestamp, interpolate = false) {
    const index2 = this.getIndexNear(timestamp);
    const node = this[index2];
    if (!interpolate) {
      return [node.x, node.y];
    }
    if (node.timestamp === timestamp) {
      return [node.x, node.y];
    }
    if (node.timestamp < timestamp) {
      const nextNode = this[index2 + 1];
      if (!nextNode) {
        return [node.x, node.y];
      }
      const deltaTime = nextNode.deltaTime;
      const deltaX = nextNode.x - node.x;
      const deltaY = nextNode.y - node.y;
      const timeDiff = timestamp - node.timestamp;
      const timeRatio = timeDiff / deltaTime;
      return [node.x + deltaX * timeRatio, node.y + deltaY * timeRatio];
    } else {
      const prevNode = this[index2 - 1];
      if (!prevNode) {
        return [node.x, node.y];
      }
      const deltaTime = node.deltaTime;
      const deltaX = node.x - prevNode.x;
      const deltaY = node.y - prevNode.y;
      const timeDiff = timestamp - prevNode.timestamp;
      const timeRatio = timeDiff / deltaTime;
      return [prevNode.x + deltaX * timeRatio, prevNode.y + deltaY * timeRatio];
    }
  }
}
function extract(buffer2, bitIndex, bitLength, defaultBit) {
  if (bitLength < 0 || bitLength > 32) {
    throw new Error("Bad value for bitLength.");
  }
  if (defaultBit === void 0) {
    defaultBit = 0;
  } else if (defaultBit !== 0 && defaultBit !== 1) {
    throw new Error("Bad value for defaultBit.");
  }
  var defaultByte = defaultBit * 255;
  var result = 0;
  var lastBit = bitIndex + bitLength;
  var startByte = Math.floor(bitIndex / 8);
  var startBit = bitIndex % 8;
  var endByte = Math.floor(lastBit / 8);
  var endBit = lastBit % 8;
  if (endBit !== 0) {
    result = get(endByte) & (1 << endBit) - 1;
  }
  while (endByte > startByte) {
    endByte--;
    result = result << 8 | get(endByte);
  }
  result >>>= startBit;
  return result;
  function get(index2) {
    var result2 = buffer2[index2];
    return result2 === void 0 ? defaultByte : result2;
  }
}
function inject(buffer2, bitIndex, bitLength, value) {
  if (bitLength < 0 || bitLength > 32) {
    throw new Error("Bad value for bitLength.");
  }
  var lastByte = Math.floor((bitIndex + bitLength - 1) / 8);
  if (bitIndex < 0 || lastByte >= buffer2.length) {
    throw new Error("Index out of range.");
  }
  var atByte = Math.floor(bitIndex / 8);
  var atBit = bitIndex % 8;
  while (bitLength > 0) {
    if (value & 1) {
      buffer2[atByte] |= 1 << atBit;
    } else {
      buffer2[atByte] &= ~(1 << atBit);
    }
    value >>= 1;
    bitLength--;
    atBit = (atBit + 1) % 8;
    if (atBit === 0) {
      atByte++;
    }
  }
}
function getSign(buffer2) {
  return buffer2[buffer2.length - 1] >>> 7;
}
function highOrder(bit, buffer2) {
  var length = buffer2.length;
  var fullyWrongByte = (bit ^ 1) * 255;
  while (length > 0 && buffer2[length - 1] === fullyWrongByte) {
    length--;
  }
  if (length === 0) {
    return -1;
  }
  var byteToCheck = buffer2[length - 1];
  var result = length * 8 - 1;
  for (var i = 7; i > 0; i--) {
    if ((byteToCheck >> i & 1) === bit) {
      break;
    }
    result--;
  }
  return result;
}
var bits$1 = {
  extract,
  inject,
  getSign,
  highOrder
};
var { Buffer: Buffer2 } = buffer;
var bufPool = [];
var TEMP_BUF_MAXIMUM_LENGTH = 20;
var MIN_EXACT_INT64 = -9223372036854776e3;
var MAX_EXACT_INT64 = 9223372036854775e3;
var MAX_EXACT_UINT64 = 1844674407370955e4;
var BIT_32 = 4294967296;
var BIT_64 = 18446744073709552e3;
function lowestBit(num) {
  return num & -num;
}
function isLossyToAdd(accum, num) {
  if (num === 0) {
    return false;
  }
  var lowBit = lowestBit(num);
  var added = accum + lowBit;
  if (added === accum) {
    return true;
  }
  if (added - lowBit !== accum) {
    return true;
  }
  return false;
}
function alloc(length) {
  var result = bufPool[length];
  if (result) {
    bufPool[length] = void 0;
  } else {
    result = new Buffer2(length);
  }
  result.fill(0);
  return result;
}
function free(buffer2) {
  var length = buffer2.length;
  if (length < TEMP_BUF_MAXIMUM_LENGTH) {
    bufPool[length] = buffer2;
  }
}
function resize(buffer2, length) {
  if (length === buffer2.length) {
    return buffer2;
  }
  var newBuf = alloc(length);
  buffer2.copy(newBuf);
  free(buffer2);
  return newBuf;
}
function readInt(buffer2) {
  var length = buffer2.length;
  var positive = buffer2[length - 1] < 128;
  var result = positive ? 0 : -1;
  var lossy = false;
  if (length < 7) {
    for (var i = length - 1; i >= 0; i--) {
      result = result * 256 + buffer2[i];
    }
  } else {
    for (var i = length - 1; i >= 0; i--) {
      var one = buffer2[i];
      result *= 256;
      if (isLossyToAdd(result, one)) {
        lossy = true;
      }
      result += one;
    }
  }
  return { value: result, lossy };
}
function readUInt(buffer2) {
  var length = buffer2.length;
  var result = 0;
  var lossy = false;
  if (length < 7) {
    for (var i = length - 1; i >= 0; i--) {
      result = result * 256 + buffer2[i];
    }
  } else {
    for (var i = length - 1; i >= 0; i--) {
      var one = buffer2[i];
      result *= 256;
      if (isLossyToAdd(result, one)) {
        lossy = true;
      }
      result += one;
    }
  }
  return { value: result, lossy };
}
function writeInt64(value, buffer2) {
  if (value < MIN_EXACT_INT64 || value > MAX_EXACT_INT64) {
    throw new Error("Value out of range.");
  }
  if (value < 0) {
    value += BIT_64;
  }
  writeUInt64(value, buffer2);
}
function writeUInt64(value, buffer2) {
  if (value < 0 || value > MAX_EXACT_UINT64) {
    throw new Error("Value out of range.");
  }
  var lowWord = value % BIT_32;
  var highWord = Math.floor(value / BIT_32);
  buffer2.writeUInt32LE(lowWord, 0);
  buffer2.writeUInt32LE(highWord, 4);
}
var bufs$1 = {
  alloc,
  free,
  readInt,
  readUInt,
  resize,
  writeInt64,
  writeUInt64
};
var bits = bits$1;
var bufs = bufs$1;
var MIN_INT32 = -2147483648;
var MAX_INT32 = 2147483647;
var MAX_UINT32 = 4294967295;
var MIN_INT64 = -9223372036854776e3;
var MAX_INT64 = 9223372036854775e3;
var MAX_UINT64 = 1844674407370955e4;
function signedBitCount(buffer2) {
  return bits.highOrder(bits.getSign(buffer2) ^ 1, buffer2) + 2;
}
function unsignedBitCount(buffer2) {
  var result = bits.highOrder(1, buffer2) + 1;
  return result ? result : 1;
}
function encodeBufferCommon(buffer2, signed) {
  var signBit;
  var bitCount;
  if (signed) {
    signBit = bits.getSign(buffer2);
    bitCount = signedBitCount(buffer2);
  } else {
    signBit = 0;
    bitCount = unsignedBitCount(buffer2);
  }
  var byteCount = Math.ceil(bitCount / 7);
  var result = bufs.alloc(byteCount);
  for (var i = 0; i < byteCount; i++) {
    var payload = bits.extract(buffer2, i * 7, 7, signBit);
    result[i] = payload | 128;
  }
  result[byteCount - 1] &= 127;
  return result;
}
function encodedLength(encodedBuffer, index2) {
  var result = 0;
  while (encodedBuffer[index2 + result] >= 128) {
    result++;
  }
  result++;
  if (index2 + result > encodedBuffer.length) {
    throw new Error("Bogus encoding");
  }
  return result;
}
function decodeBufferCommon(encodedBuffer, index2, signed) {
  index2 = index2 === void 0 ? 0 : index2;
  var length = encodedLength(encodedBuffer, index2);
  var bitLength = length * 7;
  var byteLength2 = Math.ceil(bitLength / 8);
  var result = bufs.alloc(byteLength2);
  var outIndex = 0;
  while (length > 0) {
    bits.inject(result, outIndex, 7, encodedBuffer[index2]);
    outIndex += 7;
    index2++;
    length--;
  }
  var signBit;
  var signByte;
  if (signed) {
    var lastByte = result[byteLength2 - 1];
    var endBit = outIndex % 8;
    if (endBit !== 0) {
      var shift = 32 - endBit;
      lastByte = result[byteLength2 - 1] = lastByte << shift >> shift & 255;
    }
    signBit = lastByte >> 7;
    signByte = signBit * 255;
  } else {
    signBit = 0;
    signByte = 0;
  }
  while (byteLength2 > 1 && result[byteLength2 - 1] === signByte && (!signed || result[byteLength2 - 2] >> 7 === signBit)) {
    byteLength2--;
  }
  result = bufs.resize(result, byteLength2);
  return { value: result, nextIndex: index2 };
}
function encodeIntBuffer(buffer2) {
  return encodeBufferCommon(buffer2, true);
}
function decodeIntBuffer(encodedBuffer, index2) {
  return decodeBufferCommon(encodedBuffer, index2, true);
}
function encodeInt32(num) {
  var buf = bufs.alloc(4);
  buf.writeInt32LE(num, 0);
  var result = encodeIntBuffer(buf);
  bufs.free(buf);
  return result;
}
function decodeInt32(encodedBuffer, index2) {
  var result = decodeIntBuffer(encodedBuffer, index2);
  var parsed = bufs.readInt(result.value);
  var value = parsed.value;
  bufs.free(result.value);
  if (value < MIN_INT32 || value > MAX_INT32) {
    throw new Error("Result out of range");
  }
  return { value, nextIndex: result.nextIndex };
}
function encodeInt64(num) {
  var buf = bufs.alloc(8);
  bufs.writeInt64(num, buf);
  var result = encodeIntBuffer(buf);
  bufs.free(buf);
  return result;
}
function decodeInt64(encodedBuffer, index2) {
  var result = decodeIntBuffer(encodedBuffer, index2);
  var parsed = bufs.readInt(result.value);
  var value = parsed.value;
  bufs.free(result.value);
  if (value < MIN_INT64 || value > MAX_INT64) {
    throw new Error("Result out of range");
  }
  return { value, nextIndex: result.nextIndex, lossy: parsed.lossy };
}
function encodeUIntBuffer(buffer2) {
  return encodeBufferCommon(buffer2, false);
}
function decodeUIntBuffer(encodedBuffer, index2) {
  return decodeBufferCommon(encodedBuffer, index2, false);
}
function encodeUInt32(num) {
  var buf = bufs.alloc(4);
  buf.writeUInt32LE(num, 0);
  var result = encodeUIntBuffer(buf);
  bufs.free(buf);
  return result;
}
function decodeUInt32(encodedBuffer, index2) {
  var result = decodeUIntBuffer(encodedBuffer, index2);
  var parsed = bufs.readUInt(result.value);
  var value = parsed.value;
  bufs.free(result.value);
  if (value > MAX_UINT32) {
    throw new Error("Result out of range");
  }
  return { value, nextIndex: result.nextIndex };
}
function encodeUInt64(num) {
  var buf = bufs.alloc(8);
  bufs.writeUInt64(num, buf);
  var result = encodeUIntBuffer(buf);
  bufs.free(buf);
  return result;
}
function decodeUInt64(encodedBuffer, index2) {
  var result = decodeUIntBuffer(encodedBuffer, index2);
  var parsed = bufs.readUInt(result.value);
  var value = parsed.value;
  bufs.free(result.value);
  if (value > MAX_UINT64) {
    throw new Error("Result out of range");
  }
  return { value, nextIndex: result.nextIndex, lossy: parsed.lossy };
}
var leb = {
  decodeInt32,
  decodeInt64,
  decodeIntBuffer,
  decodeUInt32,
  decodeUInt64,
  decodeUIntBuffer,
  encodeInt32,
  encodeInt64,
  encodeIntBuffer,
  encodeUInt32,
  encodeUInt64,
  encodeUIntBuffer
};
var LZMA = function() {
  var action_compress = 1, action_decompress = 2, action_progress = 3, wait2 = typeof setImmediate == "function" ? setImmediate : setTimeout, __4294967296 = 4294967296, N1_longLit = [4294967295, -__4294967296], MIN_VALUE = [0, -9223372036854776e3], P0_longLit = [0, 0], P1_longLit = [1, 0];
  function update_progress(percent, cbn) {
    postMessage({
      action: action_progress,
      cbn,
      result: percent
    });
  }
  function initDim(len) {
    var a = [];
    a[len - 1] = void 0;
    return a;
  }
  function add2(a, b) {
    return create(a[0] + b[0], a[1] + b[1]);
  }
  function and(a, b) {
    return makeFromBits(~~Math.max(Math.min(a[1] / __4294967296, 2147483647), -2147483648) & ~~Math.max(Math.min(b[1] / __4294967296, 2147483647), -2147483648), lowBits_0(a) & lowBits_0(b));
  }
  function compare(a, b) {
    var nega, negb;
    if (a[0] == b[0] && a[1] == b[1]) {
      return 0;
    }
    nega = a[1] < 0;
    negb = b[1] < 0;
    if (nega && !negb) {
      return -1;
    }
    if (!nega && negb) {
      return 1;
    }
    if (sub(a, b)[1] < 0) {
      return -1;
    }
    return 1;
  }
  function create(valueLow, valueHigh) {
    var diffHigh, diffLow;
    valueHigh %= 18446744073709552e3;
    valueLow %= 18446744073709552e3;
    diffHigh = valueHigh % __4294967296;
    diffLow = Math.floor(valueLow / __4294967296) * __4294967296;
    valueHigh = valueHigh - diffHigh + diffLow;
    valueLow = valueLow - diffLow + diffHigh;
    while (valueLow < 0) {
      valueLow += __4294967296;
      valueHigh -= __4294967296;
    }
    while (valueLow > 4294967295) {
      valueLow -= __4294967296;
      valueHigh += __4294967296;
    }
    valueHigh = valueHigh % 18446744073709552e3;
    while (valueHigh > 9223372032559809e3) {
      valueHigh -= 18446744073709552e3;
    }
    while (valueHigh < -9223372036854776e3) {
      valueHigh += 18446744073709552e3;
    }
    return [valueLow, valueHigh];
  }
  function eq(a, b) {
    return a[0] == b[0] && a[1] == b[1];
  }
  function fromInt(value) {
    if (value >= 0) {
      return [value, 0];
    } else {
      return [value + __4294967296, -__4294967296];
    }
  }
  function lowBits_0(a) {
    if (a[0] >= 2147483648) {
      return ~~Math.max(Math.min(a[0] - __4294967296, 2147483647), -2147483648);
    } else {
      return ~~Math.max(Math.min(a[0], 2147483647), -2147483648);
    }
  }
  function makeFromBits(highBits, lowBits) {
    var high, low;
    high = highBits * __4294967296;
    low = lowBits;
    if (lowBits < 0) {
      low += __4294967296;
    }
    return [low, high];
  }
  function pwrAsDouble(n) {
    if (n <= 30) {
      return 1 << n;
    } else {
      return pwrAsDouble(30) * pwrAsDouble(n - 30);
    }
  }
  function shl(a, n) {
    var diff, newHigh, newLow, twoToN;
    n &= 63;
    if (eq(a, MIN_VALUE)) {
      if (!n) {
        return a;
      }
      return P0_longLit;
    }
    if (a[1] < 0) {
      throw new Error("Neg");
    }
    twoToN = pwrAsDouble(n);
    newHigh = a[1] * twoToN % 18446744073709552e3;
    newLow = a[0] * twoToN;
    diff = newLow - newLow % __4294967296;
    newHigh += diff;
    newLow -= diff;
    if (newHigh >= 9223372036854776e3) {
      newHigh -= 18446744073709552e3;
    }
    return [newLow, newHigh];
  }
  function shr(a, n) {
    var shiftFact;
    n &= 63;
    shiftFact = pwrAsDouble(n);
    return create(Math.floor(a[0] / shiftFact), a[1] / shiftFact);
  }
  function shru(a, n) {
    var sr;
    n &= 63;
    sr = shr(a, n);
    if (a[1] < 0) {
      sr = add2(sr, shl([2, 0], 63 - n));
    }
    return sr;
  }
  function sub(a, b) {
    return create(a[0] - b[0], a[1] - b[1]);
  }
  function $ByteArrayInputStream(this$static, buf) {
    this$static.buf = buf;
    this$static.pos = 0;
    this$static.count = buf.length;
    return this$static;
  }
  function $read(this$static) {
    if (this$static.pos >= this$static.count)
      return -1;
    return this$static.buf[this$static.pos++] & 255;
  }
  function $read_0(this$static, buf, off, len) {
    if (this$static.pos >= this$static.count)
      return -1;
    len = Math.min(len, this$static.count - this$static.pos);
    arraycopy(this$static.buf, this$static.pos, buf, off, len);
    this$static.pos += len;
    return len;
  }
  function $ByteArrayOutputStream(this$static) {
    this$static.buf = initDim(32);
    this$static.count = 0;
    return this$static;
  }
  function $toByteArray(this$static) {
    var data = this$static.buf;
    data.length = this$static.count;
    return data;
  }
  function $write(this$static, b) {
    this$static.buf[this$static.count++] = b << 24 >> 24;
  }
  function $write_0(this$static, buf, off, len) {
    arraycopy(buf, off, this$static.buf, this$static.count, len);
    this$static.count += len;
  }
  function $getChars(this$static, srcBegin, srcEnd, dst, dstBegin) {
    var srcIdx;
    for (srcIdx = srcBegin; srcIdx < srcEnd; ++srcIdx) {
      dst[dstBegin++] = this$static.charCodeAt(srcIdx);
    }
  }
  function arraycopy(src, srcOfs, dest, destOfs, len) {
    for (var i = 0; i < len; ++i) {
      dest[destOfs + i] = src[srcOfs + i];
    }
  }
  function $configure(this$static, encoder) {
    $SetDictionarySize_0(encoder, 1 << this$static.s);
    encoder._numFastBytes = this$static.f;
    $SetMatchFinder(encoder, this$static.m);
    encoder._numLiteralPosStateBits = 0;
    encoder._numLiteralContextBits = 3;
    encoder._posStateBits = 2;
    encoder._posStateMask = 3;
  }
  function $init(this$static, input, output, length_0, mode2) {
    var encoder, i;
    if (compare(length_0, N1_longLit) < 0)
      throw new Error("invalid length " + length_0);
    this$static.length_0 = length_0;
    encoder = $Encoder({});
    $configure(mode2, encoder);
    encoder._writeEndMark = typeof LZMA.disableEndMark == "undefined";
    $WriteCoderProperties(encoder, output);
    for (i = 0; i < 64; i += 8)
      $write(output, lowBits_0(shr(length_0, i)) & 255);
    this$static.chunker = (encoder._needReleaseMFStream = 0, encoder._inStream = input, encoder._finished = 0, $Create_2(encoder), encoder._rangeEncoder.Stream = output, $Init_4(encoder), $FillDistancesPrices(encoder), $FillAlignPrices(encoder), encoder._lenEncoder._tableSize = encoder._numFastBytes + 1 - 2, $UpdateTables(encoder._lenEncoder, 1 << encoder._posStateBits), encoder._repMatchLenEncoder._tableSize = encoder._numFastBytes + 1 - 2, $UpdateTables(encoder._repMatchLenEncoder, 1 << encoder._posStateBits), encoder.nowPos64 = P0_longLit, void 0, $Chunker_0({}, encoder));
  }
  function $LZMAByteArrayCompressor(this$static, data, mode2) {
    this$static.output = $ByteArrayOutputStream({});
    $init(this$static, $ByteArrayInputStream({}, data), this$static.output, fromInt(data.length), mode2);
    return this$static;
  }
  function $init_0(this$static, input, output) {
    var decoder, hex_length = "", i, properties = [], r, tmp_length;
    for (i = 0; i < 5; ++i) {
      r = $read(input);
      if (r == -1)
        throw new Error("truncated input");
      properties[i] = r << 24 >> 24;
    }
    decoder = $Decoder({});
    if (!$SetDecoderProperties(decoder, properties)) {
      throw new Error("corrupted input");
    }
    for (i = 0; i < 64; i += 8) {
      r = $read(input);
      if (r == -1)
        throw new Error("truncated input");
      r = r.toString(16);
      if (r.length == 1)
        r = "0" + r;
      hex_length = r + "" + hex_length;
    }
    if (/^0+$|^f+$/i.test(hex_length)) {
      this$static.length_0 = N1_longLit;
    } else {
      tmp_length = parseInt(hex_length, 16);
      if (tmp_length > 4294967295) {
        this$static.length_0 = N1_longLit;
      } else {
        this$static.length_0 = fromInt(tmp_length);
      }
    }
    this$static.chunker = $CodeInChunks(decoder, input, output, this$static.length_0);
  }
  function $LZMAByteArrayDecompressor(this$static, data) {
    this$static.output = $ByteArrayOutputStream({});
    $init_0(this$static, $ByteArrayInputStream({}, data), this$static.output);
    return this$static;
  }
  function $Create_4(this$static, keepSizeBefore, keepSizeAfter, keepSizeReserv) {
    var blockSize;
    this$static._keepSizeBefore = keepSizeBefore;
    this$static._keepSizeAfter = keepSizeAfter;
    blockSize = keepSizeBefore + keepSizeAfter + keepSizeReserv;
    if (this$static._bufferBase == null || this$static._blockSize != blockSize) {
      this$static._bufferBase = null;
      this$static._blockSize = blockSize;
      this$static._bufferBase = initDim(this$static._blockSize);
    }
    this$static._pointerToLastSafePosition = this$static._blockSize - keepSizeAfter;
  }
  function $GetIndexByte(this$static, index2) {
    return this$static._bufferBase[this$static._bufferOffset + this$static._pos + index2];
  }
  function $GetMatchLen(this$static, index2, distance, limit) {
    var i, pby;
    if (this$static._streamEndWasReached) {
      if (this$static._pos + index2 + limit > this$static._streamPos) {
        limit = this$static._streamPos - (this$static._pos + index2);
      }
    }
    ++distance;
    pby = this$static._bufferOffset + this$static._pos + index2;
    for (i = 0; i < limit && this$static._bufferBase[pby + i] == this$static._bufferBase[pby + i - distance]; ++i) {
    }
    return i;
  }
  function $GetNumAvailableBytes(this$static) {
    return this$static._streamPos - this$static._pos;
  }
  function $MoveBlock(this$static) {
    var i, numBytes, offset;
    offset = this$static._bufferOffset + this$static._pos - this$static._keepSizeBefore;
    if (offset > 0) {
      --offset;
    }
    numBytes = this$static._bufferOffset + this$static._streamPos - offset;
    for (i = 0; i < numBytes; ++i) {
      this$static._bufferBase[i] = this$static._bufferBase[offset + i];
    }
    this$static._bufferOffset -= offset;
  }
  function $MovePos_1(this$static) {
    var pointerToPostion;
    ++this$static._pos;
    if (this$static._pos > this$static._posLimit) {
      pointerToPostion = this$static._bufferOffset + this$static._pos;
      if (pointerToPostion > this$static._pointerToLastSafePosition) {
        $MoveBlock(this$static);
      }
      $ReadBlock(this$static);
    }
  }
  function $ReadBlock(this$static) {
    var numReadBytes, pointerToPostion, size;
    if (this$static._streamEndWasReached)
      return;
    while (1) {
      size = -this$static._bufferOffset + this$static._blockSize - this$static._streamPos;
      if (!size)
        return;
      numReadBytes = $read_0(this$static._stream, this$static._bufferBase, this$static._bufferOffset + this$static._streamPos, size);
      if (numReadBytes == -1) {
        this$static._posLimit = this$static._streamPos;
        pointerToPostion = this$static._bufferOffset + this$static._posLimit;
        if (pointerToPostion > this$static._pointerToLastSafePosition) {
          this$static._posLimit = this$static._pointerToLastSafePosition - this$static._bufferOffset;
        }
        this$static._streamEndWasReached = 1;
        return;
      }
      this$static._streamPos += numReadBytes;
      if (this$static._streamPos >= this$static._pos + this$static._keepSizeAfter) {
        this$static._posLimit = this$static._streamPos - this$static._keepSizeAfter;
      }
    }
  }
  function $ReduceOffsets(this$static, subValue) {
    this$static._bufferOffset += subValue;
    this$static._posLimit -= subValue;
    this$static._pos -= subValue;
    this$static._streamPos -= subValue;
  }
  var CrcTable = function() {
    var i, j, r, CrcTable2 = [];
    for (i = 0; i < 256; ++i) {
      r = i;
      for (j = 0; j < 8; ++j)
        if ((r & 1) != 0) {
          r = r >>> 1 ^ -306674912;
        } else {
          r >>>= 1;
        }
      CrcTable2[i] = r;
    }
    return CrcTable2;
  }();
  function $Create_3(this$static, historySize, keepAddBufferBefore, matchMaxLen, keepAddBufferAfter) {
    var cyclicBufferSize, hs, windowReservSize;
    if (historySize < 1073741567) {
      this$static._cutValue = 16 + (matchMaxLen >> 1);
      windowReservSize = ~~((historySize + keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2) + 256;
      $Create_4(this$static, historySize + keepAddBufferBefore, matchMaxLen + keepAddBufferAfter, windowReservSize);
      this$static._matchMaxLen = matchMaxLen;
      cyclicBufferSize = historySize + 1;
      if (this$static._cyclicBufferSize != cyclicBufferSize) {
        this$static._son = initDim((this$static._cyclicBufferSize = cyclicBufferSize) * 2);
      }
      hs = 65536;
      if (this$static.HASH_ARRAY) {
        hs = historySize - 1;
        hs |= hs >> 1;
        hs |= hs >> 2;
        hs |= hs >> 4;
        hs |= hs >> 8;
        hs >>= 1;
        hs |= 65535;
        if (hs > 16777216)
          hs >>= 1;
        this$static._hashMask = hs;
        ++hs;
        hs += this$static.kFixHashSize;
      }
      if (hs != this$static._hashSizeSum) {
        this$static._hash = initDim(this$static._hashSizeSum = hs);
      }
    }
  }
  function $GetMatches(this$static, distances) {
    var count, cur, curMatch, curMatch2, curMatch3, cyclicPos, delta, hash2Value, hash3Value, hashValue, len, len0, len1, lenLimit, matchMinPos, maxLen, offset, pby1, ptr0, ptr1, temp2;
    if (this$static._pos + this$static._matchMaxLen <= this$static._streamPos) {
      lenLimit = this$static._matchMaxLen;
    } else {
      lenLimit = this$static._streamPos - this$static._pos;
      if (lenLimit < this$static.kMinMatchCheck) {
        $MovePos_0(this$static);
        return 0;
      }
    }
    offset = 0;
    matchMinPos = this$static._pos > this$static._cyclicBufferSize ? this$static._pos - this$static._cyclicBufferSize : 0;
    cur = this$static._bufferOffset + this$static._pos;
    maxLen = 1;
    hash2Value = 0;
    hash3Value = 0;
    if (this$static.HASH_ARRAY) {
      temp2 = CrcTable[this$static._bufferBase[cur] & 255] ^ this$static._bufferBase[cur + 1] & 255;
      hash2Value = temp2 & 1023;
      temp2 ^= (this$static._bufferBase[cur + 2] & 255) << 8;
      hash3Value = temp2 & 65535;
      hashValue = (temp2 ^ CrcTable[this$static._bufferBase[cur + 3] & 255] << 5) & this$static._hashMask;
    } else {
      hashValue = this$static._bufferBase[cur] & 255 ^ (this$static._bufferBase[cur + 1] & 255) << 8;
    }
    curMatch = this$static._hash[this$static.kFixHashSize + hashValue] || 0;
    if (this$static.HASH_ARRAY) {
      curMatch2 = this$static._hash[hash2Value] || 0;
      curMatch3 = this$static._hash[1024 + hash3Value] || 0;
      this$static._hash[hash2Value] = this$static._pos;
      this$static._hash[1024 + hash3Value] = this$static._pos;
      if (curMatch2 > matchMinPos) {
        if (this$static._bufferBase[this$static._bufferOffset + curMatch2] == this$static._bufferBase[cur]) {
          distances[offset++] = maxLen = 2;
          distances[offset++] = this$static._pos - curMatch2 - 1;
        }
      }
      if (curMatch3 > matchMinPos) {
        if (this$static._bufferBase[this$static._bufferOffset + curMatch3] == this$static._bufferBase[cur]) {
          if (curMatch3 == curMatch2) {
            offset -= 2;
          }
          distances[offset++] = maxLen = 3;
          distances[offset++] = this$static._pos - curMatch3 - 1;
          curMatch2 = curMatch3;
        }
      }
      if (offset != 0 && curMatch2 == curMatch) {
        offset -= 2;
        maxLen = 1;
      }
    }
    this$static._hash[this$static.kFixHashSize + hashValue] = this$static._pos;
    ptr0 = (this$static._cyclicBufferPos << 1) + 1;
    ptr1 = this$static._cyclicBufferPos << 1;
    len0 = len1 = this$static.kNumHashDirectBytes;
    if (this$static.kNumHashDirectBytes != 0) {
      if (curMatch > matchMinPos) {
        if (this$static._bufferBase[this$static._bufferOffset + curMatch + this$static.kNumHashDirectBytes] != this$static._bufferBase[cur + this$static.kNumHashDirectBytes]) {
          distances[offset++] = maxLen = this$static.kNumHashDirectBytes;
          distances[offset++] = this$static._pos - curMatch - 1;
        }
      }
    }
    count = this$static._cutValue;
    while (1) {
      if (curMatch <= matchMinPos || count-- == 0) {
        this$static._son[ptr0] = this$static._son[ptr1] = 0;
        break;
      }
      delta = this$static._pos - curMatch;
      cyclicPos = (delta <= this$static._cyclicBufferPos ? this$static._cyclicBufferPos - delta : this$static._cyclicBufferPos - delta + this$static._cyclicBufferSize) << 1;
      pby1 = this$static._bufferOffset + curMatch;
      len = len0 < len1 ? len0 : len1;
      if (this$static._bufferBase[pby1 + len] == this$static._bufferBase[cur + len]) {
        while (++len != lenLimit) {
          if (this$static._bufferBase[pby1 + len] != this$static._bufferBase[cur + len]) {
            break;
          }
        }
        if (maxLen < len) {
          distances[offset++] = maxLen = len;
          distances[offset++] = delta - 1;
          if (len == lenLimit) {
            this$static._son[ptr1] = this$static._son[cyclicPos];
            this$static._son[ptr0] = this$static._son[cyclicPos + 1];
            break;
          }
        }
      }
      if ((this$static._bufferBase[pby1 + len] & 255) < (this$static._bufferBase[cur + len] & 255)) {
        this$static._son[ptr1] = curMatch;
        ptr1 = cyclicPos + 1;
        curMatch = this$static._son[ptr1];
        len1 = len;
      } else {
        this$static._son[ptr0] = curMatch;
        ptr0 = cyclicPos;
        curMatch = this$static._son[ptr0];
        len0 = len;
      }
    }
    $MovePos_0(this$static);
    return offset;
  }
  function $Init_5(this$static) {
    this$static._bufferOffset = 0;
    this$static._pos = 0;
    this$static._streamPos = 0;
    this$static._streamEndWasReached = 0;
    $ReadBlock(this$static);
    this$static._cyclicBufferPos = 0;
    $ReduceOffsets(this$static, -1);
  }
  function $MovePos_0(this$static) {
    var subValue;
    if (++this$static._cyclicBufferPos >= this$static._cyclicBufferSize) {
      this$static._cyclicBufferPos = 0;
    }
    $MovePos_1(this$static);
    if (this$static._pos == 1073741823) {
      subValue = this$static._pos - this$static._cyclicBufferSize;
      $NormalizeLinks(this$static._son, this$static._cyclicBufferSize * 2, subValue);
      $NormalizeLinks(this$static._hash, this$static._hashSizeSum, subValue);
      $ReduceOffsets(this$static, subValue);
    }
  }
  function $NormalizeLinks(items, numItems, subValue) {
    var i, value;
    for (i = 0; i < numItems; ++i) {
      value = items[i] || 0;
      if (value <= subValue) {
        value = 0;
      } else {
        value -= subValue;
      }
      items[i] = value;
    }
  }
  function $SetType(this$static, numHashBytes) {
    this$static.HASH_ARRAY = numHashBytes > 2;
    if (this$static.HASH_ARRAY) {
      this$static.kNumHashDirectBytes = 0;
      this$static.kMinMatchCheck = 4;
      this$static.kFixHashSize = 66560;
    } else {
      this$static.kNumHashDirectBytes = 2;
      this$static.kMinMatchCheck = 3;
      this$static.kFixHashSize = 0;
    }
  }
  function $Skip(this$static, num) {
    var count, cur, curMatch, cyclicPos, delta, hash2Value, hash3Value, hashValue, len, len0, len1, lenLimit, matchMinPos, pby1, ptr0, ptr1, temp2;
    do {
      if (this$static._pos + this$static._matchMaxLen <= this$static._streamPos) {
        lenLimit = this$static._matchMaxLen;
      } else {
        lenLimit = this$static._streamPos - this$static._pos;
        if (lenLimit < this$static.kMinMatchCheck) {
          $MovePos_0(this$static);
          continue;
        }
      }
      matchMinPos = this$static._pos > this$static._cyclicBufferSize ? this$static._pos - this$static._cyclicBufferSize : 0;
      cur = this$static._bufferOffset + this$static._pos;
      if (this$static.HASH_ARRAY) {
        temp2 = CrcTable[this$static._bufferBase[cur] & 255] ^ this$static._bufferBase[cur + 1] & 255;
        hash2Value = temp2 & 1023;
        this$static._hash[hash2Value] = this$static._pos;
        temp2 ^= (this$static._bufferBase[cur + 2] & 255) << 8;
        hash3Value = temp2 & 65535;
        this$static._hash[1024 + hash3Value] = this$static._pos;
        hashValue = (temp2 ^ CrcTable[this$static._bufferBase[cur + 3] & 255] << 5) & this$static._hashMask;
      } else {
        hashValue = this$static._bufferBase[cur] & 255 ^ (this$static._bufferBase[cur + 1] & 255) << 8;
      }
      curMatch = this$static._hash[this$static.kFixHashSize + hashValue];
      this$static._hash[this$static.kFixHashSize + hashValue] = this$static._pos;
      ptr0 = (this$static._cyclicBufferPos << 1) + 1;
      ptr1 = this$static._cyclicBufferPos << 1;
      len0 = len1 = this$static.kNumHashDirectBytes;
      count = this$static._cutValue;
      while (1) {
        if (curMatch <= matchMinPos || count-- == 0) {
          this$static._son[ptr0] = this$static._son[ptr1] = 0;
          break;
        }
        delta = this$static._pos - curMatch;
        cyclicPos = (delta <= this$static._cyclicBufferPos ? this$static._cyclicBufferPos - delta : this$static._cyclicBufferPos - delta + this$static._cyclicBufferSize) << 1;
        pby1 = this$static._bufferOffset + curMatch;
        len = len0 < len1 ? len0 : len1;
        if (this$static._bufferBase[pby1 + len] == this$static._bufferBase[cur + len]) {
          while (++len != lenLimit) {
            if (this$static._bufferBase[pby1 + len] != this$static._bufferBase[cur + len]) {
              break;
            }
          }
          if (len == lenLimit) {
            this$static._son[ptr1] = this$static._son[cyclicPos];
            this$static._son[ptr0] = this$static._son[cyclicPos + 1];
            break;
          }
        }
        if ((this$static._bufferBase[pby1 + len] & 255) < (this$static._bufferBase[cur + len] & 255)) {
          this$static._son[ptr1] = curMatch;
          ptr1 = cyclicPos + 1;
          curMatch = this$static._son[ptr1];
          len1 = len;
        } else {
          this$static._son[ptr0] = curMatch;
          ptr0 = cyclicPos;
          curMatch = this$static._son[ptr0];
          len0 = len;
        }
      }
      $MovePos_0(this$static);
    } while (--num != 0);
  }
  function $CopyBlock(this$static, distance, len) {
    var pos = this$static._pos - distance - 1;
    if (pos < 0) {
      pos += this$static._windowSize;
    }
    for (; len != 0; --len) {
      if (pos >= this$static._windowSize) {
        pos = 0;
      }
      this$static._buffer[this$static._pos++] = this$static._buffer[pos++];
      if (this$static._pos >= this$static._windowSize) {
        $Flush_0(this$static);
      }
    }
  }
  function $Create_5(this$static, windowSize) {
    if (this$static._buffer == null || this$static._windowSize != windowSize) {
      this$static._buffer = initDim(windowSize);
    }
    this$static._windowSize = windowSize;
    this$static._pos = 0;
    this$static._streamPos = 0;
  }
  function $Flush_0(this$static) {
    var size = this$static._pos - this$static._streamPos;
    if (!size) {
      return;
    }
    $write_0(this$static._stream, this$static._buffer, this$static._streamPos, size);
    if (this$static._pos >= this$static._windowSize) {
      this$static._pos = 0;
    }
    this$static._streamPos = this$static._pos;
  }
  function $GetByte(this$static, distance) {
    var pos = this$static._pos - distance - 1;
    if (pos < 0) {
      pos += this$static._windowSize;
    }
    return this$static._buffer[pos];
  }
  function $PutByte(this$static, b) {
    this$static._buffer[this$static._pos++] = b;
    if (this$static._pos >= this$static._windowSize) {
      $Flush_0(this$static);
    }
  }
  function $ReleaseStream(this$static) {
    $Flush_0(this$static);
    this$static._stream = null;
  }
  function GetLenToPosState(len) {
    len -= 2;
    if (len < 4) {
      return len;
    }
    return 3;
  }
  function StateUpdateChar(index2) {
    if (index2 < 4) {
      return 0;
    }
    if (index2 < 10) {
      return index2 - 3;
    }
    return index2 - 6;
  }
  function $Chunker_0(this$static, encoder) {
    this$static.encoder = encoder;
    this$static.decoder = null;
    this$static.alive = 1;
    return this$static;
  }
  function $Chunker(this$static, decoder) {
    this$static.decoder = decoder;
    this$static.encoder = null;
    this$static.alive = 1;
    return this$static;
  }
  function $processChunk(this$static) {
    if (!this$static.alive) {
      throw new Error("bad state");
    }
    if (this$static.encoder) {
      $processEncoderChunk(this$static);
    } else {
      $processDecoderChunk(this$static);
    }
    return this$static.alive;
  }
  function $processDecoderChunk(this$static) {
    var result = $CodeOneChunk(this$static.decoder);
    if (result == -1) {
      throw new Error("corrupted input");
    }
    this$static.inBytesProcessed = N1_longLit;
    this$static.outBytesProcessed = this$static.decoder.nowPos64;
    if (result || compare(this$static.decoder.outSize, P0_longLit) >= 0 && compare(this$static.decoder.nowPos64, this$static.decoder.outSize) >= 0) {
      $Flush_0(this$static.decoder.m_OutWindow);
      $ReleaseStream(this$static.decoder.m_OutWindow);
      this$static.decoder.m_RangeDecoder.Stream = null;
      this$static.alive = 0;
    }
  }
  function $processEncoderChunk(this$static) {
    $CodeOneBlock(this$static.encoder, this$static.encoder.processedInSize, this$static.encoder.processedOutSize, this$static.encoder.finished);
    this$static.inBytesProcessed = this$static.encoder.processedInSize[0];
    if (this$static.encoder.finished[0]) {
      $ReleaseStreams(this$static.encoder);
      this$static.alive = 0;
    }
  }
  function $CodeInChunks(this$static, inStream, outStream, outSize) {
    this$static.m_RangeDecoder.Stream = inStream;
    $ReleaseStream(this$static.m_OutWindow);
    this$static.m_OutWindow._stream = outStream;
    $Init_1(this$static);
    this$static.state = 0;
    this$static.rep0 = 0;
    this$static.rep1 = 0;
    this$static.rep2 = 0;
    this$static.rep3 = 0;
    this$static.outSize = outSize;
    this$static.nowPos64 = P0_longLit;
    this$static.prevByte = 0;
    return $Chunker({}, this$static);
  }
  function $CodeOneChunk(this$static) {
    var decoder2, distance, len, numDirectBits, posSlot, posState;
    posState = lowBits_0(this$static.nowPos64) & this$static.m_PosStateMask;
    if (!$DecodeBit(this$static.m_RangeDecoder, this$static.m_IsMatchDecoders, (this$static.state << 4) + posState)) {
      decoder2 = $GetDecoder(this$static.m_LiteralDecoder, lowBits_0(this$static.nowPos64), this$static.prevByte);
      if (this$static.state < 7) {
        this$static.prevByte = $DecodeNormal(decoder2, this$static.m_RangeDecoder);
      } else {
        this$static.prevByte = $DecodeWithMatchByte(decoder2, this$static.m_RangeDecoder, $GetByte(this$static.m_OutWindow, this$static.rep0));
      }
      $PutByte(this$static.m_OutWindow, this$static.prevByte);
      this$static.state = StateUpdateChar(this$static.state);
      this$static.nowPos64 = add2(this$static.nowPos64, P1_longLit);
    } else {
      if ($DecodeBit(this$static.m_RangeDecoder, this$static.m_IsRepDecoders, this$static.state)) {
        len = 0;
        if (!$DecodeBit(this$static.m_RangeDecoder, this$static.m_IsRepG0Decoders, this$static.state)) {
          if (!$DecodeBit(this$static.m_RangeDecoder, this$static.m_IsRep0LongDecoders, (this$static.state << 4) + posState)) {
            this$static.state = this$static.state < 7 ? 9 : 11;
            len = 1;
          }
        } else {
          if (!$DecodeBit(this$static.m_RangeDecoder, this$static.m_IsRepG1Decoders, this$static.state)) {
            distance = this$static.rep1;
          } else {
            if (!$DecodeBit(this$static.m_RangeDecoder, this$static.m_IsRepG2Decoders, this$static.state)) {
              distance = this$static.rep2;
            } else {
              distance = this$static.rep3;
              this$static.rep3 = this$static.rep2;
            }
            this$static.rep2 = this$static.rep1;
          }
          this$static.rep1 = this$static.rep0;
          this$static.rep0 = distance;
        }
        if (!len) {
          len = $Decode(this$static.m_RepLenDecoder, this$static.m_RangeDecoder, posState) + 2;
          this$static.state = this$static.state < 7 ? 8 : 11;
        }
      } else {
        this$static.rep3 = this$static.rep2;
        this$static.rep2 = this$static.rep1;
        this$static.rep1 = this$static.rep0;
        len = 2 + $Decode(this$static.m_LenDecoder, this$static.m_RangeDecoder, posState);
        this$static.state = this$static.state < 7 ? 7 : 10;
        posSlot = $Decode_0(this$static.m_PosSlotDecoder[GetLenToPosState(len)], this$static.m_RangeDecoder);
        if (posSlot >= 4) {
          numDirectBits = (posSlot >> 1) - 1;
          this$static.rep0 = (2 | posSlot & 1) << numDirectBits;
          if (posSlot < 14) {
            this$static.rep0 += ReverseDecode(this$static.m_PosDecoders, this$static.rep0 - posSlot - 1, this$static.m_RangeDecoder, numDirectBits);
          } else {
            this$static.rep0 += $DecodeDirectBits(this$static.m_RangeDecoder, numDirectBits - 4) << 4;
            this$static.rep0 += $ReverseDecode(this$static.m_PosAlignDecoder, this$static.m_RangeDecoder);
            if (this$static.rep0 < 0) {
              if (this$static.rep0 == -1) {
                return 1;
              }
              return -1;
            }
          }
        } else
          this$static.rep0 = posSlot;
      }
      if (compare(fromInt(this$static.rep0), this$static.nowPos64) >= 0 || this$static.rep0 >= this$static.m_DictionarySizeCheck) {
        return -1;
      }
      $CopyBlock(this$static.m_OutWindow, this$static.rep0, len);
      this$static.nowPos64 = add2(this$static.nowPos64, fromInt(len));
      this$static.prevByte = $GetByte(this$static.m_OutWindow, 0);
    }
    return 0;
  }
  function $Decoder(this$static) {
    this$static.m_OutWindow = {};
    this$static.m_RangeDecoder = {};
    this$static.m_IsMatchDecoders = initDim(192);
    this$static.m_IsRepDecoders = initDim(12);
    this$static.m_IsRepG0Decoders = initDim(12);
    this$static.m_IsRepG1Decoders = initDim(12);
    this$static.m_IsRepG2Decoders = initDim(12);
    this$static.m_IsRep0LongDecoders = initDim(192);
    this$static.m_PosSlotDecoder = initDim(4);
    this$static.m_PosDecoders = initDim(114);
    this$static.m_PosAlignDecoder = $BitTreeDecoder({}, 4);
    this$static.m_LenDecoder = $Decoder$LenDecoder({});
    this$static.m_RepLenDecoder = $Decoder$LenDecoder({});
    this$static.m_LiteralDecoder = {};
    for (var i = 0; i < 4; ++i) {
      this$static.m_PosSlotDecoder[i] = $BitTreeDecoder({}, 6);
    }
    return this$static;
  }
  function $Init_1(this$static) {
    this$static.m_OutWindow._streamPos = 0;
    this$static.m_OutWindow._pos = 0;
    InitBitModels(this$static.m_IsMatchDecoders);
    InitBitModels(this$static.m_IsRep0LongDecoders);
    InitBitModels(this$static.m_IsRepDecoders);
    InitBitModels(this$static.m_IsRepG0Decoders);
    InitBitModels(this$static.m_IsRepG1Decoders);
    InitBitModels(this$static.m_IsRepG2Decoders);
    InitBitModels(this$static.m_PosDecoders);
    $Init_0(this$static.m_LiteralDecoder);
    for (var i = 0; i < 4; ++i) {
      InitBitModels(this$static.m_PosSlotDecoder[i].Models);
    }
    $Init(this$static.m_LenDecoder);
    $Init(this$static.m_RepLenDecoder);
    InitBitModels(this$static.m_PosAlignDecoder.Models);
    $Init_8(this$static.m_RangeDecoder);
  }
  function $SetDecoderProperties(this$static, properties) {
    var dictionarySize, i, lc, lp, pb, remainder, val;
    if (properties.length < 5)
      return 0;
    val = properties[0] & 255;
    lc = val % 9;
    remainder = ~~(val / 9);
    lp = remainder % 5;
    pb = ~~(remainder / 5);
    dictionarySize = 0;
    for (i = 0; i < 4; ++i) {
      dictionarySize += (properties[1 + i] & 255) << i * 8;
    }
    if (dictionarySize > 99999999 || !$SetLcLpPb(this$static, lc, lp, pb)) {
      return 0;
    }
    return $SetDictionarySize(this$static, dictionarySize);
  }
  function $SetDictionarySize(this$static, dictionarySize) {
    if (dictionarySize < 0) {
      return 0;
    }
    if (this$static.m_DictionarySize != dictionarySize) {
      this$static.m_DictionarySize = dictionarySize;
      this$static.m_DictionarySizeCheck = Math.max(this$static.m_DictionarySize, 1);
      $Create_5(this$static.m_OutWindow, Math.max(this$static.m_DictionarySizeCheck, 4096));
    }
    return 1;
  }
  function $SetLcLpPb(this$static, lc, lp, pb) {
    if (lc > 8 || lp > 4 || pb > 4) {
      return 0;
    }
    $Create_0(this$static.m_LiteralDecoder, lp, lc);
    var numPosStates = 1 << pb;
    $Create(this$static.m_LenDecoder, numPosStates);
    $Create(this$static.m_RepLenDecoder, numPosStates);
    this$static.m_PosStateMask = numPosStates - 1;
    return 1;
  }
  function $Create(this$static, numPosStates) {
    for (; this$static.m_NumPosStates < numPosStates; ++this$static.m_NumPosStates) {
      this$static.m_LowCoder[this$static.m_NumPosStates] = $BitTreeDecoder({}, 3);
      this$static.m_MidCoder[this$static.m_NumPosStates] = $BitTreeDecoder({}, 3);
    }
  }
  function $Decode(this$static, rangeDecoder, posState) {
    if (!$DecodeBit(rangeDecoder, this$static.m_Choice, 0)) {
      return $Decode_0(this$static.m_LowCoder[posState], rangeDecoder);
    }
    var symbol = 8;
    if (!$DecodeBit(rangeDecoder, this$static.m_Choice, 1)) {
      symbol += $Decode_0(this$static.m_MidCoder[posState], rangeDecoder);
    } else {
      symbol += 8 + $Decode_0(this$static.m_HighCoder, rangeDecoder);
    }
    return symbol;
  }
  function $Decoder$LenDecoder(this$static) {
    this$static.m_Choice = initDim(2);
    this$static.m_LowCoder = initDim(16);
    this$static.m_MidCoder = initDim(16);
    this$static.m_HighCoder = $BitTreeDecoder({}, 8);
    this$static.m_NumPosStates = 0;
    return this$static;
  }
  function $Init(this$static) {
    InitBitModels(this$static.m_Choice);
    for (var posState = 0; posState < this$static.m_NumPosStates; ++posState) {
      InitBitModels(this$static.m_LowCoder[posState].Models);
      InitBitModels(this$static.m_MidCoder[posState].Models);
    }
    InitBitModels(this$static.m_HighCoder.Models);
  }
  function $Create_0(this$static, numPosBits, numPrevBits) {
    var i, numStates;
    if (this$static.m_Coders != null && this$static.m_NumPrevBits == numPrevBits && this$static.m_NumPosBits == numPosBits)
      return;
    this$static.m_NumPosBits = numPosBits;
    this$static.m_PosMask = (1 << numPosBits) - 1;
    this$static.m_NumPrevBits = numPrevBits;
    numStates = 1 << this$static.m_NumPrevBits + this$static.m_NumPosBits;
    this$static.m_Coders = initDim(numStates);
    for (i = 0; i < numStates; ++i)
      this$static.m_Coders[i] = $Decoder$LiteralDecoder$Decoder2({});
  }
  function $GetDecoder(this$static, pos, prevByte) {
    return this$static.m_Coders[((pos & this$static.m_PosMask) << this$static.m_NumPrevBits) + ((prevByte & 255) >>> 8 - this$static.m_NumPrevBits)];
  }
  function $Init_0(this$static) {
    var i, numStates;
    numStates = 1 << this$static.m_NumPrevBits + this$static.m_NumPosBits;
    for (i = 0; i < numStates; ++i) {
      InitBitModels(this$static.m_Coders[i].m_Decoders);
    }
  }
  function $DecodeNormal(this$static, rangeDecoder) {
    var symbol = 1;
    do {
      symbol = symbol << 1 | $DecodeBit(rangeDecoder, this$static.m_Decoders, symbol);
    } while (symbol < 256);
    return symbol << 24 >> 24;
  }
  function $DecodeWithMatchByte(this$static, rangeDecoder, matchByte) {
    var bit, matchBit, symbol = 1;
    do {
      matchBit = matchByte >> 7 & 1;
      matchByte <<= 1;
      bit = $DecodeBit(rangeDecoder, this$static.m_Decoders, (1 + matchBit << 8) + symbol);
      symbol = symbol << 1 | bit;
      if (matchBit != bit) {
        while (symbol < 256) {
          symbol = symbol << 1 | $DecodeBit(rangeDecoder, this$static.m_Decoders, symbol);
        }
        break;
      }
    } while (symbol < 256);
    return symbol << 24 >> 24;
  }
  function $Decoder$LiteralDecoder$Decoder2(this$static) {
    this$static.m_Decoders = initDim(768);
    return this$static;
  }
  var g_FastPos = function() {
    var j, k, slotFast, c = 2, g_FastPos2 = [0, 1];
    for (slotFast = 2; slotFast < 22; ++slotFast) {
      k = 1 << (slotFast >> 1) - 1;
      for (j = 0; j < k; ++j, ++c)
        g_FastPos2[c] = slotFast << 24 >> 24;
    }
    return g_FastPos2;
  }();
  function $Backward(this$static, cur) {
    var backCur, backMem, posMem, posPrev;
    this$static._optimumEndIndex = cur;
    posMem = this$static._optimum[cur].PosPrev;
    backMem = this$static._optimum[cur].BackPrev;
    do {
      if (this$static._optimum[cur].Prev1IsChar) {
        $MakeAsChar(this$static._optimum[posMem]);
        this$static._optimum[posMem].PosPrev = posMem - 1;
        if (this$static._optimum[cur].Prev2) {
          this$static._optimum[posMem - 1].Prev1IsChar = 0;
          this$static._optimum[posMem - 1].PosPrev = this$static._optimum[cur].PosPrev2;
          this$static._optimum[posMem - 1].BackPrev = this$static._optimum[cur].BackPrev2;
        }
      }
      posPrev = posMem;
      backCur = backMem;
      backMem = this$static._optimum[posPrev].BackPrev;
      posMem = this$static._optimum[posPrev].PosPrev;
      this$static._optimum[posPrev].BackPrev = backCur;
      this$static._optimum[posPrev].PosPrev = cur;
      cur = posPrev;
    } while (cur > 0);
    this$static.backRes = this$static._optimum[0].BackPrev;
    this$static._optimumCurrentIndex = this$static._optimum[0].PosPrev;
    return this$static._optimumCurrentIndex;
  }
  function $BaseInit(this$static) {
    this$static._state = 0;
    this$static._previousByte = 0;
    for (var i = 0; i < 4; ++i) {
      this$static._repDistances[i] = 0;
    }
  }
  function $CodeOneBlock(this$static, inSize, outSize, finished) {
    var baseVal, complexState, curByte, distance, footerBits, i, len, lenToPosState, matchByte, pos, posReduced, posSlot, posState, progressPosValuePrev, subCoder;
    inSize[0] = P0_longLit;
    outSize[0] = P0_longLit;
    finished[0] = 1;
    if (this$static._inStream) {
      this$static._matchFinder._stream = this$static._inStream;
      $Init_5(this$static._matchFinder);
      this$static._needReleaseMFStream = 1;
      this$static._inStream = null;
    }
    if (this$static._finished) {
      return;
    }
    this$static._finished = 1;
    progressPosValuePrev = this$static.nowPos64;
    if (eq(this$static.nowPos64, P0_longLit)) {
      if (!$GetNumAvailableBytes(this$static._matchFinder)) {
        $Flush(this$static, lowBits_0(this$static.nowPos64));
        return;
      }
      $ReadMatchDistances(this$static);
      posState = lowBits_0(this$static.nowPos64) & this$static._posStateMask;
      $Encode_3(this$static._rangeEncoder, this$static._isMatch, (this$static._state << 4) + posState, 0);
      this$static._state = StateUpdateChar(this$static._state);
      curByte = $GetIndexByte(this$static._matchFinder, -this$static._additionalOffset);
      $Encode_1($GetSubCoder(this$static._literalEncoder, lowBits_0(this$static.nowPos64), this$static._previousByte), this$static._rangeEncoder, curByte);
      this$static._previousByte = curByte;
      --this$static._additionalOffset;
      this$static.nowPos64 = add2(this$static.nowPos64, P1_longLit);
    }
    if (!$GetNumAvailableBytes(this$static._matchFinder)) {
      $Flush(this$static, lowBits_0(this$static.nowPos64));
      return;
    }
    while (1) {
      len = $GetOptimum(this$static, lowBits_0(this$static.nowPos64));
      pos = this$static.backRes;
      posState = lowBits_0(this$static.nowPos64) & this$static._posStateMask;
      complexState = (this$static._state << 4) + posState;
      if (len == 1 && pos == -1) {
        $Encode_3(this$static._rangeEncoder, this$static._isMatch, complexState, 0);
        curByte = $GetIndexByte(this$static._matchFinder, -this$static._additionalOffset);
        subCoder = $GetSubCoder(this$static._literalEncoder, lowBits_0(this$static.nowPos64), this$static._previousByte);
        if (this$static._state < 7) {
          $Encode_1(subCoder, this$static._rangeEncoder, curByte);
        } else {
          matchByte = $GetIndexByte(this$static._matchFinder, -this$static._repDistances[0] - 1 - this$static._additionalOffset);
          $EncodeMatched(subCoder, this$static._rangeEncoder, matchByte, curByte);
        }
        this$static._previousByte = curByte;
        this$static._state = StateUpdateChar(this$static._state);
      } else {
        $Encode_3(this$static._rangeEncoder, this$static._isMatch, complexState, 1);
        if (pos < 4) {
          $Encode_3(this$static._rangeEncoder, this$static._isRep, this$static._state, 1);
          if (!pos) {
            $Encode_3(this$static._rangeEncoder, this$static._isRepG0, this$static._state, 0);
            if (len == 1) {
              $Encode_3(this$static._rangeEncoder, this$static._isRep0Long, complexState, 0);
            } else {
              $Encode_3(this$static._rangeEncoder, this$static._isRep0Long, complexState, 1);
            }
          } else {
            $Encode_3(this$static._rangeEncoder, this$static._isRepG0, this$static._state, 1);
            if (pos == 1) {
              $Encode_3(this$static._rangeEncoder, this$static._isRepG1, this$static._state, 0);
            } else {
              $Encode_3(this$static._rangeEncoder, this$static._isRepG1, this$static._state, 1);
              $Encode_3(this$static._rangeEncoder, this$static._isRepG2, this$static._state, pos - 2);
            }
          }
          if (len == 1) {
            this$static._state = this$static._state < 7 ? 9 : 11;
          } else {
            $Encode_0(this$static._repMatchLenEncoder, this$static._rangeEncoder, len - 2, posState);
            this$static._state = this$static._state < 7 ? 8 : 11;
          }
          distance = this$static._repDistances[pos];
          if (pos != 0) {
            for (i = pos; i >= 1; --i) {
              this$static._repDistances[i] = this$static._repDistances[i - 1];
            }
            this$static._repDistances[0] = distance;
          }
        } else {
          $Encode_3(this$static._rangeEncoder, this$static._isRep, this$static._state, 0);
          this$static._state = this$static._state < 7 ? 7 : 10;
          $Encode_0(this$static._lenEncoder, this$static._rangeEncoder, len - 2, posState);
          pos -= 4;
          posSlot = GetPosSlot(pos);
          lenToPosState = GetLenToPosState(len);
          $Encode_2(this$static._posSlotEncoder[lenToPosState], this$static._rangeEncoder, posSlot);
          if (posSlot >= 4) {
            footerBits = (posSlot >> 1) - 1;
            baseVal = (2 | posSlot & 1) << footerBits;
            posReduced = pos - baseVal;
            if (posSlot < 14) {
              ReverseEncode(this$static._posEncoders, baseVal - posSlot - 1, this$static._rangeEncoder, footerBits, posReduced);
            } else {
              $EncodeDirectBits(this$static._rangeEncoder, posReduced >> 4, footerBits - 4);
              $ReverseEncode(this$static._posAlignEncoder, this$static._rangeEncoder, posReduced & 15);
              ++this$static._alignPriceCount;
            }
          }
          distance = pos;
          for (i = 3; i >= 1; --i) {
            this$static._repDistances[i] = this$static._repDistances[i - 1];
          }
          this$static._repDistances[0] = distance;
          ++this$static._matchPriceCount;
        }
        this$static._previousByte = $GetIndexByte(this$static._matchFinder, len - 1 - this$static._additionalOffset);
      }
      this$static._additionalOffset -= len;
      this$static.nowPos64 = add2(this$static.nowPos64, fromInt(len));
      if (!this$static._additionalOffset) {
        if (this$static._matchPriceCount >= 128) {
          $FillDistancesPrices(this$static);
        }
        if (this$static._alignPriceCount >= 16) {
          $FillAlignPrices(this$static);
        }
        inSize[0] = this$static.nowPos64;
        outSize[0] = $GetProcessedSizeAdd(this$static._rangeEncoder);
        if (!$GetNumAvailableBytes(this$static._matchFinder)) {
          $Flush(this$static, lowBits_0(this$static.nowPos64));
          return;
        }
        if (compare(sub(this$static.nowPos64, progressPosValuePrev), [4096, 0]) >= 0) {
          this$static._finished = 0;
          finished[0] = 0;
          return;
        }
      }
    }
  }
  function $Create_2(this$static) {
    var bt, numHashBytes;
    if (!this$static._matchFinder) {
      bt = {};
      numHashBytes = 4;
      if (!this$static._matchFinderType) {
        numHashBytes = 2;
      }
      $SetType(bt, numHashBytes);
      this$static._matchFinder = bt;
    }
    $Create_1(this$static._literalEncoder, this$static._numLiteralPosStateBits, this$static._numLiteralContextBits);
    if (this$static._dictionarySize == this$static._dictionarySizePrev && this$static._numFastBytesPrev == this$static._numFastBytes) {
      return;
    }
    $Create_3(this$static._matchFinder, this$static._dictionarySize, 4096, this$static._numFastBytes, 274);
    this$static._dictionarySizePrev = this$static._dictionarySize;
    this$static._numFastBytesPrev = this$static._numFastBytes;
  }
  function $Encoder(this$static) {
    var i;
    this$static._repDistances = initDim(4);
    this$static._optimum = [];
    this$static._rangeEncoder = {};
    this$static._isMatch = initDim(192);
    this$static._isRep = initDim(12);
    this$static._isRepG0 = initDim(12);
    this$static._isRepG1 = initDim(12);
    this$static._isRepG2 = initDim(12);
    this$static._isRep0Long = initDim(192);
    this$static._posSlotEncoder = [];
    this$static._posEncoders = initDim(114);
    this$static._posAlignEncoder = $BitTreeEncoder({}, 4);
    this$static._lenEncoder = $Encoder$LenPriceTableEncoder({});
    this$static._repMatchLenEncoder = $Encoder$LenPriceTableEncoder({});
    this$static._literalEncoder = {};
    this$static._matchDistances = [];
    this$static._posSlotPrices = [];
    this$static._distancesPrices = [];
    this$static._alignPrices = initDim(16);
    this$static.reps = initDim(4);
    this$static.repLens = initDim(4);
    this$static.processedInSize = [P0_longLit];
    this$static.processedOutSize = [P0_longLit];
    this$static.finished = [0];
    this$static.properties = initDim(5);
    this$static.tempPrices = initDim(128);
    this$static._longestMatchLength = 0;
    this$static._matchFinderType = 1;
    this$static._numDistancePairs = 0;
    this$static._numFastBytesPrev = -1;
    this$static.backRes = 0;
    for (i = 0; i < 4096; ++i) {
      this$static._optimum[i] = {};
    }
    for (i = 0; i < 4; ++i) {
      this$static._posSlotEncoder[i] = $BitTreeEncoder({}, 6);
    }
    return this$static;
  }
  function $FillAlignPrices(this$static) {
    for (var i = 0; i < 16; ++i) {
      this$static._alignPrices[i] = $ReverseGetPrice(this$static._posAlignEncoder, i);
    }
    this$static._alignPriceCount = 0;
  }
  function $FillDistancesPrices(this$static) {
    var baseVal, encoder, footerBits, i, lenToPosState, posSlot, st, st2;
    for (i = 4; i < 128; ++i) {
      posSlot = GetPosSlot(i);
      footerBits = (posSlot >> 1) - 1;
      baseVal = (2 | posSlot & 1) << footerBits;
      this$static.tempPrices[i] = ReverseGetPrice(this$static._posEncoders, baseVal - posSlot - 1, footerBits, i - baseVal);
    }
    for (lenToPosState = 0; lenToPosState < 4; ++lenToPosState) {
      encoder = this$static._posSlotEncoder[lenToPosState];
      st = lenToPosState << 6;
      for (posSlot = 0; posSlot < this$static._distTableSize; ++posSlot) {
        this$static._posSlotPrices[st + posSlot] = $GetPrice_1(encoder, posSlot);
      }
      for (posSlot = 14; posSlot < this$static._distTableSize; ++posSlot) {
        this$static._posSlotPrices[st + posSlot] += (posSlot >> 1) - 1 - 4 << 6;
      }
      st2 = lenToPosState * 128;
      for (i = 0; i < 4; ++i) {
        this$static._distancesPrices[st2 + i] = this$static._posSlotPrices[st + i];
      }
      for (; i < 128; ++i) {
        this$static._distancesPrices[st2 + i] = this$static._posSlotPrices[st + GetPosSlot(i)] + this$static.tempPrices[i];
      }
    }
    this$static._matchPriceCount = 0;
  }
  function $Flush(this$static, nowPos) {
    $ReleaseMFStream(this$static);
    $WriteEndMarker(this$static, nowPos & this$static._posStateMask);
    for (var i = 0; i < 5; ++i) {
      $ShiftLow(this$static._rangeEncoder);
    }
  }
  function $GetOptimum(this$static, position) {
    var cur, curAnd1Price, curAndLenCharPrice, curAndLenPrice, curBack, curPrice, currentByte, distance, i, len, lenEnd, lenMain, lenRes, lenTest, lenTest2, lenTestTemp, matchByte, matchPrice, newLen, nextIsChar, nextMatchPrice, nextOptimum, nextRepMatchPrice, normalMatchPrice, numAvailableBytes, numAvailableBytesFull, numDistancePairs, offs, offset, opt, optimum, pos, posPrev, posState, posStateNext, price_4, repIndex, repLen, repMatchPrice, repMaxIndex, shortRepPrice, startLen, state, state2, t, price, price_0, price_1, price_2, price_3;
    if (this$static._optimumEndIndex != this$static._optimumCurrentIndex) {
      lenRes = this$static._optimum[this$static._optimumCurrentIndex].PosPrev - this$static._optimumCurrentIndex;
      this$static.backRes = this$static._optimum[this$static._optimumCurrentIndex].BackPrev;
      this$static._optimumCurrentIndex = this$static._optimum[this$static._optimumCurrentIndex].PosPrev;
      return lenRes;
    }
    this$static._optimumCurrentIndex = this$static._optimumEndIndex = 0;
    if (this$static._longestMatchWasFound) {
      lenMain = this$static._longestMatchLength;
      this$static._longestMatchWasFound = 0;
    } else {
      lenMain = $ReadMatchDistances(this$static);
    }
    numDistancePairs = this$static._numDistancePairs;
    numAvailableBytes = $GetNumAvailableBytes(this$static._matchFinder) + 1;
    if (numAvailableBytes < 2) {
      this$static.backRes = -1;
      return 1;
    }
    if (numAvailableBytes > 273) {
      numAvailableBytes = 273;
    }
    repMaxIndex = 0;
    for (i = 0; i < 4; ++i) {
      this$static.reps[i] = this$static._repDistances[i];
      this$static.repLens[i] = $GetMatchLen(this$static._matchFinder, -1, this$static.reps[i], 273);
      if (this$static.repLens[i] > this$static.repLens[repMaxIndex]) {
        repMaxIndex = i;
      }
    }
    if (this$static.repLens[repMaxIndex] >= this$static._numFastBytes) {
      this$static.backRes = repMaxIndex;
      lenRes = this$static.repLens[repMaxIndex];
      $MovePos(this$static, lenRes - 1);
      return lenRes;
    }
    if (lenMain >= this$static._numFastBytes) {
      this$static.backRes = this$static._matchDistances[numDistancePairs - 1] + 4;
      $MovePos(this$static, lenMain - 1);
      return lenMain;
    }
    currentByte = $GetIndexByte(this$static._matchFinder, -1);
    matchByte = $GetIndexByte(this$static._matchFinder, -this$static._repDistances[0] - 1 - 1);
    if (lenMain < 2 && currentByte != matchByte && this$static.repLens[repMaxIndex] < 2) {
      this$static.backRes = -1;
      return 1;
    }
    this$static._optimum[0].State = this$static._state;
    posState = position & this$static._posStateMask;
    this$static._optimum[1].Price = ProbPrices[this$static._isMatch[(this$static._state << 4) + posState] >>> 2] + $GetPrice_0($GetSubCoder(this$static._literalEncoder, position, this$static._previousByte), this$static._state >= 7, matchByte, currentByte);
    $MakeAsChar(this$static._optimum[1]);
    matchPrice = ProbPrices[2048 - this$static._isMatch[(this$static._state << 4) + posState] >>> 2];
    repMatchPrice = matchPrice + ProbPrices[2048 - this$static._isRep[this$static._state] >>> 2];
    if (matchByte == currentByte) {
      shortRepPrice = repMatchPrice + $GetRepLen1Price(this$static, this$static._state, posState);
      if (shortRepPrice < this$static._optimum[1].Price) {
        this$static._optimum[1].Price = shortRepPrice;
        $MakeAsShortRep(this$static._optimum[1]);
      }
    }
    lenEnd = lenMain >= this$static.repLens[repMaxIndex] ? lenMain : this$static.repLens[repMaxIndex];
    if (lenEnd < 2) {
      this$static.backRes = this$static._optimum[1].BackPrev;
      return 1;
    }
    this$static._optimum[1].PosPrev = 0;
    this$static._optimum[0].Backs0 = this$static.reps[0];
    this$static._optimum[0].Backs1 = this$static.reps[1];
    this$static._optimum[0].Backs2 = this$static.reps[2];
    this$static._optimum[0].Backs3 = this$static.reps[3];
    len = lenEnd;
    do {
      this$static._optimum[len--].Price = 268435455;
    } while (len >= 2);
    for (i = 0; i < 4; ++i) {
      repLen = this$static.repLens[i];
      if (repLen < 2) {
        continue;
      }
      price_4 = repMatchPrice + $GetPureRepPrice(this$static, i, this$static._state, posState);
      do {
        curAndLenPrice = price_4 + $GetPrice(this$static._repMatchLenEncoder, repLen - 2, posState);
        optimum = this$static._optimum[repLen];
        if (curAndLenPrice < optimum.Price) {
          optimum.Price = curAndLenPrice;
          optimum.PosPrev = 0;
          optimum.BackPrev = i;
          optimum.Prev1IsChar = 0;
        }
      } while (--repLen >= 2);
    }
    normalMatchPrice = matchPrice + ProbPrices[this$static._isRep[this$static._state] >>> 2];
    len = this$static.repLens[0] >= 2 ? this$static.repLens[0] + 1 : 2;
    if (len <= lenMain) {
      offs = 0;
      while (len > this$static._matchDistances[offs]) {
        offs += 2;
      }
      for (; ; ++len) {
        distance = this$static._matchDistances[offs + 1];
        curAndLenPrice = normalMatchPrice + $GetPosLenPrice(this$static, distance, len, posState);
        optimum = this$static._optimum[len];
        if (curAndLenPrice < optimum.Price) {
          optimum.Price = curAndLenPrice;
          optimum.PosPrev = 0;
          optimum.BackPrev = distance + 4;
          optimum.Prev1IsChar = 0;
        }
        if (len == this$static._matchDistances[offs]) {
          offs += 2;
          if (offs == numDistancePairs) {
            break;
          }
        }
      }
    }
    cur = 0;
    while (1) {
      ++cur;
      if (cur == lenEnd) {
        return $Backward(this$static, cur);
      }
      newLen = $ReadMatchDistances(this$static);
      numDistancePairs = this$static._numDistancePairs;
      if (newLen >= this$static._numFastBytes) {
        this$static._longestMatchLength = newLen;
        this$static._longestMatchWasFound = 1;
        return $Backward(this$static, cur);
      }
      ++position;
      posPrev = this$static._optimum[cur].PosPrev;
      if (this$static._optimum[cur].Prev1IsChar) {
        --posPrev;
        if (this$static._optimum[cur].Prev2) {
          state = this$static._optimum[this$static._optimum[cur].PosPrev2].State;
          if (this$static._optimum[cur].BackPrev2 < 4) {
            state = state < 7 ? 8 : 11;
          } else {
            state = state < 7 ? 7 : 10;
          }
        } else {
          state = this$static._optimum[posPrev].State;
        }
        state = StateUpdateChar(state);
      } else {
        state = this$static._optimum[posPrev].State;
      }
      if (posPrev == cur - 1) {
        if (!this$static._optimum[cur].BackPrev) {
          state = state < 7 ? 9 : 11;
        } else {
          state = StateUpdateChar(state);
        }
      } else {
        if (this$static._optimum[cur].Prev1IsChar && this$static._optimum[cur].Prev2) {
          posPrev = this$static._optimum[cur].PosPrev2;
          pos = this$static._optimum[cur].BackPrev2;
          state = state < 7 ? 8 : 11;
        } else {
          pos = this$static._optimum[cur].BackPrev;
          if (pos < 4) {
            state = state < 7 ? 8 : 11;
          } else {
            state = state < 7 ? 7 : 10;
          }
        }
        opt = this$static._optimum[posPrev];
        if (pos < 4) {
          if (!pos) {
            this$static.reps[0] = opt.Backs0;
            this$static.reps[1] = opt.Backs1;
            this$static.reps[2] = opt.Backs2;
            this$static.reps[3] = opt.Backs3;
          } else if (pos == 1) {
            this$static.reps[0] = opt.Backs1;
            this$static.reps[1] = opt.Backs0;
            this$static.reps[2] = opt.Backs2;
            this$static.reps[3] = opt.Backs3;
          } else if (pos == 2) {
            this$static.reps[0] = opt.Backs2;
            this$static.reps[1] = opt.Backs0;
            this$static.reps[2] = opt.Backs1;
            this$static.reps[3] = opt.Backs3;
          } else {
            this$static.reps[0] = opt.Backs3;
            this$static.reps[1] = opt.Backs0;
            this$static.reps[2] = opt.Backs1;
            this$static.reps[3] = opt.Backs2;
          }
        } else {
          this$static.reps[0] = pos - 4;
          this$static.reps[1] = opt.Backs0;
          this$static.reps[2] = opt.Backs1;
          this$static.reps[3] = opt.Backs2;
        }
      }
      this$static._optimum[cur].State = state;
      this$static._optimum[cur].Backs0 = this$static.reps[0];
      this$static._optimum[cur].Backs1 = this$static.reps[1];
      this$static._optimum[cur].Backs2 = this$static.reps[2];
      this$static._optimum[cur].Backs3 = this$static.reps[3];
      curPrice = this$static._optimum[cur].Price;
      currentByte = $GetIndexByte(this$static._matchFinder, -1);
      matchByte = $GetIndexByte(this$static._matchFinder, -this$static.reps[0] - 1 - 1);
      posState = position & this$static._posStateMask;
      curAnd1Price = curPrice + ProbPrices[this$static._isMatch[(state << 4) + posState] >>> 2] + $GetPrice_0($GetSubCoder(this$static._literalEncoder, position, $GetIndexByte(this$static._matchFinder, -2)), state >= 7, matchByte, currentByte);
      nextOptimum = this$static._optimum[cur + 1];
      nextIsChar = 0;
      if (curAnd1Price < nextOptimum.Price) {
        nextOptimum.Price = curAnd1Price;
        nextOptimum.PosPrev = cur;
        nextOptimum.BackPrev = -1;
        nextOptimum.Prev1IsChar = 0;
        nextIsChar = 1;
      }
      matchPrice = curPrice + ProbPrices[2048 - this$static._isMatch[(state << 4) + posState] >>> 2];
      repMatchPrice = matchPrice + ProbPrices[2048 - this$static._isRep[state] >>> 2];
      if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && !nextOptimum.BackPrev)) {
        shortRepPrice = repMatchPrice + (ProbPrices[this$static._isRepG0[state] >>> 2] + ProbPrices[this$static._isRep0Long[(state << 4) + posState] >>> 2]);
        if (shortRepPrice <= nextOptimum.Price) {
          nextOptimum.Price = shortRepPrice;
          nextOptimum.PosPrev = cur;
          nextOptimum.BackPrev = 0;
          nextOptimum.Prev1IsChar = 0;
          nextIsChar = 1;
        }
      }
      numAvailableBytesFull = $GetNumAvailableBytes(this$static._matchFinder) + 1;
      numAvailableBytesFull = 4095 - cur < numAvailableBytesFull ? 4095 - cur : numAvailableBytesFull;
      numAvailableBytes = numAvailableBytesFull;
      if (numAvailableBytes < 2) {
        continue;
      }
      if (numAvailableBytes > this$static._numFastBytes) {
        numAvailableBytes = this$static._numFastBytes;
      }
      if (!nextIsChar && matchByte != currentByte) {
        t = Math.min(numAvailableBytesFull - 1, this$static._numFastBytes);
        lenTest2 = $GetMatchLen(this$static._matchFinder, 0, this$static.reps[0], t);
        if (lenTest2 >= 2) {
          state2 = StateUpdateChar(state);
          posStateNext = position + 1 & this$static._posStateMask;
          nextRepMatchPrice = curAnd1Price + ProbPrices[2048 - this$static._isMatch[(state2 << 4) + posStateNext] >>> 2] + ProbPrices[2048 - this$static._isRep[state2] >>> 2];
          offset = cur + 1 + lenTest2;
          while (lenEnd < offset) {
            this$static._optimum[++lenEnd].Price = 268435455;
          }
          curAndLenPrice = nextRepMatchPrice + (price = $GetPrice(this$static._repMatchLenEncoder, lenTest2 - 2, posStateNext), price + $GetPureRepPrice(this$static, 0, state2, posStateNext));
          optimum = this$static._optimum[offset];
          if (curAndLenPrice < optimum.Price) {
            optimum.Price = curAndLenPrice;
            optimum.PosPrev = cur + 1;
            optimum.BackPrev = 0;
            optimum.Prev1IsChar = 1;
            optimum.Prev2 = 0;
          }
        }
      }
      startLen = 2;
      for (repIndex = 0; repIndex < 4; ++repIndex) {
        lenTest = $GetMatchLen(this$static._matchFinder, -1, this$static.reps[repIndex], numAvailableBytes);
        if (lenTest < 2) {
          continue;
        }
        lenTestTemp = lenTest;
        do {
          while (lenEnd < cur + lenTest) {
            this$static._optimum[++lenEnd].Price = 268435455;
          }
          curAndLenPrice = repMatchPrice + (price_0 = $GetPrice(this$static._repMatchLenEncoder, lenTest - 2, posState), price_0 + $GetPureRepPrice(this$static, repIndex, state, posState));
          optimum = this$static._optimum[cur + lenTest];
          if (curAndLenPrice < optimum.Price) {
            optimum.Price = curAndLenPrice;
            optimum.PosPrev = cur;
            optimum.BackPrev = repIndex;
            optimum.Prev1IsChar = 0;
          }
        } while (--lenTest >= 2);
        lenTest = lenTestTemp;
        if (!repIndex) {
          startLen = lenTest + 1;
        }
        if (lenTest < numAvailableBytesFull) {
          t = Math.min(numAvailableBytesFull - 1 - lenTest, this$static._numFastBytes);
          lenTest2 = $GetMatchLen(this$static._matchFinder, lenTest, this$static.reps[repIndex], t);
          if (lenTest2 >= 2) {
            state2 = state < 7 ? 8 : 11;
            posStateNext = position + lenTest & this$static._posStateMask;
            curAndLenCharPrice = repMatchPrice + (price_1 = $GetPrice(this$static._repMatchLenEncoder, lenTest - 2, posState), price_1 + $GetPureRepPrice(this$static, repIndex, state, posState)) + ProbPrices[this$static._isMatch[(state2 << 4) + posStateNext] >>> 2] + $GetPrice_0($GetSubCoder(this$static._literalEncoder, position + lenTest, $GetIndexByte(this$static._matchFinder, lenTest - 1 - 1)), 1, $GetIndexByte(this$static._matchFinder, lenTest - 1 - (this$static.reps[repIndex] + 1)), $GetIndexByte(this$static._matchFinder, lenTest - 1));
            state2 = StateUpdateChar(state2);
            posStateNext = position + lenTest + 1 & this$static._posStateMask;
            nextMatchPrice = curAndLenCharPrice + ProbPrices[2048 - this$static._isMatch[(state2 << 4) + posStateNext] >>> 2];
            nextRepMatchPrice = nextMatchPrice + ProbPrices[2048 - this$static._isRep[state2] >>> 2];
            offset = lenTest + 1 + lenTest2;
            while (lenEnd < cur + offset) {
              this$static._optimum[++lenEnd].Price = 268435455;
            }
            curAndLenPrice = nextRepMatchPrice + (price_2 = $GetPrice(this$static._repMatchLenEncoder, lenTest2 - 2, posStateNext), price_2 + $GetPureRepPrice(this$static, 0, state2, posStateNext));
            optimum = this$static._optimum[cur + offset];
            if (curAndLenPrice < optimum.Price) {
              optimum.Price = curAndLenPrice;
              optimum.PosPrev = cur + lenTest + 1;
              optimum.BackPrev = 0;
              optimum.Prev1IsChar = 1;
              optimum.Prev2 = 1;
              optimum.PosPrev2 = cur;
              optimum.BackPrev2 = repIndex;
            }
          }
        }
      }
      if (newLen > numAvailableBytes) {
        newLen = numAvailableBytes;
        for (numDistancePairs = 0; newLen > this$static._matchDistances[numDistancePairs]; numDistancePairs += 2) {
        }
        this$static._matchDistances[numDistancePairs] = newLen;
        numDistancePairs += 2;
      }
      if (newLen >= startLen) {
        normalMatchPrice = matchPrice + ProbPrices[this$static._isRep[state] >>> 2];
        while (lenEnd < cur + newLen) {
          this$static._optimum[++lenEnd].Price = 268435455;
        }
        offs = 0;
        while (startLen > this$static._matchDistances[offs]) {
          offs += 2;
        }
        for (lenTest = startLen; ; ++lenTest) {
          curBack = this$static._matchDistances[offs + 1];
          curAndLenPrice = normalMatchPrice + $GetPosLenPrice(this$static, curBack, lenTest, posState);
          optimum = this$static._optimum[cur + lenTest];
          if (curAndLenPrice < optimum.Price) {
            optimum.Price = curAndLenPrice;
            optimum.PosPrev = cur;
            optimum.BackPrev = curBack + 4;
            optimum.Prev1IsChar = 0;
          }
          if (lenTest == this$static._matchDistances[offs]) {
            if (lenTest < numAvailableBytesFull) {
              t = Math.min(numAvailableBytesFull - 1 - lenTest, this$static._numFastBytes);
              lenTest2 = $GetMatchLen(this$static._matchFinder, lenTest, curBack, t);
              if (lenTest2 >= 2) {
                state2 = state < 7 ? 7 : 10;
                posStateNext = position + lenTest & this$static._posStateMask;
                curAndLenCharPrice = curAndLenPrice + ProbPrices[this$static._isMatch[(state2 << 4) + posStateNext] >>> 2] + $GetPrice_0($GetSubCoder(this$static._literalEncoder, position + lenTest, $GetIndexByte(this$static._matchFinder, lenTest - 1 - 1)), 1, $GetIndexByte(this$static._matchFinder, lenTest - (curBack + 1) - 1), $GetIndexByte(this$static._matchFinder, lenTest - 1));
                state2 = StateUpdateChar(state2);
                posStateNext = position + lenTest + 1 & this$static._posStateMask;
                nextMatchPrice = curAndLenCharPrice + ProbPrices[2048 - this$static._isMatch[(state2 << 4) + posStateNext] >>> 2];
                nextRepMatchPrice = nextMatchPrice + ProbPrices[2048 - this$static._isRep[state2] >>> 2];
                offset = lenTest + 1 + lenTest2;
                while (lenEnd < cur + offset) {
                  this$static._optimum[++lenEnd].Price = 268435455;
                }
                curAndLenPrice = nextRepMatchPrice + (price_3 = $GetPrice(this$static._repMatchLenEncoder, lenTest2 - 2, posStateNext), price_3 + $GetPureRepPrice(this$static, 0, state2, posStateNext));
                optimum = this$static._optimum[cur + offset];
                if (curAndLenPrice < optimum.Price) {
                  optimum.Price = curAndLenPrice;
                  optimum.PosPrev = cur + lenTest + 1;
                  optimum.BackPrev = 0;
                  optimum.Prev1IsChar = 1;
                  optimum.Prev2 = 1;
                  optimum.PosPrev2 = cur;
                  optimum.BackPrev2 = curBack + 4;
                }
              }
            }
            offs += 2;
            if (offs == numDistancePairs)
              break;
          }
        }
      }
    }
  }
  function $GetPosLenPrice(this$static, pos, len, posState) {
    var price, lenToPosState = GetLenToPosState(len);
    if (pos < 128) {
      price = this$static._distancesPrices[lenToPosState * 128 + pos];
    } else {
      price = this$static._posSlotPrices[(lenToPosState << 6) + GetPosSlot2(pos)] + this$static._alignPrices[pos & 15];
    }
    return price + $GetPrice(this$static._lenEncoder, len - 2, posState);
  }
  function $GetPureRepPrice(this$static, repIndex, state, posState) {
    var price;
    if (!repIndex) {
      price = ProbPrices[this$static._isRepG0[state] >>> 2];
      price += ProbPrices[2048 - this$static._isRep0Long[(state << 4) + posState] >>> 2];
    } else {
      price = ProbPrices[2048 - this$static._isRepG0[state] >>> 2];
      if (repIndex == 1) {
        price += ProbPrices[this$static._isRepG1[state] >>> 2];
      } else {
        price += ProbPrices[2048 - this$static._isRepG1[state] >>> 2];
        price += GetPrice(this$static._isRepG2[state], repIndex - 2);
      }
    }
    return price;
  }
  function $GetRepLen1Price(this$static, state, posState) {
    return ProbPrices[this$static._isRepG0[state] >>> 2] + ProbPrices[this$static._isRep0Long[(state << 4) + posState] >>> 2];
  }
  function $Init_4(this$static) {
    $BaseInit(this$static);
    $Init_9(this$static._rangeEncoder);
    InitBitModels(this$static._isMatch);
    InitBitModels(this$static._isRep0Long);
    InitBitModels(this$static._isRep);
    InitBitModels(this$static._isRepG0);
    InitBitModels(this$static._isRepG1);
    InitBitModels(this$static._isRepG2);
    InitBitModels(this$static._posEncoders);
    $Init_3(this$static._literalEncoder);
    for (var i = 0; i < 4; ++i) {
      InitBitModels(this$static._posSlotEncoder[i].Models);
    }
    $Init_2(this$static._lenEncoder, 1 << this$static._posStateBits);
    $Init_2(this$static._repMatchLenEncoder, 1 << this$static._posStateBits);
    InitBitModels(this$static._posAlignEncoder.Models);
    this$static._longestMatchWasFound = 0;
    this$static._optimumEndIndex = 0;
    this$static._optimumCurrentIndex = 0;
    this$static._additionalOffset = 0;
  }
  function $MovePos(this$static, num) {
    if (num > 0) {
      $Skip(this$static._matchFinder, num);
      this$static._additionalOffset += num;
    }
  }
  function $ReadMatchDistances(this$static) {
    var lenRes = 0;
    this$static._numDistancePairs = $GetMatches(this$static._matchFinder, this$static._matchDistances);
    if (this$static._numDistancePairs > 0) {
      lenRes = this$static._matchDistances[this$static._numDistancePairs - 2];
      if (lenRes == this$static._numFastBytes)
        lenRes += $GetMatchLen(this$static._matchFinder, lenRes - 1, this$static._matchDistances[this$static._numDistancePairs - 1], 273 - lenRes);
    }
    ++this$static._additionalOffset;
    return lenRes;
  }
  function $ReleaseMFStream(this$static) {
    if (this$static._matchFinder && this$static._needReleaseMFStream) {
      this$static._matchFinder._stream = null;
      this$static._needReleaseMFStream = 0;
    }
  }
  function $ReleaseStreams(this$static) {
    $ReleaseMFStream(this$static);
    this$static._rangeEncoder.Stream = null;
  }
  function $SetDictionarySize_0(this$static, dictionarySize) {
    this$static._dictionarySize = dictionarySize;
    for (var dicLogSize = 0; dictionarySize > 1 << dicLogSize; ++dicLogSize) {
    }
    this$static._distTableSize = dicLogSize * 2;
  }
  function $SetMatchFinder(this$static, matchFinderIndex) {
    var matchFinderIndexPrev = this$static._matchFinderType;
    this$static._matchFinderType = matchFinderIndex;
    if (this$static._matchFinder && matchFinderIndexPrev != this$static._matchFinderType) {
      this$static._dictionarySizePrev = -1;
      this$static._matchFinder = null;
    }
  }
  function $WriteCoderProperties(this$static, outStream) {
    this$static.properties[0] = (this$static._posStateBits * 5 + this$static._numLiteralPosStateBits) * 9 + this$static._numLiteralContextBits << 24 >> 24;
    for (var i = 0; i < 4; ++i) {
      this$static.properties[1 + i] = this$static._dictionarySize >> 8 * i << 24 >> 24;
    }
    $write_0(outStream, this$static.properties, 0, 5);
  }
  function $WriteEndMarker(this$static, posState) {
    if (!this$static._writeEndMark) {
      return;
    }
    $Encode_3(this$static._rangeEncoder, this$static._isMatch, (this$static._state << 4) + posState, 1);
    $Encode_3(this$static._rangeEncoder, this$static._isRep, this$static._state, 0);
    this$static._state = this$static._state < 7 ? 7 : 10;
    $Encode_0(this$static._lenEncoder, this$static._rangeEncoder, 0, posState);
    var lenToPosState = GetLenToPosState(2);
    $Encode_2(this$static._posSlotEncoder[lenToPosState], this$static._rangeEncoder, 63);
    $EncodeDirectBits(this$static._rangeEncoder, 67108863, 26);
    $ReverseEncode(this$static._posAlignEncoder, this$static._rangeEncoder, 15);
  }
  function GetPosSlot(pos) {
    if (pos < 2048) {
      return g_FastPos[pos];
    }
    if (pos < 2097152) {
      return g_FastPos[pos >> 10] + 20;
    }
    return g_FastPos[pos >> 20] + 40;
  }
  function GetPosSlot2(pos) {
    if (pos < 131072) {
      return g_FastPos[pos >> 6] + 12;
    }
    if (pos < 134217728) {
      return g_FastPos[pos >> 16] + 32;
    }
    return g_FastPos[pos >> 26] + 52;
  }
  function $Encode(this$static, rangeEncoder, symbol, posState) {
    if (symbol < 8) {
      $Encode_3(rangeEncoder, this$static._choice, 0, 0);
      $Encode_2(this$static._lowCoder[posState], rangeEncoder, symbol);
    } else {
      symbol -= 8;
      $Encode_3(rangeEncoder, this$static._choice, 0, 1);
      if (symbol < 8) {
        $Encode_3(rangeEncoder, this$static._choice, 1, 0);
        $Encode_2(this$static._midCoder[posState], rangeEncoder, symbol);
      } else {
        $Encode_3(rangeEncoder, this$static._choice, 1, 1);
        $Encode_2(this$static._highCoder, rangeEncoder, symbol - 8);
      }
    }
  }
  function $Encoder$LenEncoder(this$static) {
    this$static._choice = initDim(2);
    this$static._lowCoder = initDim(16);
    this$static._midCoder = initDim(16);
    this$static._highCoder = $BitTreeEncoder({}, 8);
    for (var posState = 0; posState < 16; ++posState) {
      this$static._lowCoder[posState] = $BitTreeEncoder({}, 3);
      this$static._midCoder[posState] = $BitTreeEncoder({}, 3);
    }
    return this$static;
  }
  function $Init_2(this$static, numPosStates) {
    InitBitModels(this$static._choice);
    for (var posState = 0; posState < numPosStates; ++posState) {
      InitBitModels(this$static._lowCoder[posState].Models);
      InitBitModels(this$static._midCoder[posState].Models);
    }
    InitBitModels(this$static._highCoder.Models);
  }
  function $SetPrices(this$static, posState, numSymbols, prices, st) {
    var a0, a1, b0, b1, i;
    a0 = ProbPrices[this$static._choice[0] >>> 2];
    a1 = ProbPrices[2048 - this$static._choice[0] >>> 2];
    b0 = a1 + ProbPrices[this$static._choice[1] >>> 2];
    b1 = a1 + ProbPrices[2048 - this$static._choice[1] >>> 2];
    i = 0;
    for (i = 0; i < 8; ++i) {
      if (i >= numSymbols)
        return;
      prices[st + i] = a0 + $GetPrice_1(this$static._lowCoder[posState], i);
    }
    for (; i < 16; ++i) {
      if (i >= numSymbols)
        return;
      prices[st + i] = b0 + $GetPrice_1(this$static._midCoder[posState], i - 8);
    }
    for (; i < numSymbols; ++i) {
      prices[st + i] = b1 + $GetPrice_1(this$static._highCoder, i - 8 - 8);
    }
  }
  function $Encode_0(this$static, rangeEncoder, symbol, posState) {
    $Encode(this$static, rangeEncoder, symbol, posState);
    if (--this$static._counters[posState] == 0) {
      $SetPrices(this$static, posState, this$static._tableSize, this$static._prices, posState * 272);
      this$static._counters[posState] = this$static._tableSize;
    }
  }
  function $Encoder$LenPriceTableEncoder(this$static) {
    $Encoder$LenEncoder(this$static);
    this$static._prices = [];
    this$static._counters = [];
    return this$static;
  }
  function $GetPrice(this$static, symbol, posState) {
    return this$static._prices[posState * 272 + symbol];
  }
  function $UpdateTables(this$static, numPosStates) {
    for (var posState = 0; posState < numPosStates; ++posState) {
      $SetPrices(this$static, posState, this$static._tableSize, this$static._prices, posState * 272);
      this$static._counters[posState] = this$static._tableSize;
    }
  }
  function $Create_1(this$static, numPosBits, numPrevBits) {
    var i, numStates;
    if (this$static.m_Coders != null && this$static.m_NumPrevBits == numPrevBits && this$static.m_NumPosBits == numPosBits) {
      return;
    }
    this$static.m_NumPosBits = numPosBits;
    this$static.m_PosMask = (1 << numPosBits) - 1;
    this$static.m_NumPrevBits = numPrevBits;
    numStates = 1 << this$static.m_NumPrevBits + this$static.m_NumPosBits;
    this$static.m_Coders = initDim(numStates);
    for (i = 0; i < numStates; ++i) {
      this$static.m_Coders[i] = $Encoder$LiteralEncoder$Encoder2({});
    }
  }
  function $GetSubCoder(this$static, pos, prevByte) {
    return this$static.m_Coders[((pos & this$static.m_PosMask) << this$static.m_NumPrevBits) + ((prevByte & 255) >>> 8 - this$static.m_NumPrevBits)];
  }
  function $Init_3(this$static) {
    var i, numStates = 1 << this$static.m_NumPrevBits + this$static.m_NumPosBits;
    for (i = 0; i < numStates; ++i) {
      InitBitModels(this$static.m_Coders[i].m_Encoders);
    }
  }
  function $Encode_1(this$static, rangeEncoder, symbol) {
    var bit, i, context2 = 1;
    for (i = 7; i >= 0; --i) {
      bit = symbol >> i & 1;
      $Encode_3(rangeEncoder, this$static.m_Encoders, context2, bit);
      context2 = context2 << 1 | bit;
    }
  }
  function $EncodeMatched(this$static, rangeEncoder, matchByte, symbol) {
    var bit, i, matchBit, state, same = 1, context2 = 1;
    for (i = 7; i >= 0; --i) {
      bit = symbol >> i & 1;
      state = context2;
      if (same) {
        matchBit = matchByte >> i & 1;
        state += 1 + matchBit << 8;
        same = matchBit == bit;
      }
      $Encode_3(rangeEncoder, this$static.m_Encoders, state, bit);
      context2 = context2 << 1 | bit;
    }
  }
  function $Encoder$LiteralEncoder$Encoder2(this$static) {
    this$static.m_Encoders = initDim(768);
    return this$static;
  }
  function $GetPrice_0(this$static, matchMode, matchByte, symbol) {
    var bit, context2 = 1, i = 7, matchBit, price = 0;
    if (matchMode) {
      for (; i >= 0; --i) {
        matchBit = matchByte >> i & 1;
        bit = symbol >> i & 1;
        price += GetPrice(this$static.m_Encoders[(1 + matchBit << 8) + context2], bit);
        context2 = context2 << 1 | bit;
        if (matchBit != bit) {
          --i;
          break;
        }
      }
    }
    for (; i >= 0; --i) {
      bit = symbol >> i & 1;
      price += GetPrice(this$static.m_Encoders[context2], bit);
      context2 = context2 << 1 | bit;
    }
    return price;
  }
  function $MakeAsChar(this$static) {
    this$static.BackPrev = -1;
    this$static.Prev1IsChar = 0;
  }
  function $MakeAsShortRep(this$static) {
    this$static.BackPrev = 0;
    this$static.Prev1IsChar = 0;
  }
  function $BitTreeDecoder(this$static, numBitLevels) {
    this$static.NumBitLevels = numBitLevels;
    this$static.Models = initDim(1 << numBitLevels);
    return this$static;
  }
  function $Decode_0(this$static, rangeDecoder) {
    var bitIndex, m = 1;
    for (bitIndex = this$static.NumBitLevels; bitIndex != 0; --bitIndex) {
      m = (m << 1) + $DecodeBit(rangeDecoder, this$static.Models, m);
    }
    return m - (1 << this$static.NumBitLevels);
  }
  function $ReverseDecode(this$static, rangeDecoder) {
    var bit, bitIndex, m = 1, symbol = 0;
    for (bitIndex = 0; bitIndex < this$static.NumBitLevels; ++bitIndex) {
      bit = $DecodeBit(rangeDecoder, this$static.Models, m);
      m <<= 1;
      m += bit;
      symbol |= bit << bitIndex;
    }
    return symbol;
  }
  function ReverseDecode(Models, startIndex, rangeDecoder, NumBitLevels) {
    var bit, bitIndex, m = 1, symbol = 0;
    for (bitIndex = 0; bitIndex < NumBitLevels; ++bitIndex) {
      bit = $DecodeBit(rangeDecoder, Models, startIndex + m);
      m <<= 1;
      m += bit;
      symbol |= bit << bitIndex;
    }
    return symbol;
  }
  function $BitTreeEncoder(this$static, numBitLevels) {
    this$static.NumBitLevels = numBitLevels;
    this$static.Models = initDim(1 << numBitLevels);
    return this$static;
  }
  function $Encode_2(this$static, rangeEncoder, symbol) {
    var bit, bitIndex, m = 1;
    for (bitIndex = this$static.NumBitLevels; bitIndex != 0; ) {
      --bitIndex;
      bit = symbol >>> bitIndex & 1;
      $Encode_3(rangeEncoder, this$static.Models, m, bit);
      m = m << 1 | bit;
    }
  }
  function $GetPrice_1(this$static, symbol) {
    var bit, bitIndex, m = 1, price = 0;
    for (bitIndex = this$static.NumBitLevels; bitIndex != 0; ) {
      --bitIndex;
      bit = symbol >>> bitIndex & 1;
      price += GetPrice(this$static.Models[m], bit);
      m = (m << 1) + bit;
    }
    return price;
  }
  function $ReverseEncode(this$static, rangeEncoder, symbol) {
    var bit, i, m = 1;
    for (i = 0; i < this$static.NumBitLevels; ++i) {
      bit = symbol & 1;
      $Encode_3(rangeEncoder, this$static.Models, m, bit);
      m = m << 1 | bit;
      symbol >>= 1;
    }
  }
  function $ReverseGetPrice(this$static, symbol) {
    var bit, i, m = 1, price = 0;
    for (i = this$static.NumBitLevels; i != 0; --i) {
      bit = symbol & 1;
      symbol >>>= 1;
      price += GetPrice(this$static.Models[m], bit);
      m = m << 1 | bit;
    }
    return price;
  }
  function ReverseEncode(Models, startIndex, rangeEncoder, NumBitLevels, symbol) {
    var bit, i, m = 1;
    for (i = 0; i < NumBitLevels; ++i) {
      bit = symbol & 1;
      $Encode_3(rangeEncoder, Models, startIndex + m, bit);
      m = m << 1 | bit;
      symbol >>= 1;
    }
  }
  function ReverseGetPrice(Models, startIndex, NumBitLevels, symbol) {
    var bit, i, m = 1, price = 0;
    for (i = NumBitLevels; i != 0; --i) {
      bit = symbol & 1;
      symbol >>>= 1;
      price += ProbPrices[((Models[startIndex + m] - bit ^ -bit) & 2047) >>> 2];
      m = m << 1 | bit;
    }
    return price;
  }
  function $DecodeBit(this$static, probs, index2) {
    var newBound, prob = probs[index2];
    newBound = (this$static.Range >>> 11) * prob;
    if ((this$static.Code ^ -2147483648) < (newBound ^ -2147483648)) {
      this$static.Range = newBound;
      probs[index2] = prob + (2048 - prob >>> 5) << 16 >> 16;
      if (!(this$static.Range & -16777216)) {
        this$static.Code = this$static.Code << 8 | $read(this$static.Stream);
        this$static.Range <<= 8;
      }
      return 0;
    } else {
      this$static.Range -= newBound;
      this$static.Code -= newBound;
      probs[index2] = prob - (prob >>> 5) << 16 >> 16;
      if (!(this$static.Range & -16777216)) {
        this$static.Code = this$static.Code << 8 | $read(this$static.Stream);
        this$static.Range <<= 8;
      }
      return 1;
    }
  }
  function $DecodeDirectBits(this$static, numTotalBits) {
    var i, t, result = 0;
    for (i = numTotalBits; i != 0; --i) {
      this$static.Range >>>= 1;
      t = this$static.Code - this$static.Range >>> 31;
      this$static.Code -= this$static.Range & t - 1;
      result = result << 1 | 1 - t;
      if (!(this$static.Range & -16777216)) {
        this$static.Code = this$static.Code << 8 | $read(this$static.Stream);
        this$static.Range <<= 8;
      }
    }
    return result;
  }
  function $Init_8(this$static) {
    this$static.Code = 0;
    this$static.Range = -1;
    for (var i = 0; i < 5; ++i) {
      this$static.Code = this$static.Code << 8 | $read(this$static.Stream);
    }
  }
  function InitBitModels(probs) {
    for (var i = probs.length - 1; i >= 0; --i) {
      probs[i] = 1024;
    }
  }
  var ProbPrices = function() {
    var end, i, j, start, ProbPrices2 = [];
    for (i = 8; i >= 0; --i) {
      start = 1 << 9 - i - 1;
      end = 1 << 9 - i;
      for (j = start; j < end; ++j) {
        ProbPrices2[j] = (i << 6) + (end - j << 6 >>> 9 - i - 1);
      }
    }
    return ProbPrices2;
  }();
  function $Encode_3(this$static, probs, index2, symbol) {
    var newBound, prob = probs[index2];
    newBound = (this$static.Range >>> 11) * prob;
    if (!symbol) {
      this$static.Range = newBound;
      probs[index2] = prob + (2048 - prob >>> 5) << 16 >> 16;
    } else {
      this$static.Low = add2(this$static.Low, and(fromInt(newBound), [4294967295, 0]));
      this$static.Range -= newBound;
      probs[index2] = prob - (prob >>> 5) << 16 >> 16;
    }
    if (!(this$static.Range & -16777216)) {
      this$static.Range <<= 8;
      $ShiftLow(this$static);
    }
  }
  function $EncodeDirectBits(this$static, v, numTotalBits) {
    for (var i = numTotalBits - 1; i >= 0; --i) {
      this$static.Range >>>= 1;
      if ((v >>> i & 1) == 1) {
        this$static.Low = add2(this$static.Low, fromInt(this$static.Range));
      }
      if (!(this$static.Range & -16777216)) {
        this$static.Range <<= 8;
        $ShiftLow(this$static);
      }
    }
  }
  function $GetProcessedSizeAdd(this$static) {
    return add2(add2(fromInt(this$static._cacheSize), this$static._position), [4, 0]);
  }
  function $Init_9(this$static) {
    this$static._position = P0_longLit;
    this$static.Low = P0_longLit;
    this$static.Range = -1;
    this$static._cacheSize = 1;
    this$static._cache = 0;
  }
  function $ShiftLow(this$static) {
    var temp2, LowHi = lowBits_0(shru(this$static.Low, 32));
    if (LowHi != 0 || compare(this$static.Low, [4278190080, 0]) < 0) {
      this$static._position = add2(this$static._position, fromInt(this$static._cacheSize));
      temp2 = this$static._cache;
      do {
        $write(this$static.Stream, temp2 + LowHi);
        temp2 = 255;
      } while (--this$static._cacheSize != 0);
      this$static._cache = lowBits_0(this$static.Low) >>> 24;
    }
    ++this$static._cacheSize;
    this$static.Low = shl(and(this$static.Low, [16777215, 0]), 8);
  }
  function GetPrice(Prob, symbol) {
    return ProbPrices[((Prob - symbol ^ -symbol) & 2047) >>> 2];
  }
  function decode2(utf) {
    var i = 0, j = 0, x, y, z, l = utf.length, buf = [], charCodes = [];
    for (; i < l; ++i, ++j) {
      x = utf[i] & 255;
      if (!(x & 128)) {
        if (!x) {
          return utf;
        }
        charCodes[j] = x;
      } else if ((x & 224) == 192) {
        if (i + 1 >= l) {
          return utf;
        }
        y = utf[++i] & 255;
        if ((y & 192) != 128) {
          return utf;
        }
        charCodes[j] = (x & 31) << 6 | y & 63;
      } else if ((x & 240) == 224) {
        if (i + 2 >= l) {
          return utf;
        }
        y = utf[++i] & 255;
        if ((y & 192) != 128) {
          return utf;
        }
        z = utf[++i] & 255;
        if ((z & 192) != 128) {
          return utf;
        }
        charCodes[j] = (x & 15) << 12 | (y & 63) << 6 | z & 63;
      } else {
        return utf;
      }
      if (j == 16383) {
        buf.push(String.fromCharCode.apply(String, charCodes));
        j = -1;
      }
    }
    if (j > 0) {
      charCodes.length = j;
      buf.push(String.fromCharCode.apply(String, charCodes));
    }
    return buf.join("");
  }
  function encode2(s) {
    var ch, chars = [], data, elen = 0, i, l = s.length;
    if (typeof s == "object") {
      return s;
    } else {
      $getChars(s, 0, l, chars, 0);
    }
    for (i = 0; i < l; ++i) {
      ch = chars[i];
      if (ch >= 1 && ch <= 127) {
        ++elen;
      } else if (!ch || ch >= 128 && ch <= 2047) {
        elen += 2;
      } else {
        elen += 3;
      }
    }
    data = [];
    elen = 0;
    for (i = 0; i < l; ++i) {
      ch = chars[i];
      if (ch >= 1 && ch <= 127) {
        data[elen++] = ch << 24 >> 24;
      } else if (!ch || ch >= 128 && ch <= 2047) {
        data[elen++] = (192 | ch >> 6 & 31) << 24 >> 24;
        data[elen++] = (128 | ch & 63) << 24 >> 24;
      } else {
        data[elen++] = (224 | ch >> 12 & 15) << 24 >> 24;
        data[elen++] = (128 | ch >> 6 & 63) << 24 >> 24;
        data[elen++] = (128 | ch & 63) << 24 >> 24;
      }
    }
    return data;
  }
  function toDouble(a) {
    return a[1] + a[0];
  }
  function compress(str, mode2, on_finish, on_progress) {
    var this$static = {}, percent, cbn, sync = typeof on_finish == "undefined" && typeof on_progress == "undefined";
    if (typeof on_finish != "function") {
      cbn = on_finish;
      on_finish = on_progress = 0;
    }
    on_progress = on_progress || function(percent2) {
      if (typeof cbn == "undefined")
        return;
      return update_progress(percent2, cbn);
    };
    on_finish = on_finish || function(res, err) {
      if (typeof cbn == "undefined")
        return;
      return postMessage({
        action: action_compress,
        cbn,
        result: res,
        error: err
      });
    };
    if (sync) {
      this$static.c = $LZMAByteArrayCompressor({}, encode2(str), get_mode_obj(mode2));
      while ($processChunk(this$static.c.chunker))
        ;
      return $toByteArray(this$static.c.output);
    }
    try {
      this$static.c = $LZMAByteArrayCompressor({}, encode2(str), get_mode_obj(mode2));
      on_progress(0);
    } catch (err) {
      return on_finish(null, err);
    }
    function do_action() {
      try {
        var res, start = new Date().getTime();
        while ($processChunk(this$static.c.chunker)) {
          percent = toDouble(this$static.c.chunker.inBytesProcessed) / toDouble(this$static.c.length_0);
          if (new Date().getTime() - start > 200) {
            on_progress(percent);
            wait2(do_action, 0);
            return 0;
          }
        }
        on_progress(1);
        res = $toByteArray(this$static.c.output);
        wait2(on_finish.bind(null, res), 0);
      } catch (err) {
        on_finish(null, err);
      }
    }
    wait2(do_action, 0);
  }
  function decompress(byte_arr, on_finish, on_progress) {
    var this$static = {}, percent, cbn, has_progress, len, sync = typeof on_finish == "undefined" && typeof on_progress == "undefined";
    if (typeof on_finish != "function") {
      cbn = on_finish;
      on_finish = on_progress = 0;
    }
    on_progress = on_progress || function(percent2) {
      if (typeof cbn == "undefined")
        return;
      return update_progress(has_progress ? percent2 : -1, cbn);
    };
    on_finish = on_finish || function(res, err) {
      if (typeof cbn == "undefined")
        return;
      return postMessage({
        action: action_decompress,
        cbn,
        result: res,
        error: err
      });
    };
    if (sync) {
      this$static.d = $LZMAByteArrayDecompressor({}, byte_arr);
      while ($processChunk(this$static.d.chunker))
        ;
      return decode2($toByteArray(this$static.d.output));
    }
    try {
      this$static.d = $LZMAByteArrayDecompressor({}, byte_arr);
      len = toDouble(this$static.d.length_0);
      has_progress = len > -1;
      on_progress(0);
    } catch (err) {
      return on_finish(null, err);
    }
    function do_action() {
      try {
        var res, i = 0, start = new Date().getTime();
        while ($processChunk(this$static.d.chunker)) {
          if (++i % 1e3 == 0 && new Date().getTime() - start > 200) {
            if (has_progress) {
              percent = toDouble(this$static.d.chunker.decoder.nowPos64) / len;
              on_progress(percent);
            }
            wait2(do_action, 0);
            return 0;
          }
        }
        on_progress(1);
        res = decode2($toByteArray(this$static.d.output));
        wait2(on_finish.bind(null, res), 0);
      } catch (err) {
        on_finish(null, err);
      }
    }
    wait2(do_action, 0);
  }
  var get_mode_obj = function() {
    var modes = [
      { s: 16, f: 64, m: 0 },
      { s: 20, f: 64, m: 0 },
      { s: 19, f: 64, m: 1 },
      { s: 20, f: 64, m: 1 },
      { s: 21, f: 128, m: 1 },
      { s: 22, f: 128, m: 1 },
      { s: 23, f: 128, m: 1 },
      { s: 24, f: 255, m: 1 },
      { s: 25, f: 255, m: 1 }
    ];
    return function(mode2) {
      return modes[mode2 - 1] || modes[6];
    };
  }();
  if (typeof onmessage != "undefined" && (typeof window == "undefined" || typeof window.document == "undefined")) {
    (function() {
      onmessage = function(e2) {
        if (e2 && e2.data) {
          if (e2.data.action == action_decompress) {
            LZMA.decompress(e2.data.data, e2.data.cbn);
          } else if (e2.data.action == action_compress) {
            LZMA.compress(e2.data.data, e2.data.mode, e2.data.cbn);
          }
        }
      };
    })();
  }
  return {
    compress,
    decompress
  };
}();
const EPOCH = 621355968e9;
class Replay {
  constructor() {
    this.gameMode = 0;
    this.gameVersion = 0;
    this.beatmapMD5 = "";
    this.playerName = "";
    this.replayMD5 = "";
    this.number_300s = 0;
    this.number_100s = 0;
    this.number_50s = 0;
    this.gekis = 0;
    this.katus = 0;
    this.misses = 0;
    this.score = 0;
    this.maxCombo = 0;
    this.perfectCombo = 0;
    this.mods = new Mods();
    this.life_bar = "";
    this.timestamp = new Date(0);
    this.replayLength = 0;
    this.replayData = new ReplayData();
    this.unknown = 0;
  }
  async toBlob() {
    const replayBytes = await write(this);
    const arrayBuffer = Uint8Array.from(replayBytes);
    return new Blob([arrayBuffer], {
      type: "application/x-osu-replay"
    });
  }
  static async FromBuffer(buffer2) {
    return await read(buffer2);
  }
  static async FromArrayBuffer(arrayBuffer) {
    const buffer$1 = buffer.Buffer.alloc(arrayBuffer.byteLength);
    const view = new Uint8Array(arrayBuffer);
    for (let i = 0; i < buffer$1.length; ++i) {
      buffer$1[i] = view[i];
    }
    return await read(buffer$1);
  }
}
function read(buff) {
  let offset = 0;
  return new Promise(async (resolve2, reject2) => {
    let replay = new Replay();
    try {
      replay.gameMode = readByte(buff);
      replay.gameVersion = readInteger(buff);
      replay.beatmapMD5 = readString(buff);
      replay.playerName = readString(buff);
      replay.replayMD5 = readString(buff);
      replay.number_300s = readShort(buff);
      replay.number_100s = readShort(buff);
      replay.number_50s = readShort(buff);
      replay.gekis = readShort(buff);
      replay.katus = readShort(buff);
      replay.misses = readShort(buff);
      replay.score = readInteger(buff);
      replay.maxCombo = readShort(buff);
      replay.perfectCombo = readByte(buff);
      replay.mods = new Mods(readInteger(buff));
      replay.life_bar = readString(buff);
      replay.timestamp = new Date(Number(readLong(buff) - BigInt(EPOCH)) / 1e4);
      replay.replayLength = readInteger(buff);
      if (replay.replayLength != 0) {
        const replayDataString = await readCompressedPromise(buff, replay.replayLength);
        replay.replayData = new ReplayData(replayDataString);
        replay.unknown = Number(readLong(buff));
      }
      resolve2(replay);
    } catch (err) {
      reject2(null);
    }
  });
  function readByte(buffer2) {
    offset++;
    return buffer2.readInt8(offset - 1);
  }
  function readShort(buffer2) {
    offset += 2;
    return buffer2.readUIntLE(offset - 2, 2);
  }
  function readInteger(buffer2) {
    offset += 4;
    return buffer2.readInt32LE(offset - 4);
  }
  function readLong(buffer2) {
    offset += 8;
    return buffer2.readBigUInt64LE(offset - 8);
  }
  function readString(buffer2) {
    if (buffer2.readInt8(offset) == 11) {
      offset++;
      let ulebString = leb.decodeUInt64(buffer2.slice(offset, offset + 8), 0);
      let strLength = ulebString.value;
      offset += strLength + ulebString.nextIndex;
      return buffer2.slice(offset - strLength, offset).toString();
    } else {
      offset++;
      return "";
    }
  }
  function readCompressed(buffer2, length, callback) {
    offset += length;
    return length != 0 ? LZMA.decompress(buffer2.slice(offset - length, offset), callback) : callback(null, null);
  }
  function readCompressedPromise(buffer2, length) {
    return new Promise((resolve2, reject2) => {
      readCompressed(buffer2, length, (result, err) => {
        if (result !== void 0) {
          resolve2(result);
        } else {
          reject2(err);
        }
      });
    });
  }
}
function write(replay) {
  return new Promise((resolve2, reject2) => {
    try {
      let gameMode = buffer.Buffer.from([replay.gameMode]);
      let gameVersion = writeInteger(replay.gameVersion);
      let beatmapMD5 = writeString(replay.beatmapMD5);
      let playerName = writeString(replay.playerName);
      let replayMD5 = writeString(replay.replayMD5);
      let number_300s = writeShort(replay.number_300s || 0);
      let number_100s = writeShort(replay.number_100s || 0);
      let number_50s = writeShort(replay.number_50s || 0);
      let gekis = writeShort(replay.gekis || 0);
      let katus = writeShort(replay.katus || 0);
      let misses = writeShort(replay.misses || 0);
      let score = writeInteger(replay.score || 0);
      let maxCombo = writeShort(replay.maxCombo || 0);
      let perfectCombo = new buffer.Buffer([replay.perfectCombo]);
      let mods = writeInteger(replay.mods.numeric);
      let life_bar = writeString(replay.life_bar || "");
      let timestamp = writeLong((replay.timestamp || new Date()).getTime() * 1e4 + EPOCH);
      LZMA.compress(replay.replayData.toString() || "", 1, (res, err) => {
        let replayData = buffer.Buffer.from(res);
        let replayLength = writeInteger(replayData.length);
        let unknown = writeLong(replay.unknown || 0);
        const finalResult = buffer.Buffer.concat([
          gameMode,
          gameVersion,
          beatmapMD5,
          playerName,
          replayMD5,
          number_300s,
          number_100s,
          number_50s,
          gekis,
          katus,
          misses,
          score,
          maxCombo,
          perfectCombo,
          mods,
          life_bar,
          timestamp,
          replayLength,
          replayData,
          unknown
        ]);
        resolve2(finalResult);
      });
    } catch (err) {
      reject2(buffer.Buffer.from([0]));
    }
  });
  function writeString(text) {
    if (text.length > 0) {
      return buffer.Buffer.concat([buffer.Buffer.from([11]), leb.encodeUInt32(text.length), buffer.Buffer.from(text)]);
    }
    return buffer.Buffer.from([0]);
  }
  function writeInteger(int) {
    let buffer$1 = buffer.Buffer.alloc(4);
    buffer$1.writeInt32LE(int);
    return buffer$1;
  }
  function writeShort(short) {
    let buffer$1 = buffer.Buffer.alloc(2);
    buffer$1.writeUIntLE(short, 0, 2);
    return buffer$1;
  }
  function writeLong(long) {
    let buffer$1 = buffer.Buffer.alloc(8);
    buffer$1.writeBigUInt64LE(BigInt(long));
    return buffer$1;
  }
}
const ZipDeflate = (() => {
  const MAX_BITS = 15;
  const D_CODES = 30;
  const BL_CODES = 19;
  const LENGTH_CODES = 29;
  const LITERALS = 256;
  const L_CODES = LITERALS + 1 + LENGTH_CODES;
  const HEAP_SIZE = 2 * L_CODES + 1;
  const END_BLOCK = 256;
  const MAX_BL_BITS = 7;
  const REP_3_6 = 16;
  const REPZ_3_10 = 17;
  const REPZ_11_138 = 18;
  const Buf_size = 8 * 2;
  const Z_DEFAULT_COMPRESSION = -1;
  const Z_FILTERED = 1;
  const Z_HUFFMAN_ONLY = 2;
  const Z_DEFAULT_STRATEGY = 0;
  const Z_NO_FLUSH = 0;
  const Z_PARTIAL_FLUSH = 1;
  const Z_FULL_FLUSH = 3;
  const Z_FINISH = 4;
  const Z_OK = 0;
  const Z_STREAM_END = 1;
  const Z_NEED_DICT = 2;
  const Z_STREAM_ERROR = -2;
  const Z_DATA_ERROR = -3;
  const Z_BUF_ERROR = -5;
  function extractArray(array) {
    return flatArray(array.map(([length, value]) => new Array(length).fill(value, 0, length)));
  }
  function flatArray(array) {
    return array.reduce((a, b) => a.concat(Array.isArray(b) ? flatArray(b) : b), []);
  }
  const _dist_code = [0, 1, 2, 3].concat(...extractArray([
    [2, 4],
    [2, 5],
    [4, 6],
    [4, 7],
    [8, 8],
    [8, 9],
    [16, 10],
    [16, 11],
    [32, 12],
    [32, 13],
    [64, 14],
    [64, 15],
    [2, 0],
    [1, 16],
    [1, 17],
    [2, 18],
    [2, 19],
    [4, 20],
    [4, 21],
    [8, 22],
    [8, 23],
    [16, 24],
    [16, 25],
    [32, 26],
    [32, 27],
    [64, 28],
    [64, 29]
  ]));
  function Tree() {
    const that = this;
    function gen_bitlen(s) {
      const tree = that.dyn_tree;
      const stree = that.stat_desc.static_tree;
      const extra = that.stat_desc.extra_bits;
      const base = that.stat_desc.extra_base;
      const max_length = that.stat_desc.max_length;
      let h;
      let n, m;
      let bits2;
      let xbits;
      let f;
      let overflow = 0;
      for (bits2 = 0; bits2 <= MAX_BITS; bits2++)
        s.bl_count[bits2] = 0;
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits2 = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits2 > max_length) {
          bits2 = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits2;
        if (n > that.max_code)
          continue;
        s.bl_count[bits2]++;
        xbits = 0;
        if (n >= base)
          xbits = extra[n - base];
        f = tree[n * 2];
        s.opt_len += f * (bits2 + xbits);
        if (stree)
          s.static_len += f * (stree[n * 2 + 1] + xbits);
      }
      if (overflow === 0)
        return;
      do {
        bits2 = max_length - 1;
        while (s.bl_count[bits2] === 0)
          bits2--;
        s.bl_count[bits2]--;
        s.bl_count[bits2 + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits2 = max_length; bits2 !== 0; bits2--) {
        n = s.bl_count[bits2];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > that.max_code)
            continue;
          if (tree[m * 2 + 1] != bits2) {
            s.opt_len += (bits2 - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits2;
          }
          n--;
        }
      }
    }
    function bi_reverse(code2, len) {
      let res = 0;
      do {
        res |= code2 & 1;
        code2 >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function gen_codes(tree, max_code, bl_count) {
      const next_code = [];
      let code2 = 0;
      let bits2;
      let n;
      let len;
      for (bits2 = 1; bits2 <= MAX_BITS; bits2++) {
        next_code[bits2] = code2 = code2 + bl_count[bits2 - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        len = tree[n * 2 + 1];
        if (len === 0)
          continue;
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    that.build_tree = function(s) {
      const tree = that.dyn_tree;
      const stree = that.stat_desc.static_tree;
      const elems = that.stat_desc.elems;
      let n, m;
      let max_code = -1;
      let node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (stree)
          s.static_len -= stree[node * 2 + 1];
      }
      that.max_code = max_code;
      for (n = Math.floor(s.heap_len / 2); n >= 1; n--)
        s.pqdownheap(tree, n);
      node = elems;
      do {
        n = s.heap[1];
        s.heap[1] = s.heap[s.heap_len--];
        s.pqdownheap(tree, 1);
        m = s.heap[1];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[1] = node++;
        s.pqdownheap(tree, 1);
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[1];
      gen_bitlen(s);
      gen_codes(tree, that.max_code, s.bl_count);
    };
  }
  Tree._length_code = [0, 1, 2, 3, 4, 5, 6, 7].concat(...extractArray([
    [2, 8],
    [2, 9],
    [2, 10],
    [2, 11],
    [4, 12],
    [4, 13],
    [4, 14],
    [4, 15],
    [8, 16],
    [8, 17],
    [8, 18],
    [8, 19],
    [16, 20],
    [16, 21],
    [16, 22],
    [16, 23],
    [32, 24],
    [32, 25],
    [32, 26],
    [31, 27],
    [1, 28]
  ]));
  Tree.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0];
  Tree.base_dist = [
    0,
    1,
    2,
    3,
    4,
    6,
    8,
    12,
    16,
    24,
    32,
    48,
    64,
    96,
    128,
    192,
    256,
    384,
    512,
    768,
    1024,
    1536,
    2048,
    3072,
    4096,
    6144,
    8192,
    12288,
    16384,
    24576
  ];
  Tree.d_code = function(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  };
  Tree.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
  Tree.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
  Tree.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
  Tree.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  function StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {
    const that = this;
    that.static_tree = static_tree;
    that.extra_bits = extra_bits;
    that.extra_base = extra_base;
    that.elems = elems;
    that.max_length = max_length;
  }
  const static_ltree2_first_part = [
    12,
    140,
    76,
    204,
    44,
    172,
    108,
    236,
    28,
    156,
    92,
    220,
    60,
    188,
    124,
    252,
    2,
    130,
    66,
    194,
    34,
    162,
    98,
    226,
    18,
    146,
    82,
    210,
    50,
    178,
    114,
    242,
    10,
    138,
    74,
    202,
    42,
    170,
    106,
    234,
    26,
    154,
    90,
    218,
    58,
    186,
    122,
    250,
    6,
    134,
    70,
    198,
    38,
    166,
    102,
    230,
    22,
    150,
    86,
    214,
    54,
    182,
    118,
    246,
    14,
    142,
    78,
    206,
    46,
    174,
    110,
    238,
    30,
    158,
    94,
    222,
    62,
    190,
    126,
    254,
    1,
    129,
    65,
    193,
    33,
    161,
    97,
    225,
    17,
    145,
    81,
    209,
    49,
    177,
    113,
    241,
    9,
    137,
    73,
    201,
    41,
    169,
    105,
    233,
    25,
    153,
    89,
    217,
    57,
    185,
    121,
    249,
    5,
    133,
    69,
    197,
    37,
    165,
    101,
    229,
    21,
    149,
    85,
    213,
    53,
    181,
    117,
    245,
    13,
    141,
    77,
    205,
    45,
    173,
    109,
    237,
    29,
    157,
    93,
    221,
    61,
    189,
    125,
    253,
    19,
    275,
    147,
    403,
    83,
    339,
    211,
    467,
    51,
    307,
    179,
    435,
    115,
    371,
    243,
    499,
    11,
    267,
    139,
    395,
    75,
    331,
    203,
    459,
    43,
    299,
    171,
    427,
    107,
    363,
    235,
    491,
    27,
    283,
    155,
    411,
    91,
    347,
    219,
    475,
    59,
    315,
    187,
    443,
    123,
    379,
    251,
    507,
    7,
    263,
    135,
    391,
    71,
    327,
    199,
    455,
    39,
    295,
    167,
    423,
    103,
    359,
    231,
    487,
    23,
    279,
    151,
    407,
    87,
    343,
    215,
    471,
    55,
    311,
    183,
    439,
    119,
    375,
    247,
    503,
    15,
    271,
    143,
    399,
    79,
    335,
    207,
    463,
    47,
    303,
    175,
    431,
    111,
    367,
    239,
    495,
    31,
    287,
    159,
    415,
    95,
    351,
    223,
    479,
    63,
    319,
    191,
    447,
    127,
    383,
    255,
    511,
    0,
    64,
    32,
    96,
    16,
    80,
    48,
    112,
    8,
    72,
    40,
    104,
    24,
    88,
    56,
    120,
    4,
    68,
    36,
    100,
    20,
    84,
    52,
    116,
    3,
    131,
    67,
    195,
    35,
    163,
    99,
    227
  ];
  const static_ltree2_second_part = extractArray([[144, 8], [112, 9], [24, 7], [8, 8]]);
  StaticTree.static_ltree = flatArray(static_ltree2_first_part.map((value, index2) => [value, static_ltree2_second_part[index2]]));
  const static_dtree_first_part = [0, 16, 8, 24, 4, 20, 12, 28, 2, 18, 10, 26, 6, 22, 14, 30, 1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 7, 23];
  const static_dtree_second_part = extractArray([[30, 5]]);
  StaticTree.static_dtree = flatArray(static_dtree_first_part.map((value, index2) => [value, static_dtree_second_part[index2]]));
  StaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  StaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES, MAX_BITS);
  StaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  const MAX_MEM_LEVEL = 9;
  const DEF_MEM_LEVEL = 8;
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    const that = this;
    that.good_length = good_length;
    that.max_lazy = max_lazy;
    that.nice_length = nice_length;
    that.max_chain = max_chain;
    that.func = func;
  }
  const STORED = 0;
  const FAST = 1;
  const SLOW = 2;
  const config_table = [
    new Config(0, 0, 0, 0, STORED),
    new Config(4, 4, 8, 4, FAST),
    new Config(4, 5, 16, 8, FAST),
    new Config(4, 6, 32, 32, FAST),
    new Config(4, 4, 16, 16, SLOW),
    new Config(8, 16, 32, 32, SLOW),
    new Config(8, 16, 128, 128, SLOW),
    new Config(8, 32, 128, 256, SLOW),
    new Config(32, 128, 258, 1024, SLOW),
    new Config(32, 258, 258, 4096, SLOW)
  ];
  const z_errmsg = [
    "need dictionary",
    "stream end",
    "",
    "",
    "stream error",
    "data error",
    "",
    "buffer error",
    "",
    ""
  ];
  const NeedMore = 0;
  const BlockDone = 1;
  const FinishStarted = 2;
  const FinishDone = 3;
  const PRESET_DICT = 32;
  const INIT_STATE = 42;
  const BUSY_STATE = 113;
  const FINISH_STATE = 666;
  const Z_DEFLATED = 8;
  const STORED_BLOCK = 0;
  const STATIC_TREES = 1;
  const DYN_TREES = 2;
  const MIN_MATCH = 3;
  const MAX_MATCH = 258;
  const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  function smaller(tree, n, m, depth) {
    const tn2 = tree[n * 2];
    const tm2 = tree[m * 2];
    return tn2 < tm2 || tn2 == tm2 && depth[n] <= depth[m];
  }
  function Deflate() {
    const that = this;
    let strm;
    let status;
    let pending_buf_size;
    let last_flush;
    let w_size;
    let w_bits;
    let w_mask;
    let win;
    let window_size;
    let prev;
    let head;
    let ins_h;
    let hash_size;
    let hash_bits;
    let hash_mask;
    let hash_shift;
    let block_start;
    let match_length;
    let prev_match;
    let match_available;
    let strstart;
    let match_start;
    let lookahead;
    let prev_length;
    let max_chain_length;
    let max_lazy_match;
    let level;
    let strategy;
    let good_match;
    let nice_match;
    let dyn_ltree;
    let dyn_dtree;
    let bl_tree;
    const l_desc = new Tree();
    const d_desc = new Tree();
    const bl_desc = new Tree();
    that.depth = [];
    let lit_bufsize;
    let last_lit;
    let matches;
    let last_eob_len;
    let bi_buf;
    let bi_valid;
    that.bl_count = [];
    that.heap = [];
    dyn_ltree = [];
    dyn_dtree = [];
    bl_tree = [];
    function lm_init() {
      window_size = 2 * w_size;
      head[hash_size - 1] = 0;
      for (let i = 0; i < hash_size - 1; i++) {
        head[i] = 0;
      }
      max_lazy_match = config_table[level].max_lazy;
      good_match = config_table[level].good_length;
      nice_match = config_table[level].nice_length;
      max_chain_length = config_table[level].max_chain;
      strstart = 0;
      block_start = 0;
      lookahead = 0;
      match_length = prev_length = MIN_MATCH - 1;
      match_available = 0;
      ins_h = 0;
    }
    function init_block() {
      let i;
      for (i = 0; i < L_CODES; i++)
        dyn_ltree[i * 2] = 0;
      for (i = 0; i < D_CODES; i++)
        dyn_dtree[i * 2] = 0;
      for (i = 0; i < BL_CODES; i++)
        bl_tree[i * 2] = 0;
      dyn_ltree[END_BLOCK * 2] = 1;
      that.opt_len = that.static_len = 0;
      last_lit = matches = 0;
    }
    function tr_init() {
      l_desc.dyn_tree = dyn_ltree;
      l_desc.stat_desc = StaticTree.static_l_desc;
      d_desc.dyn_tree = dyn_dtree;
      d_desc.stat_desc = StaticTree.static_d_desc;
      bl_desc.dyn_tree = bl_tree;
      bl_desc.stat_desc = StaticTree.static_bl_desc;
      bi_buf = 0;
      bi_valid = 0;
      last_eob_len = 8;
      init_block();
    }
    that.pqdownheap = function(tree, k) {
      const heap = that.heap;
      const v = heap[k];
      let j = k << 1;
      while (j <= that.heap_len) {
        if (j < that.heap_len && smaller(tree, heap[j + 1], heap[j], that.depth)) {
          j++;
        }
        if (smaller(tree, v, heap[j], that.depth))
          break;
        heap[k] = heap[j];
        k = j;
        j <<= 1;
      }
      heap[k] = v;
    };
    function scan_tree(tree, max_code) {
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (let n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen == nextlen) {
          continue;
        } else if (count < min_count) {
          bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen != prevlen)
            bl_tree[curlen * 2]++;
          bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          bl_tree[REPZ_3_10 * 2]++;
        } else {
          bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen == nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree() {
      let max_blindex;
      scan_tree(dyn_ltree, l_desc.max_code);
      scan_tree(dyn_dtree, d_desc.max_code);
      bl_desc.build_tree(that);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0)
          break;
      }
      that.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function put_byte(p) {
      that.pending_buf[that.pending++] = p;
    }
    function put_short(w) {
      put_byte(w & 255);
      put_byte(w >>> 8 & 255);
    }
    function putShortMSB(b) {
      put_byte(b >> 8 & 255);
      put_byte(b & 255 & 255);
    }
    function send_bits(value, length) {
      let val;
      const len = length;
      if (bi_valid > Buf_size - len) {
        val = value;
        bi_buf |= val << bi_valid & 65535;
        put_short(bi_buf);
        bi_buf = val >>> Buf_size - bi_valid;
        bi_valid += len - Buf_size;
      } else {
        bi_buf |= value << bi_valid & 65535;
        bi_valid += len;
      }
    }
    function send_code(c, tree) {
      const c2 = c * 2;
      send_bits(tree[c2] & 65535, tree[c2 + 1] & 65535);
    }
    function send_tree(tree, max_code) {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen == nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(curlen, bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen != prevlen) {
            send_code(curlen, bl_tree);
            count--;
          }
          send_code(REP_3_6, bl_tree);
          send_bits(count - 3, 2);
        } else if (count <= 10) {
          send_code(REPZ_3_10, bl_tree);
          send_bits(count - 3, 3);
        } else {
          send_code(REPZ_11_138, bl_tree);
          send_bits(count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen == nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_all_trees(lcodes, dcodes, blcodes) {
      let rank;
      send_bits(lcodes - 257, 5);
      send_bits(dcodes - 1, 5);
      send_bits(blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1], 3);
      }
      send_tree(dyn_ltree, lcodes - 1);
      send_tree(dyn_dtree, dcodes - 1);
    }
    function bi_flush() {
      if (bi_valid == 16) {
        put_short(bi_buf);
        bi_buf = 0;
        bi_valid = 0;
      } else if (bi_valid >= 8) {
        put_byte(bi_buf & 255);
        bi_buf >>>= 8;
        bi_valid -= 8;
      }
    }
    function _tr_align() {
      send_bits(STATIC_TREES << 1, 3);
      send_code(END_BLOCK, StaticTree.static_ltree);
      bi_flush();
      if (1 + last_eob_len + 10 - bi_valid < 9) {
        send_bits(STATIC_TREES << 1, 3);
        send_code(END_BLOCK, StaticTree.static_ltree);
        bi_flush();
      }
      last_eob_len = 7;
    }
    function _tr_tally(dist, lc) {
      let out_length, in_length, dcode;
      that.dist_buf[last_lit] = dist;
      that.lc_buf[last_lit] = lc & 255;
      last_lit++;
      if (dist === 0) {
        dyn_ltree[lc * 2]++;
      } else {
        matches++;
        dist--;
        dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;
        dyn_dtree[Tree.d_code(dist) * 2]++;
      }
      if ((last_lit & 8191) === 0 && level > 2) {
        out_length = last_lit * 8;
        in_length = strstart - block_start;
        for (dcode = 0; dcode < D_CODES; dcode++) {
          out_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);
        }
        out_length >>>= 3;
        if (matches < Math.floor(last_lit / 2) && out_length < Math.floor(in_length / 2))
          return true;
      }
      return last_lit == lit_bufsize - 1;
    }
    function compress_block(ltree, dtree) {
      let dist;
      let lc;
      let lx = 0;
      let code2;
      let extra;
      if (last_lit !== 0) {
        do {
          dist = that.dist_buf[lx];
          lc = that.lc_buf[lx];
          lx++;
          if (dist === 0) {
            send_code(lc, ltree);
          } else {
            code2 = Tree._length_code[lc];
            send_code(code2 + LITERALS + 1, ltree);
            extra = Tree.extra_lbits[code2];
            if (extra !== 0) {
              lc -= Tree.base_length[code2];
              send_bits(lc, extra);
            }
            dist--;
            code2 = Tree.d_code(dist);
            send_code(code2, dtree);
            extra = Tree.extra_dbits[code2];
            if (extra !== 0) {
              dist -= Tree.base_dist[code2];
              send_bits(dist, extra);
            }
          }
        } while (lx < last_lit);
      }
      send_code(END_BLOCK, ltree);
      last_eob_len = ltree[END_BLOCK * 2 + 1];
    }
    function bi_windup() {
      if (bi_valid > 8) {
        put_short(bi_buf);
      } else if (bi_valid > 0) {
        put_byte(bi_buf & 255);
      }
      bi_buf = 0;
      bi_valid = 0;
    }
    function copy_block(buf, len, header) {
      bi_windup();
      last_eob_len = 8;
      if (header) {
        put_short(len);
        put_short(~len);
      }
      that.pending_buf.set(win.subarray(buf, buf + len), that.pending);
      that.pending += len;
    }
    function _tr_stored_block(buf, stored_len, eof) {
      send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0), 3);
      copy_block(buf, stored_len, true);
    }
    function _tr_flush_block(buf, stored_len, eof) {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (level > 0) {
        l_desc.build_tree(that);
        d_desc.build_tree(that);
        max_blindex = build_bl_tree();
        opt_lenb = that.opt_len + 3 + 7 >>> 3;
        static_lenb = that.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb)
          opt_lenb = static_lenb;
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf != -1) {
        _tr_stored_block(buf, stored_len, eof);
      } else if (static_lenb == opt_lenb) {
        send_bits((STATIC_TREES << 1) + (eof ? 1 : 0), 3);
        compress_block(StaticTree.static_ltree, StaticTree.static_dtree);
      } else {
        send_bits((DYN_TREES << 1) + (eof ? 1 : 0), 3);
        send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
        compress_block(dyn_ltree, dyn_dtree);
      }
      init_block();
      if (eof) {
        bi_windup();
      }
    }
    function flush_block_only(eof) {
      _tr_flush_block(block_start >= 0 ? block_start : -1, strstart - block_start, eof);
      block_start = strstart;
      strm.flush_pending();
    }
    function fill_window() {
      let n, m;
      let p;
      let more;
      do {
        more = window_size - lookahead - strstart;
        if (more === 0 && strstart === 0 && lookahead === 0) {
          more = w_size;
        } else if (more == -1) {
          more--;
        } else if (strstart >= w_size + w_size - MIN_LOOKAHEAD) {
          win.set(win.subarray(w_size, w_size + w_size), 0);
          match_start -= w_size;
          strstart -= w_size;
          block_start -= w_size;
          n = hash_size;
          p = n;
          do {
            m = head[--p] & 65535;
            head[p] = m >= w_size ? m - w_size : 0;
          } while (--n !== 0);
          n = w_size;
          p = n;
          do {
            m = prev[--p] & 65535;
            prev[p] = m >= w_size ? m - w_size : 0;
          } while (--n !== 0);
          more += w_size;
        }
        if (strm.avail_in === 0)
          return;
        n = strm.read_buf(win, strstart + lookahead, more);
        lookahead += n;
        if (lookahead >= MIN_MATCH) {
          ins_h = win[strstart] & 255;
          ins_h = (ins_h << hash_shift ^ win[strstart + 1] & 255) & hash_mask;
        }
      } while (lookahead < MIN_LOOKAHEAD && strm.avail_in !== 0);
    }
    function deflate_stored(flush) {
      let max_block_size = 65535;
      let max_start;
      if (max_block_size > pending_buf_size - 5) {
        max_block_size = pending_buf_size - 5;
      }
      while (true) {
        if (lookahead <= 1) {
          fill_window();
          if (lookahead === 0 && flush == Z_NO_FLUSH)
            return NeedMore;
          if (lookahead === 0)
            break;
        }
        strstart += lookahead;
        lookahead = 0;
        max_start = block_start + max_block_size;
        if (strstart === 0 || strstart >= max_start) {
          lookahead = strstart - max_start;
          strstart = max_start;
          flush_block_only(false);
          if (strm.avail_out === 0)
            return NeedMore;
        }
        if (strstart - block_start >= w_size - MIN_LOOKAHEAD) {
          flush_block_only(false);
          if (strm.avail_out === 0)
            return NeedMore;
        }
      }
      flush_block_only(flush == Z_FINISH);
      if (strm.avail_out === 0)
        return flush == Z_FINISH ? FinishStarted : NeedMore;
      return flush == Z_FINISH ? FinishDone : BlockDone;
    }
    function longest_match(cur_match) {
      let chain_length = max_chain_length;
      let scan = strstart;
      let match;
      let len;
      let best_len = prev_length;
      const limit = strstart > w_size - MIN_LOOKAHEAD ? strstart - (w_size - MIN_LOOKAHEAD) : 0;
      let _nice_match = nice_match;
      const wmask = w_mask;
      const strend = strstart + MAX_MATCH;
      let scan_end1 = win[scan + best_len - 1];
      let scan_end = win[scan + best_len];
      if (prev_length >= good_match) {
        chain_length >>= 2;
      }
      if (_nice_match > lookahead)
        _nice_match = lookahead;
      do {
        match = cur_match;
        if (win[match + best_len] != scan_end || win[match + best_len - 1] != scan_end1 || win[match] != win[scan] || win[++match] != win[scan + 1])
          continue;
        scan += 2;
        match++;
        do {
        } while (win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          match_start = cur_match;
          best_len = len;
          if (len >= _nice_match)
            break;
          scan_end1 = win[scan + best_len - 1];
          scan_end = win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask] & 65535) > limit && --chain_length !== 0);
      if (best_len <= lookahead)
        return best_len;
      return lookahead;
    }
    function deflate_fast(flush) {
      let hash_head = 0;
      let bflush;
      while (true) {
        if (lookahead < MIN_LOOKAHEAD) {
          fill_window();
          if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
            return NeedMore;
          }
          if (lookahead === 0)
            break;
        }
        if (lookahead >= MIN_MATCH) {
          ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH - 1)] & 255) & hash_mask;
          hash_head = head[ins_h] & 65535;
          prev[strstart & w_mask] = head[ins_h];
          head[ins_h] = strstart;
        }
        if (hash_head !== 0 && (strstart - hash_head & 65535) <= w_size - MIN_LOOKAHEAD) {
          if (strategy != Z_HUFFMAN_ONLY) {
            match_length = longest_match(hash_head);
          }
        }
        if (match_length >= MIN_MATCH) {
          bflush = _tr_tally(strstart - match_start, match_length - MIN_MATCH);
          lookahead -= match_length;
          if (match_length <= max_lazy_match && lookahead >= MIN_MATCH) {
            match_length--;
            do {
              strstart++;
              ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH - 1)] & 255) & hash_mask;
              hash_head = head[ins_h] & 65535;
              prev[strstart & w_mask] = head[ins_h];
              head[ins_h] = strstart;
            } while (--match_length !== 0);
            strstart++;
          } else {
            strstart += match_length;
            match_length = 0;
            ins_h = win[strstart] & 255;
            ins_h = (ins_h << hash_shift ^ win[strstart + 1] & 255) & hash_mask;
          }
        } else {
          bflush = _tr_tally(0, win[strstart] & 255);
          lookahead--;
          strstart++;
        }
        if (bflush) {
          flush_block_only(false);
          if (strm.avail_out === 0)
            return NeedMore;
        }
      }
      flush_block_only(flush == Z_FINISH);
      if (strm.avail_out === 0) {
        if (flush == Z_FINISH)
          return FinishStarted;
        else
          return NeedMore;
      }
      return flush == Z_FINISH ? FinishDone : BlockDone;
    }
    function deflate_slow(flush) {
      let hash_head = 0;
      let bflush;
      let max_insert;
      while (true) {
        if (lookahead < MIN_LOOKAHEAD) {
          fill_window();
          if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
            return NeedMore;
          }
          if (lookahead === 0)
            break;
        }
        if (lookahead >= MIN_MATCH) {
          ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH - 1)] & 255) & hash_mask;
          hash_head = head[ins_h] & 65535;
          prev[strstart & w_mask] = head[ins_h];
          head[ins_h] = strstart;
        }
        prev_length = match_length;
        prev_match = match_start;
        match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && prev_length < max_lazy_match && (strstart - hash_head & 65535) <= w_size - MIN_LOOKAHEAD) {
          if (strategy != Z_HUFFMAN_ONLY) {
            match_length = longest_match(hash_head);
          }
          if (match_length <= 5 && (strategy == Z_FILTERED || match_length == MIN_MATCH && strstart - match_start > 4096)) {
            match_length = MIN_MATCH - 1;
          }
        }
        if (prev_length >= MIN_MATCH && match_length <= prev_length) {
          max_insert = strstart + lookahead - MIN_MATCH;
          bflush = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);
          lookahead -= prev_length - 1;
          prev_length -= 2;
          do {
            if (++strstart <= max_insert) {
              ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH - 1)] & 255) & hash_mask;
              hash_head = head[ins_h] & 65535;
              prev[strstart & w_mask] = head[ins_h];
              head[ins_h] = strstart;
            }
          } while (--prev_length !== 0);
          match_available = 0;
          match_length = MIN_MATCH - 1;
          strstart++;
          if (bflush) {
            flush_block_only(false);
            if (strm.avail_out === 0)
              return NeedMore;
          }
        } else if (match_available !== 0) {
          bflush = _tr_tally(0, win[strstart - 1] & 255);
          if (bflush) {
            flush_block_only(false);
          }
          strstart++;
          lookahead--;
          if (strm.avail_out === 0)
            return NeedMore;
        } else {
          match_available = 1;
          strstart++;
          lookahead--;
        }
      }
      if (match_available !== 0) {
        bflush = _tr_tally(0, win[strstart - 1] & 255);
        match_available = 0;
      }
      flush_block_only(flush == Z_FINISH);
      if (strm.avail_out === 0) {
        if (flush == Z_FINISH)
          return FinishStarted;
        else
          return NeedMore;
      }
      return flush == Z_FINISH ? FinishDone : BlockDone;
    }
    function deflateReset(strm2) {
      strm2.total_in = strm2.total_out = 0;
      strm2.msg = null;
      that.pending = 0;
      that.pending_out = 0;
      status = BUSY_STATE;
      last_flush = Z_NO_FLUSH;
      tr_init();
      lm_init();
      return Z_OK;
    }
    that.deflateInit = function(strm2, _level, bits2, _method, memLevel, _strategy) {
      if (!_method)
        _method = Z_DEFLATED;
      if (!memLevel)
        memLevel = DEF_MEM_LEVEL;
      if (!_strategy)
        _strategy = Z_DEFAULT_STRATEGY;
      strm2.msg = null;
      if (_level == Z_DEFAULT_COMPRESSION)
        _level = 6;
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || _method != Z_DEFLATED || bits2 < 9 || bits2 > 15 || _level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {
        return Z_STREAM_ERROR;
      }
      strm2.dstate = that;
      w_bits = bits2;
      w_size = 1 << w_bits;
      w_mask = w_size - 1;
      hash_bits = memLevel + 7;
      hash_size = 1 << hash_bits;
      hash_mask = hash_size - 1;
      hash_shift = Math.floor((hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      win = new Uint8Array(w_size * 2);
      prev = [];
      head = [];
      lit_bufsize = 1 << memLevel + 6;
      that.pending_buf = new Uint8Array(lit_bufsize * 4);
      pending_buf_size = lit_bufsize * 4;
      that.dist_buf = new Uint16Array(lit_bufsize);
      that.lc_buf = new Uint8Array(lit_bufsize);
      level = _level;
      strategy = _strategy;
      return deflateReset(strm2);
    };
    that.deflateEnd = function() {
      if (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE) {
        return Z_STREAM_ERROR;
      }
      that.lc_buf = null;
      that.dist_buf = null;
      that.pending_buf = null;
      head = null;
      prev = null;
      win = null;
      that.dstate = null;
      return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
    };
    that.deflateParams = function(strm2, _level, _strategy) {
      let err = Z_OK;
      if (_level == Z_DEFAULT_COMPRESSION) {
        _level = 6;
      }
      if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {
        return Z_STREAM_ERROR;
      }
      if (config_table[level].func != config_table[_level].func && strm2.total_in !== 0) {
        err = strm2.deflate(Z_PARTIAL_FLUSH);
      }
      if (level != _level) {
        level = _level;
        max_lazy_match = config_table[level].max_lazy;
        good_match = config_table[level].good_length;
        nice_match = config_table[level].nice_length;
        max_chain_length = config_table[level].max_chain;
      }
      strategy = _strategy;
      return err;
    };
    that.deflateSetDictionary = function(_strm, dictionary, dictLength) {
      let length = dictLength;
      let n, index2 = 0;
      if (!dictionary || status != INIT_STATE)
        return Z_STREAM_ERROR;
      if (length < MIN_MATCH)
        return Z_OK;
      if (length > w_size - MIN_LOOKAHEAD) {
        length = w_size - MIN_LOOKAHEAD;
        index2 = dictLength - length;
      }
      win.set(dictionary.subarray(index2, index2 + length), 0);
      strstart = length;
      block_start = length;
      ins_h = win[0] & 255;
      ins_h = (ins_h << hash_shift ^ win[1] & 255) & hash_mask;
      for (n = 0; n <= length - MIN_MATCH; n++) {
        ins_h = (ins_h << hash_shift ^ win[n + (MIN_MATCH - 1)] & 255) & hash_mask;
        prev[n & w_mask] = head[ins_h];
        head[ins_h] = n;
      }
      return Z_OK;
    };
    that.deflate = function(_strm, flush) {
      let i, header, level_flags, old_flush, bstate;
      if (flush > Z_FINISH || flush < 0) {
        return Z_STREAM_ERROR;
      }
      if (!_strm.next_out || !_strm.next_in && _strm.avail_in !== 0 || status == FINISH_STATE && flush != Z_FINISH) {
        _strm.msg = z_errmsg[Z_NEED_DICT - Z_STREAM_ERROR];
        return Z_STREAM_ERROR;
      }
      if (_strm.avail_out === 0) {
        _strm.msg = z_errmsg[Z_NEED_DICT - Z_BUF_ERROR];
        return Z_BUF_ERROR;
      }
      strm = _strm;
      old_flush = last_flush;
      last_flush = flush;
      if (status == INIT_STATE) {
        header = Z_DEFLATED + (w_bits - 8 << 4) << 8;
        level_flags = (level - 1 & 255) >> 1;
        if (level_flags > 3)
          level_flags = 3;
        header |= level_flags << 6;
        if (strstart !== 0)
          header |= PRESET_DICT;
        header += 31 - header % 31;
        status = BUSY_STATE;
        putShortMSB(header);
      }
      if (that.pending !== 0) {
        strm.flush_pending();
        if (strm.avail_out === 0) {
          last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH) {
        strm.msg = z_errmsg[Z_NEED_DICT - Z_BUF_ERROR];
        return Z_BUF_ERROR;
      }
      if (status == FINISH_STATE && strm.avail_in !== 0) {
        _strm.msg = z_errmsg[Z_NEED_DICT - Z_BUF_ERROR];
        return Z_BUF_ERROR;
      }
      if (strm.avail_in !== 0 || lookahead !== 0 || flush != Z_NO_FLUSH && status != FINISH_STATE) {
        bstate = -1;
        switch (config_table[level].func) {
          case STORED:
            bstate = deflate_stored(flush);
            break;
          case FAST:
            bstate = deflate_fast(flush);
            break;
          case SLOW:
            bstate = deflate_slow(flush);
            break;
        }
        if (bstate == FinishStarted || bstate == FinishDone) {
          status = FINISH_STATE;
        }
        if (bstate == NeedMore || bstate == FinishStarted) {
          if (strm.avail_out === 0) {
            last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate == BlockDone) {
          if (flush == Z_PARTIAL_FLUSH) {
            _tr_align();
          } else {
            _tr_stored_block(0, 0, false);
            if (flush == Z_FULL_FLUSH) {
              for (i = 0; i < hash_size; i++)
                head[i] = 0;
            }
          }
          strm.flush_pending();
          if (strm.avail_out === 0) {
            last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush != Z_FINISH)
        return Z_OK;
      return Z_STREAM_END;
    };
  }
  function ZStream() {
    const that = this;
    that.next_in_index = 0;
    that.next_out_index = 0;
    that.avail_in = 0;
    that.total_in = 0;
    that.avail_out = 0;
    that.total_out = 0;
  }
  ZStream.prototype = {
    deflateInit: function(level, bits2) {
      const that = this;
      that.dstate = new Deflate();
      if (!bits2)
        bits2 = MAX_BITS;
      return that.dstate.deflateInit(that, level, bits2);
    },
    deflate: function(flush) {
      const that = this;
      if (!that.dstate) {
        return Z_STREAM_ERROR;
      }
      return that.dstate.deflate(that, flush);
    },
    deflateEnd: function() {
      const that = this;
      if (!that.dstate)
        return Z_STREAM_ERROR;
      const ret = that.dstate.deflateEnd();
      that.dstate = null;
      return ret;
    },
    deflateParams: function(level, strategy) {
      const that = this;
      if (!that.dstate)
        return Z_STREAM_ERROR;
      return that.dstate.deflateParams(that, level, strategy);
    },
    deflateSetDictionary: function(dictionary, dictLength) {
      const that = this;
      if (!that.dstate)
        return Z_STREAM_ERROR;
      return that.dstate.deflateSetDictionary(that, dictionary, dictLength);
    },
    read_buf: function(buf, start, size) {
      const that = this;
      let len = that.avail_in;
      if (len > size)
        len = size;
      if (len === 0)
        return 0;
      that.avail_in -= len;
      buf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);
      that.next_in_index += len;
      that.total_in += len;
      return len;
    },
    flush_pending: function() {
      const that = this;
      let len = that.dstate.pending;
      if (len > that.avail_out)
        len = that.avail_out;
      if (len === 0)
        return;
      that.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);
      that.next_out_index += len;
      that.dstate.pending_out += len;
      that.total_out += len;
      that.avail_out -= len;
      that.dstate.pending -= len;
      if (that.dstate.pending === 0) {
        that.dstate.pending_out = 0;
      }
    }
  };
  function ZipDeflate2(options) {
    const that = this;
    const z = new ZStream();
    const bufsize = getMaximumCompressedSize(options && options.chunkSize ? options.chunkSize : 64 * 1024);
    const flush = Z_NO_FLUSH;
    const buf = new Uint8Array(bufsize);
    let level = options ? options.level : Z_DEFAULT_COMPRESSION;
    if (typeof level == "undefined")
      level = Z_DEFAULT_COMPRESSION;
    z.deflateInit(level);
    z.next_out = buf;
    that.append = function(data, onprogress) {
      let err, array, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
      const buffers = [];
      if (!data.length)
        return;
      z.next_in_index = 0;
      z.next_in = data;
      z.avail_in = data.length;
      do {
        z.next_out_index = 0;
        z.avail_out = bufsize;
        err = z.deflate(flush);
        if (err != Z_OK)
          throw new Error("deflating: " + z.msg);
        if (z.next_out_index)
          if (z.next_out_index == bufsize)
            buffers.push(new Uint8Array(buf));
          else
            buffers.push(buf.slice(0, z.next_out_index));
        bufferSize += z.next_out_index;
        if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
          onprogress(z.next_in_index);
          lastIndex = z.next_in_index;
        }
      } while (z.avail_in > 0 || z.avail_out === 0);
      if (buffers.length > 1) {
        array = new Uint8Array(bufferSize);
        buffers.forEach(function(chunk) {
          array.set(chunk, bufferIndex);
          bufferIndex += chunk.length;
        });
      } else {
        array = buffers[0] || new Uint8Array(0);
      }
      return array;
    };
    that.flush = function() {
      let err, array, bufferIndex = 0, bufferSize = 0;
      const buffers = [];
      do {
        z.next_out_index = 0;
        z.avail_out = bufsize;
        err = z.deflate(Z_FINISH);
        if (err != Z_STREAM_END && err != Z_OK)
          throw new Error("deflating: " + z.msg);
        if (bufsize - z.avail_out > 0)
          buffers.push(buf.slice(0, z.next_out_index));
        bufferSize += z.next_out_index;
      } while (z.avail_in > 0 || z.avail_out === 0);
      z.deflateEnd();
      array = new Uint8Array(bufferSize);
      buffers.forEach(function(chunk) {
        array.set(chunk, bufferIndex);
        bufferIndex += chunk.length;
      });
      return array;
    };
  }
  function getMaximumCompressedSize(uncompressedSize) {
    return uncompressedSize + 5 * (Math.floor(uncompressedSize / 16383) + 1);
  }
  return ZipDeflate2;
})();
const ZipInflate = (() => {
  const MAX_BITS = 15;
  const Z_OK = 0;
  const Z_STREAM_END = 1;
  const Z_NEED_DICT = 2;
  const Z_STREAM_ERROR = -2;
  const Z_DATA_ERROR = -3;
  const Z_MEM_ERROR = -4;
  const Z_BUF_ERROR = -5;
  const inflate_mask = [
    0,
    1,
    3,
    7,
    15,
    31,
    63,
    127,
    255,
    511,
    1023,
    2047,
    4095,
    8191,
    16383,
    32767,
    65535
  ];
  const MANY = 1440;
  const Z_NO_FLUSH = 0;
  const Z_FINISH = 4;
  const fixed_bl = 9;
  const fixed_bd = 5;
  const fixed_tl = [
    96,
    7,
    256,
    0,
    8,
    80,
    0,
    8,
    16,
    84,
    8,
    115,
    82,
    7,
    31,
    0,
    8,
    112,
    0,
    8,
    48,
    0,
    9,
    192,
    80,
    7,
    10,
    0,
    8,
    96,
    0,
    8,
    32,
    0,
    9,
    160,
    0,
    8,
    0,
    0,
    8,
    128,
    0,
    8,
    64,
    0,
    9,
    224,
    80,
    7,
    6,
    0,
    8,
    88,
    0,
    8,
    24,
    0,
    9,
    144,
    83,
    7,
    59,
    0,
    8,
    120,
    0,
    8,
    56,
    0,
    9,
    208,
    81,
    7,
    17,
    0,
    8,
    104,
    0,
    8,
    40,
    0,
    9,
    176,
    0,
    8,
    8,
    0,
    8,
    136,
    0,
    8,
    72,
    0,
    9,
    240,
    80,
    7,
    4,
    0,
    8,
    84,
    0,
    8,
    20,
    85,
    8,
    227,
    83,
    7,
    43,
    0,
    8,
    116,
    0,
    8,
    52,
    0,
    9,
    200,
    81,
    7,
    13,
    0,
    8,
    100,
    0,
    8,
    36,
    0,
    9,
    168,
    0,
    8,
    4,
    0,
    8,
    132,
    0,
    8,
    68,
    0,
    9,
    232,
    80,
    7,
    8,
    0,
    8,
    92,
    0,
    8,
    28,
    0,
    9,
    152,
    84,
    7,
    83,
    0,
    8,
    124,
    0,
    8,
    60,
    0,
    9,
    216,
    82,
    7,
    23,
    0,
    8,
    108,
    0,
    8,
    44,
    0,
    9,
    184,
    0,
    8,
    12,
    0,
    8,
    140,
    0,
    8,
    76,
    0,
    9,
    248,
    80,
    7,
    3,
    0,
    8,
    82,
    0,
    8,
    18,
    85,
    8,
    163,
    83,
    7,
    35,
    0,
    8,
    114,
    0,
    8,
    50,
    0,
    9,
    196,
    81,
    7,
    11,
    0,
    8,
    98,
    0,
    8,
    34,
    0,
    9,
    164,
    0,
    8,
    2,
    0,
    8,
    130,
    0,
    8,
    66,
    0,
    9,
    228,
    80,
    7,
    7,
    0,
    8,
    90,
    0,
    8,
    26,
    0,
    9,
    148,
    84,
    7,
    67,
    0,
    8,
    122,
    0,
    8,
    58,
    0,
    9,
    212,
    82,
    7,
    19,
    0,
    8,
    106,
    0,
    8,
    42,
    0,
    9,
    180,
    0,
    8,
    10,
    0,
    8,
    138,
    0,
    8,
    74,
    0,
    9,
    244,
    80,
    7,
    5,
    0,
    8,
    86,
    0,
    8,
    22,
    192,
    8,
    0,
    83,
    7,
    51,
    0,
    8,
    118,
    0,
    8,
    54,
    0,
    9,
    204,
    81,
    7,
    15,
    0,
    8,
    102,
    0,
    8,
    38,
    0,
    9,
    172,
    0,
    8,
    6,
    0,
    8,
    134,
    0,
    8,
    70,
    0,
    9,
    236,
    80,
    7,
    9,
    0,
    8,
    94,
    0,
    8,
    30,
    0,
    9,
    156,
    84,
    7,
    99,
    0,
    8,
    126,
    0,
    8,
    62,
    0,
    9,
    220,
    82,
    7,
    27,
    0,
    8,
    110,
    0,
    8,
    46,
    0,
    9,
    188,
    0,
    8,
    14,
    0,
    8,
    142,
    0,
    8,
    78,
    0,
    9,
    252,
    96,
    7,
    256,
    0,
    8,
    81,
    0,
    8,
    17,
    85,
    8,
    131,
    82,
    7,
    31,
    0,
    8,
    113,
    0,
    8,
    49,
    0,
    9,
    194,
    80,
    7,
    10,
    0,
    8,
    97,
    0,
    8,
    33,
    0,
    9,
    162,
    0,
    8,
    1,
    0,
    8,
    129,
    0,
    8,
    65,
    0,
    9,
    226,
    80,
    7,
    6,
    0,
    8,
    89,
    0,
    8,
    25,
    0,
    9,
    146,
    83,
    7,
    59,
    0,
    8,
    121,
    0,
    8,
    57,
    0,
    9,
    210,
    81,
    7,
    17,
    0,
    8,
    105,
    0,
    8,
    41,
    0,
    9,
    178,
    0,
    8,
    9,
    0,
    8,
    137,
    0,
    8,
    73,
    0,
    9,
    242,
    80,
    7,
    4,
    0,
    8,
    85,
    0,
    8,
    21,
    80,
    8,
    258,
    83,
    7,
    43,
    0,
    8,
    117,
    0,
    8,
    53,
    0,
    9,
    202,
    81,
    7,
    13,
    0,
    8,
    101,
    0,
    8,
    37,
    0,
    9,
    170,
    0,
    8,
    5,
    0,
    8,
    133,
    0,
    8,
    69,
    0,
    9,
    234,
    80,
    7,
    8,
    0,
    8,
    93,
    0,
    8,
    29,
    0,
    9,
    154,
    84,
    7,
    83,
    0,
    8,
    125,
    0,
    8,
    61,
    0,
    9,
    218,
    82,
    7,
    23,
    0,
    8,
    109,
    0,
    8,
    45,
    0,
    9,
    186,
    0,
    8,
    13,
    0,
    8,
    141,
    0,
    8,
    77,
    0,
    9,
    250,
    80,
    7,
    3,
    0,
    8,
    83,
    0,
    8,
    19,
    85,
    8,
    195,
    83,
    7,
    35,
    0,
    8,
    115,
    0,
    8,
    51,
    0,
    9,
    198,
    81,
    7,
    11,
    0,
    8,
    99,
    0,
    8,
    35,
    0,
    9,
    166,
    0,
    8,
    3,
    0,
    8,
    131,
    0,
    8,
    67,
    0,
    9,
    230,
    80,
    7,
    7,
    0,
    8,
    91,
    0,
    8,
    27,
    0,
    9,
    150,
    84,
    7,
    67,
    0,
    8,
    123,
    0,
    8,
    59,
    0,
    9,
    214,
    82,
    7,
    19,
    0,
    8,
    107,
    0,
    8,
    43,
    0,
    9,
    182,
    0,
    8,
    11,
    0,
    8,
    139,
    0,
    8,
    75,
    0,
    9,
    246,
    80,
    7,
    5,
    0,
    8,
    87,
    0,
    8,
    23,
    192,
    8,
    0,
    83,
    7,
    51,
    0,
    8,
    119,
    0,
    8,
    55,
    0,
    9,
    206,
    81,
    7,
    15,
    0,
    8,
    103,
    0,
    8,
    39,
    0,
    9,
    174,
    0,
    8,
    7,
    0,
    8,
    135,
    0,
    8,
    71,
    0,
    9,
    238,
    80,
    7,
    9,
    0,
    8,
    95,
    0,
    8,
    31,
    0,
    9,
    158,
    84,
    7,
    99,
    0,
    8,
    127,
    0,
    8,
    63,
    0,
    9,
    222,
    82,
    7,
    27,
    0,
    8,
    111,
    0,
    8,
    47,
    0,
    9,
    190,
    0,
    8,
    15,
    0,
    8,
    143,
    0,
    8,
    79,
    0,
    9,
    254,
    96,
    7,
    256,
    0,
    8,
    80,
    0,
    8,
    16,
    84,
    8,
    115,
    82,
    7,
    31,
    0,
    8,
    112,
    0,
    8,
    48,
    0,
    9,
    193,
    80,
    7,
    10,
    0,
    8,
    96,
    0,
    8,
    32,
    0,
    9,
    161,
    0,
    8,
    0,
    0,
    8,
    128,
    0,
    8,
    64,
    0,
    9,
    225,
    80,
    7,
    6,
    0,
    8,
    88,
    0,
    8,
    24,
    0,
    9,
    145,
    83,
    7,
    59,
    0,
    8,
    120,
    0,
    8,
    56,
    0,
    9,
    209,
    81,
    7,
    17,
    0,
    8,
    104,
    0,
    8,
    40,
    0,
    9,
    177,
    0,
    8,
    8,
    0,
    8,
    136,
    0,
    8,
    72,
    0,
    9,
    241,
    80,
    7,
    4,
    0,
    8,
    84,
    0,
    8,
    20,
    85,
    8,
    227,
    83,
    7,
    43,
    0,
    8,
    116,
    0,
    8,
    52,
    0,
    9,
    201,
    81,
    7,
    13,
    0,
    8,
    100,
    0,
    8,
    36,
    0,
    9,
    169,
    0,
    8,
    4,
    0,
    8,
    132,
    0,
    8,
    68,
    0,
    9,
    233,
    80,
    7,
    8,
    0,
    8,
    92,
    0,
    8,
    28,
    0,
    9,
    153,
    84,
    7,
    83,
    0,
    8,
    124,
    0,
    8,
    60,
    0,
    9,
    217,
    82,
    7,
    23,
    0,
    8,
    108,
    0,
    8,
    44,
    0,
    9,
    185,
    0,
    8,
    12,
    0,
    8,
    140,
    0,
    8,
    76,
    0,
    9,
    249,
    80,
    7,
    3,
    0,
    8,
    82,
    0,
    8,
    18,
    85,
    8,
    163,
    83,
    7,
    35,
    0,
    8,
    114,
    0,
    8,
    50,
    0,
    9,
    197,
    81,
    7,
    11,
    0,
    8,
    98,
    0,
    8,
    34,
    0,
    9,
    165,
    0,
    8,
    2,
    0,
    8,
    130,
    0,
    8,
    66,
    0,
    9,
    229,
    80,
    7,
    7,
    0,
    8,
    90,
    0,
    8,
    26,
    0,
    9,
    149,
    84,
    7,
    67,
    0,
    8,
    122,
    0,
    8,
    58,
    0,
    9,
    213,
    82,
    7,
    19,
    0,
    8,
    106,
    0,
    8,
    42,
    0,
    9,
    181,
    0,
    8,
    10,
    0,
    8,
    138,
    0,
    8,
    74,
    0,
    9,
    245,
    80,
    7,
    5,
    0,
    8,
    86,
    0,
    8,
    22,
    192,
    8,
    0,
    83,
    7,
    51,
    0,
    8,
    118,
    0,
    8,
    54,
    0,
    9,
    205,
    81,
    7,
    15,
    0,
    8,
    102,
    0,
    8,
    38,
    0,
    9,
    173,
    0,
    8,
    6,
    0,
    8,
    134,
    0,
    8,
    70,
    0,
    9,
    237,
    80,
    7,
    9,
    0,
    8,
    94,
    0,
    8,
    30,
    0,
    9,
    157,
    84,
    7,
    99,
    0,
    8,
    126,
    0,
    8,
    62,
    0,
    9,
    221,
    82,
    7,
    27,
    0,
    8,
    110,
    0,
    8,
    46,
    0,
    9,
    189,
    0,
    8,
    14,
    0,
    8,
    142,
    0,
    8,
    78,
    0,
    9,
    253,
    96,
    7,
    256,
    0,
    8,
    81,
    0,
    8,
    17,
    85,
    8,
    131,
    82,
    7,
    31,
    0,
    8,
    113,
    0,
    8,
    49,
    0,
    9,
    195,
    80,
    7,
    10,
    0,
    8,
    97,
    0,
    8,
    33,
    0,
    9,
    163,
    0,
    8,
    1,
    0,
    8,
    129,
    0,
    8,
    65,
    0,
    9,
    227,
    80,
    7,
    6,
    0,
    8,
    89,
    0,
    8,
    25,
    0,
    9,
    147,
    83,
    7,
    59,
    0,
    8,
    121,
    0,
    8,
    57,
    0,
    9,
    211,
    81,
    7,
    17,
    0,
    8,
    105,
    0,
    8,
    41,
    0,
    9,
    179,
    0,
    8,
    9,
    0,
    8,
    137,
    0,
    8,
    73,
    0,
    9,
    243,
    80,
    7,
    4,
    0,
    8,
    85,
    0,
    8,
    21,
    80,
    8,
    258,
    83,
    7,
    43,
    0,
    8,
    117,
    0,
    8,
    53,
    0,
    9,
    203,
    81,
    7,
    13,
    0,
    8,
    101,
    0,
    8,
    37,
    0,
    9,
    171,
    0,
    8,
    5,
    0,
    8,
    133,
    0,
    8,
    69,
    0,
    9,
    235,
    80,
    7,
    8,
    0,
    8,
    93,
    0,
    8,
    29,
    0,
    9,
    155,
    84,
    7,
    83,
    0,
    8,
    125,
    0,
    8,
    61,
    0,
    9,
    219,
    82,
    7,
    23,
    0,
    8,
    109,
    0,
    8,
    45,
    0,
    9,
    187,
    0,
    8,
    13,
    0,
    8,
    141,
    0,
    8,
    77,
    0,
    9,
    251,
    80,
    7,
    3,
    0,
    8,
    83,
    0,
    8,
    19,
    85,
    8,
    195,
    83,
    7,
    35,
    0,
    8,
    115,
    0,
    8,
    51,
    0,
    9,
    199,
    81,
    7,
    11,
    0,
    8,
    99,
    0,
    8,
    35,
    0,
    9,
    167,
    0,
    8,
    3,
    0,
    8,
    131,
    0,
    8,
    67,
    0,
    9,
    231,
    80,
    7,
    7,
    0,
    8,
    91,
    0,
    8,
    27,
    0,
    9,
    151,
    84,
    7,
    67,
    0,
    8,
    123,
    0,
    8,
    59,
    0,
    9,
    215,
    82,
    7,
    19,
    0,
    8,
    107,
    0,
    8,
    43,
    0,
    9,
    183,
    0,
    8,
    11,
    0,
    8,
    139,
    0,
    8,
    75,
    0,
    9,
    247,
    80,
    7,
    5,
    0,
    8,
    87,
    0,
    8,
    23,
    192,
    8,
    0,
    83,
    7,
    51,
    0,
    8,
    119,
    0,
    8,
    55,
    0,
    9,
    207,
    81,
    7,
    15,
    0,
    8,
    103,
    0,
    8,
    39,
    0,
    9,
    175,
    0,
    8,
    7,
    0,
    8,
    135,
    0,
    8,
    71,
    0,
    9,
    239,
    80,
    7,
    9,
    0,
    8,
    95,
    0,
    8,
    31,
    0,
    9,
    159,
    84,
    7,
    99,
    0,
    8,
    127,
    0,
    8,
    63,
    0,
    9,
    223,
    82,
    7,
    27,
    0,
    8,
    111,
    0,
    8,
    47,
    0,
    9,
    191,
    0,
    8,
    15,
    0,
    8,
    143,
    0,
    8,
    79,
    0,
    9,
    255
  ];
  const fixed_td = [
    80,
    5,
    1,
    87,
    5,
    257,
    83,
    5,
    17,
    91,
    5,
    4097,
    81,
    5,
    5,
    89,
    5,
    1025,
    85,
    5,
    65,
    93,
    5,
    16385,
    80,
    5,
    3,
    88,
    5,
    513,
    84,
    5,
    33,
    92,
    5,
    8193,
    82,
    5,
    9,
    90,
    5,
    2049,
    86,
    5,
    129,
    192,
    5,
    24577,
    80,
    5,
    2,
    87,
    5,
    385,
    83,
    5,
    25,
    91,
    5,
    6145,
    81,
    5,
    7,
    89,
    5,
    1537,
    85,
    5,
    97,
    93,
    5,
    24577,
    80,
    5,
    4,
    88,
    5,
    769,
    84,
    5,
    49,
    92,
    5,
    12289,
    82,
    5,
    13,
    90,
    5,
    3073,
    86,
    5,
    193,
    192,
    5,
    24577
  ];
  const cplens = [
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  const cplext = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    112,
    112
  ];
  const cpdist = [
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577
  ];
  const cpdext = [
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13
  ];
  const BMAX = 15;
  function InfTree() {
    const that = this;
    let hn;
    let v;
    let c;
    let r;
    let u;
    let x;
    function huft_build(b, bindex, n, s, d, e2, t, m, hp, hn2, v2) {
      let a;
      let f;
      let g;
      let h;
      let i;
      let j;
      let k;
      let l;
      let mask;
      let p;
      let q;
      let w;
      let xp;
      let y;
      let z;
      p = 0;
      i = n;
      do {
        c[b[bindex + p]]++;
        p++;
        i--;
      } while (i !== 0);
      if (c[0] == n) {
        t[0] = -1;
        m[0] = 0;
        return Z_OK;
      }
      l = m[0];
      for (j = 1; j <= BMAX; j++)
        if (c[j] !== 0)
          break;
      k = j;
      if (l < j) {
        l = j;
      }
      for (i = BMAX; i !== 0; i--) {
        if (c[i] !== 0)
          break;
      }
      g = i;
      if (l > i) {
        l = i;
      }
      m[0] = l;
      for (y = 1 << j; j < i; j++, y <<= 1) {
        if ((y -= c[j]) < 0) {
          return Z_DATA_ERROR;
        }
      }
      if ((y -= c[i]) < 0) {
        return Z_DATA_ERROR;
      }
      c[i] += y;
      x[1] = j = 0;
      p = 1;
      xp = 2;
      while (--i !== 0) {
        x[xp] = j += c[p];
        xp++;
        p++;
      }
      i = 0;
      p = 0;
      do {
        if ((j = b[bindex + p]) !== 0) {
          v2[x[j]++] = i;
        }
        p++;
      } while (++i < n);
      n = x[g];
      x[0] = i = 0;
      p = 0;
      h = -1;
      w = -l;
      u[0] = 0;
      q = 0;
      z = 0;
      for (; k <= g; k++) {
        a = c[k];
        while (a-- !== 0) {
          while (k > w + l) {
            h++;
            w += l;
            z = g - w;
            z = z > l ? l : z;
            if ((f = 1 << (j = k - w)) > a + 1) {
              f -= a + 1;
              xp = k;
              if (j < z) {
                while (++j < z) {
                  if ((f <<= 1) <= c[++xp])
                    break;
                  f -= c[xp];
                }
              }
            }
            z = 1 << j;
            if (hn2[0] + z > MANY) {
              return Z_DATA_ERROR;
            }
            u[h] = q = hn2[0];
            hn2[0] += z;
            if (h !== 0) {
              x[h] = i;
              r[0] = j;
              r[1] = l;
              j = i >>> w - l;
              r[2] = q - u[h - 1] - j;
              hp.set(r, (u[h - 1] + j) * 3);
            } else {
              t[0] = q;
            }
          }
          r[1] = k - w;
          if (p >= n) {
            r[0] = 128 + 64;
          } else if (v2[p] < s) {
            r[0] = v2[p] < 256 ? 0 : 32 + 64;
            r[2] = v2[p++];
          } else {
            r[0] = e2[v2[p] - s] + 16 + 64;
            r[2] = d[v2[p++] - s];
          }
          f = 1 << k - w;
          for (j = i >>> w; j < z; j += f) {
            hp.set(r, (q + j) * 3);
          }
          for (j = 1 << k - 1; (i & j) !== 0; j >>>= 1) {
            i ^= j;
          }
          i ^= j;
          mask = (1 << w) - 1;
          while ((i & mask) != x[h]) {
            h--;
            w -= l;
            mask = (1 << w) - 1;
          }
        }
      }
      return y !== 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
    }
    function initWorkArea(vsize) {
      let i;
      if (!hn) {
        hn = [];
        v = [];
        c = new Int32Array(BMAX + 1);
        r = [];
        u = new Int32Array(BMAX);
        x = new Int32Array(BMAX + 1);
      }
      if (v.length < vsize) {
        v = [];
      }
      for (i = 0; i < vsize; i++) {
        v[i] = 0;
      }
      for (i = 0; i < BMAX + 1; i++) {
        c[i] = 0;
      }
      for (i = 0; i < 3; i++) {
        r[i] = 0;
      }
      u.set(c.subarray(0, BMAX), 0);
      x.set(c.subarray(0, BMAX + 1), 0);
    }
    that.inflate_trees_bits = function(c2, bb, tb, hp, z) {
      let result;
      initWorkArea(19);
      hn[0] = 0;
      result = huft_build(c2, 0, 19, 19, null, null, tb, bb, hp, hn, v);
      if (result == Z_DATA_ERROR) {
        z.msg = "oversubscribed dynamic bit lengths tree";
      } else if (result == Z_BUF_ERROR || bb[0] === 0) {
        z.msg = "incomplete dynamic bit lengths tree";
        result = Z_DATA_ERROR;
      }
      return result;
    };
    that.inflate_trees_dynamic = function(nl, nd, c2, bl, bd, tl, td, hp, z) {
      let result;
      initWorkArea(288);
      hn[0] = 0;
      result = huft_build(c2, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);
      if (result != Z_OK || bl[0] === 0) {
        if (result == Z_DATA_ERROR) {
          z.msg = "oversubscribed literal/length tree";
        } else if (result != Z_MEM_ERROR) {
          z.msg = "incomplete literal/length tree";
          result = Z_DATA_ERROR;
        }
        return result;
      }
      initWorkArea(288);
      result = huft_build(c2, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);
      if (result != Z_OK || bd[0] === 0 && nl > 257) {
        if (result == Z_DATA_ERROR) {
          z.msg = "oversubscribed distance tree";
        } else if (result == Z_BUF_ERROR) {
          z.msg = "incomplete distance tree";
          result = Z_DATA_ERROR;
        } else if (result != Z_MEM_ERROR) {
          z.msg = "empty distance tree with lengths";
          result = Z_DATA_ERROR;
        }
        return result;
      }
      return Z_OK;
    };
  }
  InfTree.inflate_trees_fixed = function(bl, bd, tl, td) {
    bl[0] = fixed_bl;
    bd[0] = fixed_bd;
    tl[0] = fixed_tl;
    td[0] = fixed_td;
    return Z_OK;
  };
  const START = 0;
  const LEN = 1;
  const LENEXT = 2;
  const DIST = 3;
  const DISTEXT = 4;
  const COPY = 5;
  const LIT = 6;
  const WASH = 7;
  const END = 8;
  const BADCODE = 9;
  function InfCodes() {
    const that = this;
    let mode2;
    let len = 0;
    let tree;
    let tree_index = 0;
    let need = 0;
    let lit = 0;
    let get = 0;
    let dist = 0;
    let lbits = 0;
    let dbits = 0;
    let ltree;
    let ltree_index = 0;
    let dtree;
    let dtree_index = 0;
    function inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {
      let t;
      let tp;
      let tp_index;
      let e2;
      let b;
      let k;
      let p;
      let n;
      let q;
      let m;
      let ml;
      let md;
      let c;
      let d;
      let r;
      let tp_index_t_3;
      p = z.next_in_index;
      n = z.avail_in;
      b = s.bitb;
      k = s.bitk;
      q = s.write;
      m = q < s.read ? s.read - q - 1 : s.end - q;
      ml = inflate_mask[bl];
      md = inflate_mask[bd];
      do {
        while (k < 20) {
          n--;
          b |= (z.read_byte(p++) & 255) << k;
          k += 8;
        }
        t = b & ml;
        tp = tl;
        tp_index = tl_index;
        tp_index_t_3 = (tp_index + t) * 3;
        if ((e2 = tp[tp_index_t_3]) === 0) {
          b >>= tp[tp_index_t_3 + 1];
          k -= tp[tp_index_t_3 + 1];
          s.win[q++] = tp[tp_index_t_3 + 2];
          m--;
          continue;
        }
        do {
          b >>= tp[tp_index_t_3 + 1];
          k -= tp[tp_index_t_3 + 1];
          if ((e2 & 16) !== 0) {
            e2 &= 15;
            c = tp[tp_index_t_3 + 2] + (b & inflate_mask[e2]);
            b >>= e2;
            k -= e2;
            while (k < 15) {
              n--;
              b |= (z.read_byte(p++) & 255) << k;
              k += 8;
            }
            t = b & md;
            tp = td;
            tp_index = td_index;
            tp_index_t_3 = (tp_index + t) * 3;
            e2 = tp[tp_index_t_3];
            do {
              b >>= tp[tp_index_t_3 + 1];
              k -= tp[tp_index_t_3 + 1];
              if ((e2 & 16) !== 0) {
                e2 &= 15;
                while (k < e2) {
                  n--;
                  b |= (z.read_byte(p++) & 255) << k;
                  k += 8;
                }
                d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e2]);
                b >>= e2;
                k -= e2;
                m -= c;
                if (q >= d) {
                  r = q - d;
                  if (q - r > 0 && 2 > q - r) {
                    s.win[q++] = s.win[r++];
                    s.win[q++] = s.win[r++];
                    c -= 2;
                  } else {
                    s.win.set(s.win.subarray(r, r + 2), q);
                    q += 2;
                    r += 2;
                    c -= 2;
                  }
                } else {
                  r = q - d;
                  do {
                    r += s.end;
                  } while (r < 0);
                  e2 = s.end - r;
                  if (c > e2) {
                    c -= e2;
                    if (q - r > 0 && e2 > q - r) {
                      do {
                        s.win[q++] = s.win[r++];
                      } while (--e2 !== 0);
                    } else {
                      s.win.set(s.win.subarray(r, r + e2), q);
                      q += e2;
                      r += e2;
                      e2 = 0;
                    }
                    r = 0;
                  }
                }
                if (q - r > 0 && c > q - r) {
                  do {
                    s.win[q++] = s.win[r++];
                  } while (--c !== 0);
                } else {
                  s.win.set(s.win.subarray(r, r + c), q);
                  q += c;
                  r += c;
                  c = 0;
                }
                break;
              } else if ((e2 & 64) === 0) {
                t += tp[tp_index_t_3 + 2];
                t += b & inflate_mask[e2];
                tp_index_t_3 = (tp_index + t) * 3;
                e2 = tp[tp_index_t_3];
              } else {
                z.msg = "invalid distance code";
                c = z.avail_in - n;
                c = k >> 3 < c ? k >> 3 : c;
                n += c;
                p -= c;
                k -= c << 3;
                s.bitb = b;
                s.bitk = k;
                z.avail_in = n;
                z.total_in += p - z.next_in_index;
                z.next_in_index = p;
                s.write = q;
                return Z_DATA_ERROR;
              }
            } while (true);
            break;
          }
          if ((e2 & 64) === 0) {
            t += tp[tp_index_t_3 + 2];
            t += b & inflate_mask[e2];
            tp_index_t_3 = (tp_index + t) * 3;
            if ((e2 = tp[tp_index_t_3]) === 0) {
              b >>= tp[tp_index_t_3 + 1];
              k -= tp[tp_index_t_3 + 1];
              s.win[q++] = tp[tp_index_t_3 + 2];
              m--;
              break;
            }
          } else if ((e2 & 32) !== 0) {
            c = z.avail_in - n;
            c = k >> 3 < c ? k >> 3 : c;
            n += c;
            p -= c;
            k -= c << 3;
            s.bitb = b;
            s.bitk = k;
            z.avail_in = n;
            z.total_in += p - z.next_in_index;
            z.next_in_index = p;
            s.write = q;
            return Z_STREAM_END;
          } else {
            z.msg = "invalid literal/length code";
            c = z.avail_in - n;
            c = k >> 3 < c ? k >> 3 : c;
            n += c;
            p -= c;
            k -= c << 3;
            s.bitb = b;
            s.bitk = k;
            z.avail_in = n;
            z.total_in += p - z.next_in_index;
            z.next_in_index = p;
            s.write = q;
            return Z_DATA_ERROR;
          }
        } while (true);
      } while (m >= 258 && n >= 10);
      c = z.avail_in - n;
      c = k >> 3 < c ? k >> 3 : c;
      n += c;
      p -= c;
      k -= c << 3;
      s.bitb = b;
      s.bitk = k;
      z.avail_in = n;
      z.total_in += p - z.next_in_index;
      z.next_in_index = p;
      s.write = q;
      return Z_OK;
    }
    that.init = function(bl, bd, tl, tl_index, td, td_index) {
      mode2 = START;
      lbits = bl;
      dbits = bd;
      ltree = tl;
      ltree_index = tl_index;
      dtree = td;
      dtree_index = td_index;
      tree = null;
    };
    that.proc = function(s, z, r) {
      let j;
      let tindex;
      let e2;
      let b = 0;
      let k = 0;
      let p = 0;
      let n;
      let q;
      let m;
      let f;
      p = z.next_in_index;
      n = z.avail_in;
      b = s.bitb;
      k = s.bitk;
      q = s.write;
      m = q < s.read ? s.read - q - 1 : s.end - q;
      while (true) {
        switch (mode2) {
          case START:
            if (m >= 258 && n >= 10) {
              s.bitb = b;
              s.bitk = k;
              z.avail_in = n;
              z.total_in += p - z.next_in_index;
              z.next_in_index = p;
              s.write = q;
              r = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);
              p = z.next_in_index;
              n = z.avail_in;
              b = s.bitb;
              k = s.bitk;
              q = s.write;
              m = q < s.read ? s.read - q - 1 : s.end - q;
              if (r != Z_OK) {
                mode2 = r == Z_STREAM_END ? WASH : BADCODE;
                break;
              }
            }
            need = lbits;
            tree = ltree;
            tree_index = ltree_index;
            mode2 = LEN;
          case LEN:
            j = need;
            while (k < j) {
              if (n !== 0)
                r = Z_OK;
              else {
                s.bitb = b;
                s.bitk = k;
                z.avail_in = n;
                z.total_in += p - z.next_in_index;
                z.next_in_index = p;
                s.write = q;
                return s.inflate_flush(z, r);
              }
              n--;
              b |= (z.read_byte(p++) & 255) << k;
              k += 8;
            }
            tindex = (tree_index + (b & inflate_mask[j])) * 3;
            b >>>= tree[tindex + 1];
            k -= tree[tindex + 1];
            e2 = tree[tindex];
            if (e2 === 0) {
              lit = tree[tindex + 2];
              mode2 = LIT;
              break;
            }
            if ((e2 & 16) !== 0) {
              get = e2 & 15;
              len = tree[tindex + 2];
              mode2 = LENEXT;
              break;
            }
            if ((e2 & 64) === 0) {
              need = e2;
              tree_index = tindex / 3 + tree[tindex + 2];
              break;
            }
            if ((e2 & 32) !== 0) {
              mode2 = WASH;
              break;
            }
            mode2 = BADCODE;
            z.msg = "invalid literal/length code";
            r = Z_DATA_ERROR;
            s.bitb = b;
            s.bitk = k;
            z.avail_in = n;
            z.total_in += p - z.next_in_index;
            z.next_in_index = p;
            s.write = q;
            return s.inflate_flush(z, r);
          case LENEXT:
            j = get;
            while (k < j) {
              if (n !== 0)
                r = Z_OK;
              else {
                s.bitb = b;
                s.bitk = k;
                z.avail_in = n;
                z.total_in += p - z.next_in_index;
                z.next_in_index = p;
                s.write = q;
                return s.inflate_flush(z, r);
              }
              n--;
              b |= (z.read_byte(p++) & 255) << k;
              k += 8;
            }
            len += b & inflate_mask[j];
            b >>= j;
            k -= j;
            need = dbits;
            tree = dtree;
            tree_index = dtree_index;
            mode2 = DIST;
          case DIST:
            j = need;
            while (k < j) {
              if (n !== 0)
                r = Z_OK;
              else {
                s.bitb = b;
                s.bitk = k;
                z.avail_in = n;
                z.total_in += p - z.next_in_index;
                z.next_in_index = p;
                s.write = q;
                return s.inflate_flush(z, r);
              }
              n--;
              b |= (z.read_byte(p++) & 255) << k;
              k += 8;
            }
            tindex = (tree_index + (b & inflate_mask[j])) * 3;
            b >>= tree[tindex + 1];
            k -= tree[tindex + 1];
            e2 = tree[tindex];
            if ((e2 & 16) !== 0) {
              get = e2 & 15;
              dist = tree[tindex + 2];
              mode2 = DISTEXT;
              break;
            }
            if ((e2 & 64) === 0) {
              need = e2;
              tree_index = tindex / 3 + tree[tindex + 2];
              break;
            }
            mode2 = BADCODE;
            z.msg = "invalid distance code";
            r = Z_DATA_ERROR;
            s.bitb = b;
            s.bitk = k;
            z.avail_in = n;
            z.total_in += p - z.next_in_index;
            z.next_in_index = p;
            s.write = q;
            return s.inflate_flush(z, r);
          case DISTEXT:
            j = get;
            while (k < j) {
              if (n !== 0)
                r = Z_OK;
              else {
                s.bitb = b;
                s.bitk = k;
                z.avail_in = n;
                z.total_in += p - z.next_in_index;
                z.next_in_index = p;
                s.write = q;
                return s.inflate_flush(z, r);
              }
              n--;
              b |= (z.read_byte(p++) & 255) << k;
              k += 8;
            }
            dist += b & inflate_mask[j];
            b >>= j;
            k -= j;
            mode2 = COPY;
          case COPY:
            f = q - dist;
            while (f < 0) {
              f += s.end;
            }
            while (len !== 0) {
              if (m === 0) {
                if (q == s.end && s.read !== 0) {
                  q = 0;
                  m = q < s.read ? s.read - q - 1 : s.end - q;
                }
                if (m === 0) {
                  s.write = q;
                  r = s.inflate_flush(z, r);
                  q = s.write;
                  m = q < s.read ? s.read - q - 1 : s.end - q;
                  if (q == s.end && s.read !== 0) {
                    q = 0;
                    m = q < s.read ? s.read - q - 1 : s.end - q;
                  }
                  if (m === 0) {
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return s.inflate_flush(z, r);
                  }
                }
              }
              s.win[q++] = s.win[f++];
              m--;
              if (f == s.end)
                f = 0;
              len--;
            }
            mode2 = START;
            break;
          case LIT:
            if (m === 0) {
              if (q == s.end && s.read !== 0) {
                q = 0;
                m = q < s.read ? s.read - q - 1 : s.end - q;
              }
              if (m === 0) {
                s.write = q;
                r = s.inflate_flush(z, r);
                q = s.write;
                m = q < s.read ? s.read - q - 1 : s.end - q;
                if (q == s.end && s.read !== 0) {
                  q = 0;
                  m = q < s.read ? s.read - q - 1 : s.end - q;
                }
                if (m === 0) {
                  s.bitb = b;
                  s.bitk = k;
                  z.avail_in = n;
                  z.total_in += p - z.next_in_index;
                  z.next_in_index = p;
                  s.write = q;
                  return s.inflate_flush(z, r);
                }
              }
            }
            r = Z_OK;
            s.win[q++] = lit;
            m--;
            mode2 = START;
            break;
          case WASH:
            if (k > 7) {
              k -= 8;
              n++;
              p--;
            }
            s.write = q;
            r = s.inflate_flush(z, r);
            q = s.write;
            m = q < s.read ? s.read - q - 1 : s.end - q;
            if (s.read != s.write) {
              s.bitb = b;
              s.bitk = k;
              z.avail_in = n;
              z.total_in += p - z.next_in_index;
              z.next_in_index = p;
              s.write = q;
              return s.inflate_flush(z, r);
            }
            mode2 = END;
          case END:
            r = Z_STREAM_END;
            s.bitb = b;
            s.bitk = k;
            z.avail_in = n;
            z.total_in += p - z.next_in_index;
            z.next_in_index = p;
            s.write = q;
            return s.inflate_flush(z, r);
          case BADCODE:
            r = Z_DATA_ERROR;
            s.bitb = b;
            s.bitk = k;
            z.avail_in = n;
            z.total_in += p - z.next_in_index;
            z.next_in_index = p;
            s.write = q;
            return s.inflate_flush(z, r);
          default:
            r = Z_STREAM_ERROR;
            s.bitb = b;
            s.bitk = k;
            z.avail_in = n;
            z.total_in += p - z.next_in_index;
            z.next_in_index = p;
            s.write = q;
            return s.inflate_flush(z, r);
        }
      }
    };
    that.free = function() {
    };
  }
  const border = [
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
  ];
  const TYPE = 0;
  const LENS = 1;
  const STORED = 2;
  const TABLE = 3;
  const BTREE = 4;
  const DTREE = 5;
  const CODES = 6;
  const DRY = 7;
  const DONELOCKS = 8;
  const BADBLOCKS = 9;
  function InfBlocks(z, w) {
    const that = this;
    let mode2 = TYPE;
    let left = 0;
    let table2 = 0;
    let index2 = 0;
    let blens;
    const bb = [0];
    const tb = [0];
    const codes = new InfCodes();
    let last = 0;
    let hufts = new Int32Array(MANY * 3);
    const check = 0;
    const inftree = new InfTree();
    that.bitk = 0;
    that.bitb = 0;
    that.win = new Uint8Array(w);
    that.end = w;
    that.read = 0;
    that.write = 0;
    that.reset = function(z2, c) {
      if (c)
        c[0] = check;
      if (mode2 == CODES) {
        codes.free(z2);
      }
      mode2 = TYPE;
      that.bitk = 0;
      that.bitb = 0;
      that.read = that.write = 0;
    };
    that.reset(z, null);
    that.inflate_flush = function(z2, r) {
      let n;
      let p;
      let q;
      p = z2.next_out_index;
      q = that.read;
      n = (q <= that.write ? that.write : that.end) - q;
      if (n > z2.avail_out)
        n = z2.avail_out;
      if (n !== 0 && r == Z_BUF_ERROR)
        r = Z_OK;
      z2.avail_out -= n;
      z2.total_out += n;
      z2.next_out.set(that.win.subarray(q, q + n), p);
      p += n;
      q += n;
      if (q == that.end) {
        q = 0;
        if (that.write == that.end)
          that.write = 0;
        n = that.write - q;
        if (n > z2.avail_out)
          n = z2.avail_out;
        if (n !== 0 && r == Z_BUF_ERROR)
          r = Z_OK;
        z2.avail_out -= n;
        z2.total_out += n;
        z2.next_out.set(that.win.subarray(q, q + n), p);
        p += n;
        q += n;
      }
      z2.next_out_index = p;
      that.read = q;
      return r;
    };
    that.proc = function(z2, r) {
      let t;
      let b;
      let k;
      let p;
      let n;
      let q;
      let m;
      let i;
      p = z2.next_in_index;
      n = z2.avail_in;
      b = that.bitb;
      k = that.bitk;
      q = that.write;
      m = q < that.read ? that.read - q - 1 : that.end - q;
      while (true) {
        let bl, bd, tl, td, bl_, bd_, tl_, td_;
        switch (mode2) {
          case TYPE:
            while (k < 3) {
              if (n !== 0) {
                r = Z_OK;
              } else {
                that.bitb = b;
                that.bitk = k;
                z2.avail_in = n;
                z2.total_in += p - z2.next_in_index;
                z2.next_in_index = p;
                that.write = q;
                return that.inflate_flush(z2, r);
              }
              n--;
              b |= (z2.read_byte(p++) & 255) << k;
              k += 8;
            }
            t = b & 7;
            last = t & 1;
            switch (t >>> 1) {
              case 0:
                b >>>= 3;
                k -= 3;
                t = k & 7;
                b >>>= t;
                k -= t;
                mode2 = LENS;
                break;
              case 1:
                bl = [];
                bd = [];
                tl = [[]];
                td = [[]];
                InfTree.inflate_trees_fixed(bl, bd, tl, td);
                codes.init(bl[0], bd[0], tl[0], 0, td[0], 0);
                b >>>= 3;
                k -= 3;
                mode2 = CODES;
                break;
              case 2:
                b >>>= 3;
                k -= 3;
                mode2 = TABLE;
                break;
              case 3:
                b >>>= 3;
                k -= 3;
                mode2 = BADBLOCKS;
                z2.msg = "invalid block type";
                r = Z_DATA_ERROR;
                that.bitb = b;
                that.bitk = k;
                z2.avail_in = n;
                z2.total_in += p - z2.next_in_index;
                z2.next_in_index = p;
                that.write = q;
                return that.inflate_flush(z2, r);
            }
            break;
          case LENS:
            while (k < 32) {
              if (n !== 0) {
                r = Z_OK;
              } else {
                that.bitb = b;
                that.bitk = k;
                z2.avail_in = n;
                z2.total_in += p - z2.next_in_index;
                z2.next_in_index = p;
                that.write = q;
                return that.inflate_flush(z2, r);
              }
              n--;
              b |= (z2.read_byte(p++) & 255) << k;
              k += 8;
            }
            if ((~b >>> 16 & 65535) != (b & 65535)) {
              mode2 = BADBLOCKS;
              z2.msg = "invalid stored block lengths";
              r = Z_DATA_ERROR;
              that.bitb = b;
              that.bitk = k;
              z2.avail_in = n;
              z2.total_in += p - z2.next_in_index;
              z2.next_in_index = p;
              that.write = q;
              return that.inflate_flush(z2, r);
            }
            left = b & 65535;
            b = k = 0;
            mode2 = left !== 0 ? STORED : last !== 0 ? DRY : TYPE;
            break;
          case STORED:
            if (n === 0) {
              that.bitb = b;
              that.bitk = k;
              z2.avail_in = n;
              z2.total_in += p - z2.next_in_index;
              z2.next_in_index = p;
              that.write = q;
              return that.inflate_flush(z2, r);
            }
            if (m === 0) {
              if (q == that.end && that.read !== 0) {
                q = 0;
                m = q < that.read ? that.read - q - 1 : that.end - q;
              }
              if (m === 0) {
                that.write = q;
                r = that.inflate_flush(z2, r);
                q = that.write;
                m = q < that.read ? that.read - q - 1 : that.end - q;
                if (q == that.end && that.read !== 0) {
                  q = 0;
                  m = q < that.read ? that.read - q - 1 : that.end - q;
                }
                if (m === 0) {
                  that.bitb = b;
                  that.bitk = k;
                  z2.avail_in = n;
                  z2.total_in += p - z2.next_in_index;
                  z2.next_in_index = p;
                  that.write = q;
                  return that.inflate_flush(z2, r);
                }
              }
            }
            r = Z_OK;
            t = left;
            if (t > n)
              t = n;
            if (t > m)
              t = m;
            that.win.set(z2.read_buf(p, t), q);
            p += t;
            n -= t;
            q += t;
            m -= t;
            if ((left -= t) !== 0)
              break;
            mode2 = last !== 0 ? DRY : TYPE;
            break;
          case TABLE:
            while (k < 14) {
              if (n !== 0) {
                r = Z_OK;
              } else {
                that.bitb = b;
                that.bitk = k;
                z2.avail_in = n;
                z2.total_in += p - z2.next_in_index;
                z2.next_in_index = p;
                that.write = q;
                return that.inflate_flush(z2, r);
              }
              n--;
              b |= (z2.read_byte(p++) & 255) << k;
              k += 8;
            }
            table2 = t = b & 16383;
            if ((t & 31) > 29 || (t >> 5 & 31) > 29) {
              mode2 = BADBLOCKS;
              z2.msg = "too many length or distance symbols";
              r = Z_DATA_ERROR;
              that.bitb = b;
              that.bitk = k;
              z2.avail_in = n;
              z2.total_in += p - z2.next_in_index;
              z2.next_in_index = p;
              that.write = q;
              return that.inflate_flush(z2, r);
            }
            t = 258 + (t & 31) + (t >> 5 & 31);
            if (!blens || blens.length < t) {
              blens = [];
            } else {
              for (i = 0; i < t; i++) {
                blens[i] = 0;
              }
            }
            b >>>= 14;
            k -= 14;
            index2 = 0;
            mode2 = BTREE;
          case BTREE:
            while (index2 < 4 + (table2 >>> 10)) {
              while (k < 3) {
                if (n !== 0) {
                  r = Z_OK;
                } else {
                  that.bitb = b;
                  that.bitk = k;
                  z2.avail_in = n;
                  z2.total_in += p - z2.next_in_index;
                  z2.next_in_index = p;
                  that.write = q;
                  return that.inflate_flush(z2, r);
                }
                n--;
                b |= (z2.read_byte(p++) & 255) << k;
                k += 8;
              }
              blens[border[index2++]] = b & 7;
              b >>>= 3;
              k -= 3;
            }
            while (index2 < 19) {
              blens[border[index2++]] = 0;
            }
            bb[0] = 7;
            t = inftree.inflate_trees_bits(blens, bb, tb, hufts, z2);
            if (t != Z_OK) {
              r = t;
              if (r == Z_DATA_ERROR) {
                blens = null;
                mode2 = BADBLOCKS;
              }
              that.bitb = b;
              that.bitk = k;
              z2.avail_in = n;
              z2.total_in += p - z2.next_in_index;
              z2.next_in_index = p;
              that.write = q;
              return that.inflate_flush(z2, r);
            }
            index2 = 0;
            mode2 = DTREE;
          case DTREE:
            while (true) {
              t = table2;
              if (index2 >= 258 + (t & 31) + (t >> 5 & 31)) {
                break;
              }
              let j, c;
              t = bb[0];
              while (k < t) {
                if (n !== 0) {
                  r = Z_OK;
                } else {
                  that.bitb = b;
                  that.bitk = k;
                  z2.avail_in = n;
                  z2.total_in += p - z2.next_in_index;
                  z2.next_in_index = p;
                  that.write = q;
                  return that.inflate_flush(z2, r);
                }
                n--;
                b |= (z2.read_byte(p++) & 255) << k;
                k += 8;
              }
              t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];
              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];
              if (c < 16) {
                b >>>= t;
                k -= t;
                blens[index2++] = c;
              } else {
                i = c == 18 ? 7 : c - 14;
                j = c == 18 ? 11 : 3;
                while (k < t + i) {
                  if (n !== 0) {
                    r = Z_OK;
                  } else {
                    that.bitb = b;
                    that.bitk = k;
                    z2.avail_in = n;
                    z2.total_in += p - z2.next_in_index;
                    z2.next_in_index = p;
                    that.write = q;
                    return that.inflate_flush(z2, r);
                  }
                  n--;
                  b |= (z2.read_byte(p++) & 255) << k;
                  k += 8;
                }
                b >>>= t;
                k -= t;
                j += b & inflate_mask[i];
                b >>>= i;
                k -= i;
                i = index2;
                t = table2;
                if (i + j > 258 + (t & 31) + (t >> 5 & 31) || c == 16 && i < 1) {
                  blens = null;
                  mode2 = BADBLOCKS;
                  z2.msg = "invalid bit length repeat";
                  r = Z_DATA_ERROR;
                  that.bitb = b;
                  that.bitk = k;
                  z2.avail_in = n;
                  z2.total_in += p - z2.next_in_index;
                  z2.next_in_index = p;
                  that.write = q;
                  return that.inflate_flush(z2, r);
                }
                c = c == 16 ? blens[i - 1] : 0;
                do {
                  blens[i++] = c;
                } while (--j !== 0);
                index2 = i;
              }
            }
            tb[0] = -1;
            bl_ = [];
            bd_ = [];
            tl_ = [];
            td_ = [];
            bl_[0] = 9;
            bd_[0] = 6;
            t = table2;
            t = inftree.inflate_trees_dynamic(257 + (t & 31), 1 + (t >> 5 & 31), blens, bl_, bd_, tl_, td_, hufts, z2);
            if (t != Z_OK) {
              if (t == Z_DATA_ERROR) {
                blens = null;
                mode2 = BADBLOCKS;
              }
              r = t;
              that.bitb = b;
              that.bitk = k;
              z2.avail_in = n;
              z2.total_in += p - z2.next_in_index;
              z2.next_in_index = p;
              that.write = q;
              return that.inflate_flush(z2, r);
            }
            codes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);
            mode2 = CODES;
          case CODES:
            that.bitb = b;
            that.bitk = k;
            z2.avail_in = n;
            z2.total_in += p - z2.next_in_index;
            z2.next_in_index = p;
            that.write = q;
            if ((r = codes.proc(that, z2, r)) != Z_STREAM_END) {
              return that.inflate_flush(z2, r);
            }
            r = Z_OK;
            codes.free(z2);
            p = z2.next_in_index;
            n = z2.avail_in;
            b = that.bitb;
            k = that.bitk;
            q = that.write;
            m = q < that.read ? that.read - q - 1 : that.end - q;
            if (last === 0) {
              mode2 = TYPE;
              break;
            }
            mode2 = DRY;
          case DRY:
            that.write = q;
            r = that.inflate_flush(z2, r);
            q = that.write;
            m = q < that.read ? that.read - q - 1 : that.end - q;
            if (that.read != that.write) {
              that.bitb = b;
              that.bitk = k;
              z2.avail_in = n;
              z2.total_in += p - z2.next_in_index;
              z2.next_in_index = p;
              that.write = q;
              return that.inflate_flush(z2, r);
            }
            mode2 = DONELOCKS;
          case DONELOCKS:
            r = Z_STREAM_END;
            that.bitb = b;
            that.bitk = k;
            z2.avail_in = n;
            z2.total_in += p - z2.next_in_index;
            z2.next_in_index = p;
            that.write = q;
            return that.inflate_flush(z2, r);
          case BADBLOCKS:
            r = Z_DATA_ERROR;
            that.bitb = b;
            that.bitk = k;
            z2.avail_in = n;
            z2.total_in += p - z2.next_in_index;
            z2.next_in_index = p;
            that.write = q;
            return that.inflate_flush(z2, r);
          default:
            r = Z_STREAM_ERROR;
            that.bitb = b;
            that.bitk = k;
            z2.avail_in = n;
            z2.total_in += p - z2.next_in_index;
            z2.next_in_index = p;
            that.write = q;
            return that.inflate_flush(z2, r);
        }
      }
    };
    that.free = function(z2) {
      that.reset(z2, null);
      that.win = null;
      hufts = null;
    };
    that.set_dictionary = function(d, start, n) {
      that.win.set(d.subarray(start, start + n), 0);
      that.read = that.write = n;
    };
    that.sync_point = function() {
      return mode2 == LENS ? 1 : 0;
    };
  }
  const PRESET_DICT = 32;
  const Z_DEFLATED = 8;
  const METHOD = 0;
  const FLAG = 1;
  const DICT4 = 2;
  const DICT3 = 3;
  const DICT2 = 4;
  const DICT1 = 5;
  const DICT0 = 6;
  const BLOCKS = 7;
  const DONE = 12;
  const BAD = 13;
  const mark = [0, 0, 255, 255];
  function Inflate() {
    const that = this;
    that.mode = 0;
    that.method = 0;
    that.was = [0];
    that.need = 0;
    that.marker = 0;
    that.wbits = 0;
    function inflateReset(z) {
      if (!z || !z.istate)
        return Z_STREAM_ERROR;
      z.total_in = z.total_out = 0;
      z.msg = null;
      z.istate.mode = BLOCKS;
      z.istate.blocks.reset(z, null);
      return Z_OK;
    }
    that.inflateEnd = function(z) {
      if (that.blocks)
        that.blocks.free(z);
      that.blocks = null;
      return Z_OK;
    };
    that.inflateInit = function(z, w) {
      z.msg = null;
      that.blocks = null;
      if (w < 8 || w > 15) {
        that.inflateEnd(z);
        return Z_STREAM_ERROR;
      }
      that.wbits = w;
      z.istate.blocks = new InfBlocks(z, 1 << w);
      inflateReset(z);
      return Z_OK;
    };
    that.inflate = function(z, f) {
      let r;
      let b;
      if (!z || !z.istate || !z.next_in)
        return Z_STREAM_ERROR;
      const istate = z.istate;
      f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
      r = Z_BUF_ERROR;
      while (true) {
        switch (istate.mode) {
          case METHOD:
            if (z.avail_in === 0)
              return r;
            r = f;
            z.avail_in--;
            z.total_in++;
            if (((istate.method = z.read_byte(z.next_in_index++)) & 15) != Z_DEFLATED) {
              istate.mode = BAD;
              z.msg = "unknown compression method";
              istate.marker = 5;
              break;
            }
            if ((istate.method >> 4) + 8 > istate.wbits) {
              istate.mode = BAD;
              z.msg = "invalid win size";
              istate.marker = 5;
              break;
            }
            istate.mode = FLAG;
          case FLAG:
            if (z.avail_in === 0)
              return r;
            r = f;
            z.avail_in--;
            z.total_in++;
            b = z.read_byte(z.next_in_index++) & 255;
            if (((istate.method << 8) + b) % 31 !== 0) {
              istate.mode = BAD;
              z.msg = "incorrect header check";
              istate.marker = 5;
              break;
            }
            if ((b & PRESET_DICT) === 0) {
              istate.mode = BLOCKS;
              break;
            }
            istate.mode = DICT4;
          case DICT4:
            if (z.avail_in === 0)
              return r;
            r = f;
            z.avail_in--;
            z.total_in++;
            istate.need = (z.read_byte(z.next_in_index++) & 255) << 24 & 4278190080;
            istate.mode = DICT3;
          case DICT3:
            if (z.avail_in === 0)
              return r;
            r = f;
            z.avail_in--;
            z.total_in++;
            istate.need += (z.read_byte(z.next_in_index++) & 255) << 16 & 16711680;
            istate.mode = DICT2;
          case DICT2:
            if (z.avail_in === 0)
              return r;
            r = f;
            z.avail_in--;
            z.total_in++;
            istate.need += (z.read_byte(z.next_in_index++) & 255) << 8 & 65280;
            istate.mode = DICT1;
          case DICT1:
            if (z.avail_in === 0)
              return r;
            r = f;
            z.avail_in--;
            z.total_in++;
            istate.need += z.read_byte(z.next_in_index++) & 255;
            istate.mode = DICT0;
            return Z_NEED_DICT;
          case DICT0:
            istate.mode = BAD;
            z.msg = "need dictionary";
            istate.marker = 0;
            return Z_STREAM_ERROR;
          case BLOCKS:
            r = istate.blocks.proc(z, r);
            if (r == Z_DATA_ERROR) {
              istate.mode = BAD;
              istate.marker = 0;
              break;
            }
            if (r == Z_OK) {
              r = f;
            }
            if (r != Z_STREAM_END) {
              return r;
            }
            r = f;
            istate.blocks.reset(z, istate.was);
            istate.mode = DONE;
          case DONE:
            z.avail_in = 0;
            return Z_STREAM_END;
          case BAD:
            return Z_DATA_ERROR;
          default:
            return Z_STREAM_ERROR;
        }
      }
    };
    that.inflateSetDictionary = function(z, dictionary, dictLength) {
      let index2 = 0, length = dictLength;
      if (!z || !z.istate || z.istate.mode != DICT0)
        return Z_STREAM_ERROR;
      const istate = z.istate;
      if (length >= 1 << istate.wbits) {
        length = (1 << istate.wbits) - 1;
        index2 = dictLength - length;
      }
      istate.blocks.set_dictionary(dictionary, index2, length);
      istate.mode = BLOCKS;
      return Z_OK;
    };
    that.inflateSync = function(z) {
      let n;
      let p;
      let m;
      let r, w;
      if (!z || !z.istate)
        return Z_STREAM_ERROR;
      const istate = z.istate;
      if (istate.mode != BAD) {
        istate.mode = BAD;
        istate.marker = 0;
      }
      if ((n = z.avail_in) === 0)
        return Z_BUF_ERROR;
      p = z.next_in_index;
      m = istate.marker;
      while (n !== 0 && m < 4) {
        if (z.read_byte(p) == mark[m]) {
          m++;
        } else if (z.read_byte(p) !== 0) {
          m = 0;
        } else {
          m = 4 - m;
        }
        p++;
        n--;
      }
      z.total_in += p - z.next_in_index;
      z.next_in_index = p;
      z.avail_in = n;
      istate.marker = m;
      if (m != 4) {
        return Z_DATA_ERROR;
      }
      r = z.total_in;
      w = z.total_out;
      inflateReset(z);
      z.total_in = r;
      z.total_out = w;
      istate.mode = BLOCKS;
      return Z_OK;
    };
    that.inflateSyncPoint = function(z) {
      if (!z || !z.istate || !z.istate.blocks)
        return Z_STREAM_ERROR;
      return z.istate.blocks.sync_point();
    };
  }
  function ZStream() {
  }
  ZStream.prototype = {
    inflateInit: function(bits2) {
      const that = this;
      that.istate = new Inflate();
      if (!bits2)
        bits2 = MAX_BITS;
      return that.istate.inflateInit(that, bits2);
    },
    inflate: function(f) {
      const that = this;
      if (!that.istate)
        return Z_STREAM_ERROR;
      return that.istate.inflate(that, f);
    },
    inflateEnd: function() {
      const that = this;
      if (!that.istate)
        return Z_STREAM_ERROR;
      const ret = that.istate.inflateEnd(that);
      that.istate = null;
      return ret;
    },
    inflateSync: function() {
      const that = this;
      if (!that.istate)
        return Z_STREAM_ERROR;
      return that.istate.inflateSync(that);
    },
    inflateSetDictionary: function(dictionary, dictLength) {
      const that = this;
      if (!that.istate)
        return Z_STREAM_ERROR;
      return that.istate.inflateSetDictionary(that, dictionary, dictLength);
    },
    read_byte: function(start) {
      const that = this;
      return that.next_in[start];
    },
    read_buf: function(start, size) {
      const that = this;
      return that.next_in.subarray(start, start + size);
    }
  };
  function ZipInflate2(options) {
    const that = this;
    const z = new ZStream();
    const bufsize = options && options.chunkSize ? Math.floor(options.chunkSize * 2) : 128 * 1024;
    const flush = Z_NO_FLUSH;
    const buf = new Uint8Array(bufsize);
    let nomoreinput = false;
    z.inflateInit();
    z.next_out = buf;
    that.append = function(data, onprogress) {
      const buffers = [];
      let err, array, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
      if (data.length === 0)
        return;
      z.next_in_index = 0;
      z.next_in = data;
      z.avail_in = data.length;
      do {
        z.next_out_index = 0;
        z.avail_out = bufsize;
        if (z.avail_in === 0 && !nomoreinput) {
          z.next_in_index = 0;
          nomoreinput = true;
        }
        err = z.inflate(flush);
        if (nomoreinput && err === Z_BUF_ERROR) {
          if (z.avail_in !== 0)
            throw new Error("inflating: bad input");
        } else if (err !== Z_OK && err !== Z_STREAM_END)
          throw new Error("inflating: " + z.msg);
        if ((nomoreinput || err === Z_STREAM_END) && z.avail_in === data.length)
          throw new Error("inflating: bad input");
        if (z.next_out_index)
          if (z.next_out_index === bufsize)
            buffers.push(new Uint8Array(buf));
          else
            buffers.push(buf.slice(0, z.next_out_index));
        bufferSize += z.next_out_index;
        if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
          onprogress(z.next_in_index);
          lastIndex = z.next_in_index;
        }
      } while (z.avail_in > 0 || z.avail_out === 0);
      if (buffers.length > 1) {
        array = new Uint8Array(bufferSize);
        buffers.forEach(function(chunk) {
          array.set(chunk, bufferIndex);
          bufferIndex += chunk.length;
        });
      } else {
        array = buffers[0] || new Uint8Array(0);
      }
      return array;
    };
    that.flush = function() {
      z.inflateEnd();
    };
  }
  return ZipInflate2;
})();
const MINIMUM_CHUNK_SIZE = 64;
const DEFAULT_CONFIGURATION = {
  chunkSize: 512 * 1024,
  maxWorkers: typeof navigator != "undefined" && navigator.hardwareConcurrency || 2,
  terminateWorkerTimeout: 5e3,
  useWebWorkers: true,
  workerScripts: void 0
};
const config = Object.assign({}, DEFAULT_CONFIGURATION);
function getConfiguration() {
  return config;
}
function getChunkSize(config2) {
  return Math.max(config2.chunkSize, MINIMUM_CHUNK_SIZE);
}
function configure(configuration) {
  if (configuration.baseURL !== void 0) {
    config.baseURL = configuration.baseURL;
  }
  if (configuration.chunkSize !== void 0) {
    config.chunkSize = configuration.chunkSize;
  }
  if (configuration.maxWorkers !== void 0) {
    config.maxWorkers = configuration.maxWorkers;
  }
  if (configuration.terminateWorkerTimeout !== void 0) {
    config.terminateWorkerTimeout = configuration.terminateWorkerTimeout;
  }
  if (configuration.useCompressionStream !== void 0) {
    config.useCompressionStream = configuration.useCompressionStream;
  }
  if (configuration.useWebWorkers !== void 0) {
    config.useWebWorkers = configuration.useWebWorkers;
  }
  if (configuration.Deflate !== void 0) {
    config.Deflate = configuration.Deflate;
  }
  if (configuration.Inflate !== void 0) {
    config.Inflate = configuration.Inflate;
  }
  if (configuration.workerScripts !== void 0) {
    if (configuration.workerScripts.deflate) {
      if (!Array.isArray(configuration.workerScripts.deflate)) {
        throw new Error("workerScripts.deflate must be an array");
      }
      if (!config.workerScripts) {
        config.workerScripts = {};
      }
      config.workerScripts.deflate = configuration.workerScripts.deflate;
    }
    if (configuration.workerScripts.inflate) {
      if (!Array.isArray(configuration.workerScripts.inflate)) {
        throw new Error("workerScripts.inflate must be an array");
      }
      if (!config.workerScripts) {
        config.workerScripts = {};
      }
      config.workerScripts.inflate = configuration.workerScripts.inflate;
    }
  }
}
const table$1 = {
  "application": {
    "andrew-inset": "ez",
    "annodex": "anx",
    "atom+xml": "atom",
    "atomcat+xml": "atomcat",
    "atomserv+xml": "atomsrv",
    "bbolin": "lin",
    "cap": ["cap", "pcap"],
    "cu-seeme": "cu",
    "davmount+xml": "davmount",
    "dsptype": "tsp",
    "ecmascript": ["es", "ecma"],
    "futuresplash": "spl",
    "hta": "hta",
    "java-archive": "jar",
    "java-serialized-object": "ser",
    "java-vm": "class",
    "javascript": "js",
    "m3g": "m3g",
    "mac-binhex40": "hqx",
    "mathematica": ["nb", "ma", "mb"],
    "msaccess": "mdb",
    "msword": ["doc", "dot"],
    "mxf": "mxf",
    "oda": "oda",
    "ogg": "ogx",
    "pdf": "pdf",
    "pgp-keys": "key",
    "pgp-signature": ["asc", "sig"],
    "pics-rules": "prf",
    "postscript": ["ps", "ai", "eps", "epsi", "epsf", "eps2", "eps3"],
    "rar": "rar",
    "rdf+xml": "rdf",
    "rss+xml": "rss",
    "rtf": "rtf",
    "smil": ["smi", "smil"],
    "xhtml+xml": ["xhtml", "xht"],
    "xml": ["xml", "xsl", "xsd"],
    "xspf+xml": "xspf",
    "zip": "zip",
    "vnd.android.package-archive": "apk",
    "vnd.cinderella": "cdy",
    "vnd.google-earth.kml+xml": "kml",
    "vnd.google-earth.kmz": "kmz",
    "vnd.mozilla.xul+xml": "xul",
    "vnd.ms-excel": ["xls", "xlb", "xlt", "xlm", "xla", "xlc", "xlw"],
    "vnd.ms-pki.seccat": "cat",
    "vnd.ms-pki.stl": "stl",
    "vnd.ms-powerpoint": ["ppt", "pps", "pot"],
    "vnd.oasis.opendocument.chart": "odc",
    "vnd.oasis.opendocument.database": "odb",
    "vnd.oasis.opendocument.formula": "odf",
    "vnd.oasis.opendocument.graphics": "odg",
    "vnd.oasis.opendocument.graphics-template": "otg",
    "vnd.oasis.opendocument.image": "odi",
    "vnd.oasis.opendocument.presentation": "odp",
    "vnd.oasis.opendocument.presentation-template": "otp",
    "vnd.oasis.opendocument.spreadsheet": "ods",
    "vnd.oasis.opendocument.spreadsheet-template": "ots",
    "vnd.oasis.opendocument.text": "odt",
    "vnd.oasis.opendocument.text-master": "odm",
    "vnd.oasis.opendocument.text-template": "ott",
    "vnd.oasis.opendocument.text-web": "oth",
    "vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
    "vnd.openxmlformats-officedocument.spreadsheetml.template": "xltx",
    "vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
    "vnd.openxmlformats-officedocument.presentationml.slideshow": "ppsx",
    "vnd.openxmlformats-officedocument.presentationml.template": "potx",
    "vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
    "vnd.openxmlformats-officedocument.wordprocessingml.template": "dotx",
    "vnd.smaf": "mmf",
    "vnd.stardivision.calc": "sdc",
    "vnd.stardivision.chart": "sds",
    "vnd.stardivision.draw": "sda",
    "vnd.stardivision.impress": "sdd",
    "vnd.stardivision.math": ["sdf", "smf"],
    "vnd.stardivision.writer": ["sdw", "vor"],
    "vnd.stardivision.writer-global": "sgl",
    "vnd.sun.xml.calc": "sxc",
    "vnd.sun.xml.calc.template": "stc",
    "vnd.sun.xml.draw": "sxd",
    "vnd.sun.xml.draw.template": "std",
    "vnd.sun.xml.impress": "sxi",
    "vnd.sun.xml.impress.template": "sti",
    "vnd.sun.xml.math": "sxm",
    "vnd.sun.xml.writer": "sxw",
    "vnd.sun.xml.writer.global": "sxg",
    "vnd.sun.xml.writer.template": "stw",
    "vnd.symbian.install": ["sis", "sisx"],
    "vnd.visio": ["vsd", "vst", "vss", "vsw"],
    "vnd.wap.wbxml": "wbxml",
    "vnd.wap.wmlc": "wmlc",
    "vnd.wap.wmlscriptc": "wmlsc",
    "vnd.wordperfect": "wpd",
    "vnd.wordperfect5.1": "wp5",
    "x-123": "wk",
    "x-7z-compressed": "7z",
    "x-abiword": "abw",
    "x-apple-diskimage": "dmg",
    "x-bcpio": "bcpio",
    "x-bittorrent": "torrent",
    "x-cbr": ["cbr", "cba", "cbt", "cb7"],
    "x-cbz": "cbz",
    "x-cdf": ["cdf", "cda"],
    "x-cdlink": "vcd",
    "x-chess-pgn": "pgn",
    "x-cpio": "cpio",
    "x-csh": "csh",
    "x-debian-package": ["deb", "udeb"],
    "x-director": ["dcr", "dir", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"],
    "x-dms": "dms",
    "x-doom": "wad",
    "x-dvi": "dvi",
    "x-httpd-eruby": "rhtml",
    "x-font": "pcf.Z",
    "x-freemind": "mm",
    "x-gnumeric": "gnumeric",
    "x-go-sgf": "sgf",
    "x-graphing-calculator": "gcf",
    "x-gtar": ["gtar", "taz"],
    "x-hdf": "hdf",
    "x-httpd-php": ["phtml", "pht", "php"],
    "x-httpd-php-source": "phps",
    "x-httpd-php3": "php3",
    "x-httpd-php3-preprocessed": "php3p",
    "x-httpd-php4": "php4",
    "x-httpd-php5": "php5",
    "x-ica": "ica",
    "x-info": "info",
    "x-internet-signup": ["ins", "isp"],
    "x-iphone": "iii",
    "x-iso9660-image": "iso",
    "x-java-jnlp-file": "jnlp",
    "x-jmol": "jmz",
    "x-killustrator": "kil",
    "x-koan": ["skp", "skd", "skt", "skm"],
    "x-kpresenter": ["kpr", "kpt"],
    "x-kword": ["kwd", "kwt"],
    "x-latex": "latex",
    "x-lha": "lha",
    "x-lyx": "lyx",
    "x-lzh": "lzh",
    "x-lzx": "lzx",
    "x-maker": ["frm", "maker", "frame", "fm", "fb", "book", "fbdoc"],
    "x-ms-wmd": "wmd",
    "x-ms-wmz": "wmz",
    "x-msdos-program": ["com", "exe", "bat", "dll"],
    "x-msi": "msi",
    "x-netcdf": ["nc", "cdf"],
    "x-ns-proxy-autoconfig": ["pac", "dat"],
    "x-nwc": "nwc",
    "x-object": "o",
    "x-oz-application": "oza",
    "x-pkcs7-certreqresp": "p7r",
    "x-python-code": ["pyc", "pyo"],
    "x-qgis": ["qgs", "shp", "shx"],
    "x-quicktimeplayer": "qtl",
    "x-redhat-package-manager": "rpm",
    "x-ruby": "rb",
    "x-sh": "sh",
    "x-shar": "shar",
    "x-shockwave-flash": ["swf", "swfl"],
    "x-silverlight": "scr",
    "x-stuffit": "sit",
    "x-sv4cpio": "sv4cpio",
    "x-sv4crc": "sv4crc",
    "x-tar": "tar",
    "x-tcl": "tcl",
    "x-tex-gf": "gf",
    "x-tex-pk": "pk",
    "x-texinfo": ["texinfo", "texi"],
    "x-trash": ["~", "%", "bak", "old", "sik"],
    "x-troff": ["t", "tr", "roff"],
    "x-troff-man": "man",
    "x-troff-me": "me",
    "x-troff-ms": "ms",
    "x-ustar": "ustar",
    "x-wais-source": "src",
    "x-wingz": "wz",
    "x-x509-ca-cert": ["crt", "der", "cer"],
    "x-xcf": "xcf",
    "x-xfig": "fig",
    "x-xpinstall": "xpi",
    "applixware": "aw",
    "atomsvc+xml": "atomsvc",
    "ccxml+xml": "ccxml",
    "cdmi-capability": "cdmia",
    "cdmi-container": "cdmic",
    "cdmi-domain": "cdmid",
    "cdmi-object": "cdmio",
    "cdmi-queue": "cdmiq",
    "docbook+xml": "dbk",
    "dssc+der": "dssc",
    "dssc+xml": "xdssc",
    "emma+xml": "emma",
    "epub+zip": "epub",
    "exi": "exi",
    "font-tdpfr": "pfr",
    "gml+xml": "gml",
    "gpx+xml": "gpx",
    "gxf": "gxf",
    "hyperstudio": "stk",
    "inkml+xml": ["ink", "inkml"],
    "ipfix": "ipfix",
    "json": "json",
    "jsonml+json": "jsonml",
    "lost+xml": "lostxml",
    "mads+xml": "mads",
    "marc": "mrc",
    "marcxml+xml": "mrcx",
    "mathml+xml": "mathml",
    "mbox": "mbox",
    "mediaservercontrol+xml": "mscml",
    "metalink+xml": "metalink",
    "metalink4+xml": "meta4",
    "mets+xml": "mets",
    "mods+xml": "mods",
    "mp21": ["m21", "mp21"],
    "mp4": "mp4s",
    "oebps-package+xml": "opf",
    "omdoc+xml": "omdoc",
    "onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"],
    "oxps": "oxps",
    "patch-ops-error+xml": "xer",
    "pgp-encrypted": "pgp",
    "pkcs10": "p10",
    "pkcs7-mime": ["p7m", "p7c"],
    "pkcs7-signature": "p7s",
    "pkcs8": "p8",
    "pkix-attr-cert": "ac",
    "pkix-crl": "crl",
    "pkix-pkipath": "pkipath",
    "pkixcmp": "pki",
    "pls+xml": "pls",
    "prs.cww": "cww",
    "pskc+xml": "pskcxml",
    "reginfo+xml": "rif",
    "relax-ng-compact-syntax": "rnc",
    "resource-lists+xml": "rl",
    "resource-lists-diff+xml": "rld",
    "rls-services+xml": "rs",
    "rpki-ghostbusters": "gbr",
    "rpki-manifest": "mft",
    "rpki-roa": "roa",
    "rsd+xml": "rsd",
    "sbml+xml": "sbml",
    "scvp-cv-request": "scq",
    "scvp-cv-response": "scs",
    "scvp-vp-request": "spq",
    "scvp-vp-response": "spp",
    "sdp": "sdp",
    "set-payment-initiation": "setpay",
    "set-registration-initiation": "setreg",
    "shf+xml": "shf",
    "sparql-query": "rq",
    "sparql-results+xml": "srx",
    "srgs": "gram",
    "srgs+xml": "grxml",
    "sru+xml": "sru",
    "ssdl+xml": "ssdl",
    "ssml+xml": "ssml",
    "tei+xml": ["tei", "teicorpus"],
    "thraud+xml": "tfi",
    "timestamped-data": "tsd",
    "vnd.3gpp.pic-bw-large": "plb",
    "vnd.3gpp.pic-bw-small": "psb",
    "vnd.3gpp.pic-bw-var": "pvb",
    "vnd.3gpp2.tcap": "tcap",
    "vnd.3m.post-it-notes": "pwn",
    "vnd.accpac.simply.aso": "aso",
    "vnd.accpac.simply.imp": "imp",
    "vnd.acucobol": "acu",
    "vnd.acucorp": ["atc", "acutc"],
    "vnd.adobe.air-application-installer-package+zip": "air",
    "vnd.adobe.formscentral.fcdt": "fcdt",
    "vnd.adobe.fxp": ["fxp", "fxpl"],
    "vnd.adobe.xdp+xml": "xdp",
    "vnd.adobe.xfdf": "xfdf",
    "vnd.ahead.space": "ahead",
    "vnd.airzip.filesecure.azf": "azf",
    "vnd.airzip.filesecure.azs": "azs",
    "vnd.amazon.ebook": "azw",
    "vnd.americandynamics.acc": "acc",
    "vnd.amiga.ami": "ami",
    "vnd.anser-web-certificate-issue-initiation": "cii",
    "vnd.anser-web-funds-transfer-initiation": "fti",
    "vnd.antix.game-component": "atx",
    "vnd.apple.installer+xml": "mpkg",
    "vnd.apple.mpegurl": "m3u8",
    "vnd.aristanetworks.swi": "swi",
    "vnd.astraea-software.iota": "iota",
    "vnd.audiograph": "aep",
    "vnd.blueice.multipass": "mpm",
    "vnd.bmi": "bmi",
    "vnd.businessobjects": "rep",
    "vnd.chemdraw+xml": "cdxml",
    "vnd.chipnuts.karaoke-mmd": "mmd",
    "vnd.claymore": "cla",
    "vnd.cloanto.rp9": "rp9",
    "vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"],
    "vnd.cluetrust.cartomobile-config": "c11amc",
    "vnd.cluetrust.cartomobile-config-pkg": "c11amz",
    "vnd.commonspace": "csp",
    "vnd.contact.cmsg": "cdbcmsg",
    "vnd.cosmocaller": "cmc",
    "vnd.crick.clicker": "clkx",
    "vnd.crick.clicker.keyboard": "clkk",
    "vnd.crick.clicker.palette": "clkp",
    "vnd.crick.clicker.template": "clkt",
    "vnd.crick.clicker.wordbank": "clkw",
    "vnd.criticaltools.wbs+xml": "wbs",
    "vnd.ctc-posml": "pml",
    "vnd.cups-ppd": "ppd",
    "vnd.curl.car": "car",
    "vnd.curl.pcurl": "pcurl",
    "vnd.dart": "dart",
    "vnd.data-vision.rdz": "rdz",
    "vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"],
    "vnd.dece.ttml+xml": ["uvt", "uvvt"],
    "vnd.dece.unspecified": ["uvx", "uvvx"],
    "vnd.dece.zip": ["uvz", "uvvz"],
    "vnd.denovo.fcselayout-link": "fe_launch",
    "vnd.dna": "dna",
    "vnd.dolby.mlp": "mlp",
    "vnd.dpgraph": "dpg",
    "vnd.dreamfactory": "dfac",
    "vnd.ds-keypoint": "kpxx",
    "vnd.dvb.ait": "ait",
    "vnd.dvb.service": "svc",
    "vnd.dynageo": "geo",
    "vnd.ecowin.chart": "mag",
    "vnd.enliven": "nml",
    "vnd.epson.esf": "esf",
    "vnd.epson.msf": "msf",
    "vnd.epson.quickanime": "qam",
    "vnd.epson.salt": "slt",
    "vnd.epson.ssf": "ssf",
    "vnd.eszigno3+xml": ["es3", "et3"],
    "vnd.ezpix-album": "ez2",
    "vnd.ezpix-package": "ez3",
    "vnd.fdf": "fdf",
    "vnd.fdsn.mseed": "mseed",
    "vnd.fdsn.seed": ["seed", "dataless"],
    "vnd.flographit": "gph",
    "vnd.fluxtime.clip": "ftc",
    "vnd.framemaker": ["fm", "frame", "maker", "book"],
    "vnd.frogans.fnc": "fnc",
    "vnd.frogans.ltf": "ltf",
    "vnd.fsc.weblaunch": "fsc",
    "vnd.fujitsu.oasys": "oas",
    "vnd.fujitsu.oasys2": "oa2",
    "vnd.fujitsu.oasys3": "oa3",
    "vnd.fujitsu.oasysgp": "fg5",
    "vnd.fujitsu.oasysprs": "bh2",
    "vnd.fujixerox.ddd": "ddd",
    "vnd.fujixerox.docuworks": "xdw",
    "vnd.fujixerox.docuworks.binder": "xbd",
    "vnd.fuzzysheet": "fzs",
    "vnd.genomatix.tuxedo": "txd",
    "vnd.geogebra.file": "ggb",
    "vnd.geogebra.tool": "ggt",
    "vnd.geometry-explorer": ["gex", "gre"],
    "vnd.geonext": "gxt",
    "vnd.geoplan": "g2w",
    "vnd.geospace": "g3w",
    "vnd.gmx": "gmx",
    "vnd.grafeq": ["gqf", "gqs"],
    "vnd.groove-account": "gac",
    "vnd.groove-help": "ghf",
    "vnd.groove-identity-message": "gim",
    "vnd.groove-injector": "grv",
    "vnd.groove-tool-message": "gtm",
    "vnd.groove-tool-template": "tpl",
    "vnd.groove-vcard": "vcg",
    "vnd.hal+xml": "hal",
    "vnd.handheld-entertainment+xml": "zmm",
    "vnd.hbci": "hbci",
    "vnd.hhe.lesson-player": "les",
    "vnd.hp-hpgl": "hpgl",
    "vnd.hp-hpid": "hpid",
    "vnd.hp-hps": "hps",
    "vnd.hp-jlyt": "jlt",
    "vnd.hp-pcl": "pcl",
    "vnd.hp-pclxl": "pclxl",
    "vnd.hydrostatix.sof-data": "sfd-hdstx",
    "vnd.ibm.minipay": "mpy",
    "vnd.ibm.modcap": ["afp", "listafp", "list3820"],
    "vnd.ibm.rights-management": "irm",
    "vnd.ibm.secure-container": "sc",
    "vnd.iccprofile": ["icc", "icm"],
    "vnd.igloader": "igl",
    "vnd.immervision-ivp": "ivp",
    "vnd.immervision-ivu": "ivu",
    "vnd.insors.igm": "igm",
    "vnd.intercon.formnet": ["xpw", "xpx"],
    "vnd.intergeo": "i2g",
    "vnd.intu.qbo": "qbo",
    "vnd.intu.qfx": "qfx",
    "vnd.ipunplugged.rcprofile": "rcprofile",
    "vnd.irepository.package+xml": "irp",
    "vnd.is-xpr": "xpr",
    "vnd.isac.fcs": "fcs",
    "vnd.jam": "jam",
    "vnd.jcp.javame.midlet-rms": "rms",
    "vnd.jisp": "jisp",
    "vnd.joost.joda-archive": "joda",
    "vnd.kahootz": ["ktz", "ktr"],
    "vnd.kde.karbon": "karbon",
    "vnd.kde.kchart": "chrt",
    "vnd.kde.kformula": "kfo",
    "vnd.kde.kivio": "flw",
    "vnd.kde.kontour": "kon",
    "vnd.kde.kpresenter": ["kpr", "kpt"],
    "vnd.kde.kspread": "ksp",
    "vnd.kde.kword": ["kwd", "kwt"],
    "vnd.kenameaapp": "htke",
    "vnd.kidspiration": "kia",
    "vnd.kinar": ["kne", "knp"],
    "vnd.koan": ["skp", "skd", "skt", "skm"],
    "vnd.kodak-descriptor": "sse",
    "vnd.las.las+xml": "lasxml",
    "vnd.llamagraphics.life-balance.desktop": "lbd",
    "vnd.llamagraphics.life-balance.exchange+xml": "lbe",
    "vnd.lotus-1-2-3": "123",
    "vnd.lotus-approach": "apr",
    "vnd.lotus-freelance": "pre",
    "vnd.lotus-notes": "nsf",
    "vnd.lotus-organizer": "org",
    "vnd.lotus-screencam": "scm",
    "vnd.lotus-wordpro": "lwp",
    "vnd.macports.portpkg": "portpkg",
    "vnd.mcd": "mcd",
    "vnd.medcalcdata": "mc1",
    "vnd.mediastation.cdkey": "cdkey",
    "vnd.mfer": "mwf",
    "vnd.mfmp": "mfm",
    "vnd.micrografx.flo": "flo",
    "vnd.micrografx.igx": "igx",
    "vnd.mif": "mif",
    "vnd.mobius.daf": "daf",
    "vnd.mobius.dis": "dis",
    "vnd.mobius.mbk": "mbk",
    "vnd.mobius.mqy": "mqy",
    "vnd.mobius.msl": "msl",
    "vnd.mobius.plc": "plc",
    "vnd.mobius.txf": "txf",
    "vnd.mophun.application": "mpn",
    "vnd.mophun.certificate": "mpc",
    "vnd.ms-artgalry": "cil",
    "vnd.ms-cab-compressed": "cab",
    "vnd.ms-excel.addin.macroenabled.12": "xlam",
    "vnd.ms-excel.sheet.binary.macroenabled.12": "xlsb",
    "vnd.ms-excel.sheet.macroenabled.12": "xlsm",
    "vnd.ms-excel.template.macroenabled.12": "xltm",
    "vnd.ms-fontobject": "eot",
    "vnd.ms-htmlhelp": "chm",
    "vnd.ms-ims": "ims",
    "vnd.ms-lrm": "lrm",
    "vnd.ms-officetheme": "thmx",
    "vnd.ms-powerpoint.addin.macroenabled.12": "ppam",
    "vnd.ms-powerpoint.presentation.macroenabled.12": "pptm",
    "vnd.ms-powerpoint.slide.macroenabled.12": "sldm",
    "vnd.ms-powerpoint.slideshow.macroenabled.12": "ppsm",
    "vnd.ms-powerpoint.template.macroenabled.12": "potm",
    "vnd.ms-project": ["mpp", "mpt"],
    "vnd.ms-word.document.macroenabled.12": "docm",
    "vnd.ms-word.template.macroenabled.12": "dotm",
    "vnd.ms-works": ["wps", "wks", "wcm", "wdb"],
    "vnd.ms-wpl": "wpl",
    "vnd.ms-xpsdocument": "xps",
    "vnd.mseq": "mseq",
    "vnd.musician": "mus",
    "vnd.muvee.style": "msty",
    "vnd.mynfc": "taglet",
    "vnd.neurolanguage.nlu": "nlu",
    "vnd.nitf": ["ntf", "nitf"],
    "vnd.noblenet-directory": "nnd",
    "vnd.noblenet-sealer": "nns",
    "vnd.noblenet-web": "nnw",
    "vnd.nokia.n-gage.data": "ngdat",
    "vnd.nokia.n-gage.symbian.install": "n-gage",
    "vnd.nokia.radio-preset": "rpst",
    "vnd.nokia.radio-presets": "rpss",
    "vnd.novadigm.edm": "edm",
    "vnd.novadigm.edx": "edx",
    "vnd.novadigm.ext": "ext",
    "vnd.oasis.opendocument.chart-template": "otc",
    "vnd.oasis.opendocument.formula-template": "odft",
    "vnd.oasis.opendocument.image-template": "oti",
    "vnd.olpc-sugar": "xo",
    "vnd.oma.dd2+xml": "dd2",
    "vnd.openofficeorg.extension": "oxt",
    "vnd.openxmlformats-officedocument.presentationml.slide": "sldx",
    "vnd.osgeo.mapguide.package": "mgp",
    "vnd.osgi.dp": "dp",
    "vnd.osgi.subsystem": "esa",
    "vnd.palm": ["pdb", "pqa", "oprc"],
    "vnd.pawaafile": "paw",
    "vnd.pg.format": "str",
    "vnd.pg.osasli": "ei6",
    "vnd.picsel": "efif",
    "vnd.pmi.widget": "wg",
    "vnd.pocketlearn": "plf",
    "vnd.powerbuilder6": "pbd",
    "vnd.previewsystems.box": "box",
    "vnd.proteus.magazine": "mgz",
    "vnd.publishare-delta-tree": "qps",
    "vnd.pvi.ptid1": "ptid",
    "vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"],
    "vnd.realvnc.bed": "bed",
    "vnd.recordare.musicxml": "mxl",
    "vnd.recordare.musicxml+xml": "musicxml",
    "vnd.rig.cryptonote": "cryptonote",
    "vnd.rn-realmedia": "rm",
    "vnd.rn-realmedia-vbr": "rmvb",
    "vnd.route66.link66+xml": "link66",
    "vnd.sailingtracker.track": "st",
    "vnd.seemail": "see",
    "vnd.sema": "sema",
    "vnd.semd": "semd",
    "vnd.semf": "semf",
    "vnd.shana.informed.formdata": "ifm",
    "vnd.shana.informed.formtemplate": "itp",
    "vnd.shana.informed.interchange": "iif",
    "vnd.shana.informed.package": "ipk",
    "vnd.simtech-mindmapper": ["twd", "twds"],
    "vnd.smart.teacher": "teacher",
    "vnd.solent.sdkm+xml": ["sdkm", "sdkd"],
    "vnd.spotfire.dxp": "dxp",
    "vnd.spotfire.sfs": "sfs",
    "vnd.stepmania.package": "smzip",
    "vnd.stepmania.stepchart": "sm",
    "vnd.sus-calendar": ["sus", "susp"],
    "vnd.svd": "svd",
    "vnd.syncml+xml": "xsm",
    "vnd.syncml.dm+wbxml": "bdm",
    "vnd.syncml.dm+xml": "xdm",
    "vnd.tao.intent-module-archive": "tao",
    "vnd.tcpdump.pcap": ["pcap", "cap", "dmp"],
    "vnd.tmobile-livetv": "tmo",
    "vnd.trid.tpt": "tpt",
    "vnd.triscape.mxs": "mxs",
    "vnd.trueapp": "tra",
    "vnd.ufdl": ["ufd", "ufdl"],
    "vnd.uiq.theme": "utz",
    "vnd.umajin": "umj",
    "vnd.unity": "unityweb",
    "vnd.uoml+xml": "uoml",
    "vnd.vcx": "vcx",
    "vnd.visionary": "vis",
    "vnd.vsf": "vsf",
    "vnd.webturbo": "wtb",
    "vnd.wolfram.player": "nbp",
    "vnd.wqd": "wqd",
    "vnd.wt.stf": "stf",
    "vnd.xara": "xar",
    "vnd.xfdl": "xfdl",
    "vnd.yamaha.hv-dic": "hvd",
    "vnd.yamaha.hv-script": "hvs",
    "vnd.yamaha.hv-voice": "hvp",
    "vnd.yamaha.openscoreformat": "osf",
    "vnd.yamaha.openscoreformat.osfpvg+xml": "osfpvg",
    "vnd.yamaha.smaf-audio": "saf",
    "vnd.yamaha.smaf-phrase": "spf",
    "vnd.yellowriver-custom-menu": "cmp",
    "vnd.zul": ["zir", "zirz"],
    "vnd.zzazz.deck+xml": "zaz",
    "voicexml+xml": "vxml",
    "widget": "wgt",
    "winhlp": "hlp",
    "wsdl+xml": "wsdl",
    "wspolicy+xml": "wspolicy",
    "x-ace-compressed": "ace",
    "x-authorware-bin": ["aab", "x32", "u32", "vox"],
    "x-authorware-map": "aam",
    "x-authorware-seg": "aas",
    "x-blorb": ["blb", "blorb"],
    "x-bzip": "bz",
    "x-bzip2": ["bz2", "boz"],
    "x-cfs-compressed": "cfs",
    "x-chat": "chat",
    "x-conference": "nsc",
    "x-dgc-compressed": "dgc",
    "x-dtbncx+xml": "ncx",
    "x-dtbook+xml": "dtb",
    "x-dtbresource+xml": "res",
    "x-eva": "eva",
    "x-font-bdf": "bdf",
    "x-font-ghostscript": "gsf",
    "x-font-linux-psf": "psf",
    "x-font-otf": "otf",
    "x-font-pcf": "pcf",
    "x-font-snf": "snf",
    "x-font-ttf": ["ttf", "ttc"],
    "x-font-type1": ["pfa", "pfb", "pfm", "afm"],
    "x-font-woff": "woff",
    "x-freearc": "arc",
    "x-gca-compressed": "gca",
    "x-glulx": "ulx",
    "x-gramps-xml": "gramps",
    "x-install-instructions": "install",
    "x-lzh-compressed": ["lzh", "lha"],
    "x-mie": "mie",
    "x-mobipocket-ebook": ["prc", "mobi"],
    "x-ms-application": "application",
    "x-ms-shortcut": "lnk",
    "x-ms-xbap": "xbap",
    "x-msbinder": "obd",
    "x-mscardfile": "crd",
    "x-msclip": "clp",
    "x-msdownload": ["exe", "dll", "com", "bat", "msi"],
    "x-msmediaview": ["mvb", "m13", "m14"],
    "x-msmetafile": ["wmf", "wmz", "emf", "emz"],
    "x-msmoney": "mny",
    "x-mspublisher": "pub",
    "x-msschedule": "scd",
    "x-msterminal": "trm",
    "x-mswrite": "wri",
    "x-nzb": "nzb",
    "x-pkcs12": ["p12", "pfx"],
    "x-pkcs7-certificates": ["p7b", "spc"],
    "x-research-info-systems": "ris",
    "x-silverlight-app": "xap",
    "x-sql": "sql",
    "x-stuffitx": "sitx",
    "x-subrip": "srt",
    "x-t3vm-image": "t3",
    "x-tads": "gam",
    "x-tex": "tex",
    "x-tex-tfm": "tfm",
    "x-tgif": "obj",
    "x-xliff+xml": "xlf",
    "x-xz": "xz",
    "x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
    "xaml+xml": "xaml",
    "xcap-diff+xml": "xdf",
    "xenc+xml": "xenc",
    "xml-dtd": "dtd",
    "xop+xml": "xop",
    "xproc+xml": "xpl",
    "xslt+xml": "xslt",
    "xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
    "yang": "yang",
    "yin+xml": "yin",
    "envoy": "evy",
    "fractals": "fif",
    "internet-property-stream": "acx",
    "olescript": "axs",
    "vnd.ms-outlook": "msg",
    "vnd.ms-pkicertstore": "sst",
    "x-compress": "z",
    "x-compressed": "tgz",
    "x-gzip": "gz",
    "x-perfmon": ["pma", "pmc", "pml", "pmr", "pmw"],
    "x-pkcs7-mime": ["p7c", "p7m"],
    "ynd.ms-pkipko": "pko"
  },
  "audio": {
    "amr": "amr",
    "amr-wb": "awb",
    "annodex": "axa",
    "basic": ["au", "snd"],
    "flac": "flac",
    "midi": ["mid", "midi", "kar", "rmi"],
    "mpeg": ["mpga", "mpega", "mp2", "mp3", "m4a", "mp2a", "m2a", "m3a"],
    "mpegurl": "m3u",
    "ogg": ["oga", "ogg", "spx"],
    "prs.sid": "sid",
    "x-aiff": ["aif", "aiff", "aifc"],
    "x-gsm": "gsm",
    "x-ms-wma": "wma",
    "x-ms-wax": "wax",
    "x-pn-realaudio": "ram",
    "x-realaudio": "ra",
    "x-sd2": "sd2",
    "x-wav": "wav",
    "adpcm": "adp",
    "mp4": "mp4a",
    "s3m": "s3m",
    "silk": "sil",
    "vnd.dece.audio": ["uva", "uvva"],
    "vnd.digital-winds": "eol",
    "vnd.dra": "dra",
    "vnd.dts": "dts",
    "vnd.dts.hd": "dtshd",
    "vnd.lucent.voice": "lvp",
    "vnd.ms-playready.media.pya": "pya",
    "vnd.nuera.ecelp4800": "ecelp4800",
    "vnd.nuera.ecelp7470": "ecelp7470",
    "vnd.nuera.ecelp9600": "ecelp9600",
    "vnd.rip": "rip",
    "webm": "weba",
    "x-aac": "aac",
    "x-caf": "caf",
    "x-matroska": "mka",
    "x-pn-realaudio-plugin": "rmp",
    "xm": "xm",
    "mid": ["mid", "rmi"]
  },
  "chemical": {
    "x-alchemy": "alc",
    "x-cache": ["cac", "cache"],
    "x-cache-csf": "csf",
    "x-cactvs-binary": ["cbin", "cascii", "ctab"],
    "x-cdx": "cdx",
    "x-chem3d": "c3d",
    "x-cif": "cif",
    "x-cmdf": "cmdf",
    "x-cml": "cml",
    "x-compass": "cpa",
    "x-crossfire": "bsd",
    "x-csml": ["csml", "csm"],
    "x-ctx": "ctx",
    "x-cxf": ["cxf", "cef"],
    "x-embl-dl-nucleotide": ["emb", "embl"],
    "x-gamess-input": ["inp", "gam", "gamin"],
    "x-gaussian-checkpoint": ["fch", "fchk"],
    "x-gaussian-cube": "cub",
    "x-gaussian-input": ["gau", "gjc", "gjf"],
    "x-gaussian-log": "gal",
    "x-gcg8-sequence": "gcg",
    "x-genbank": "gen",
    "x-hin": "hin",
    "x-isostar": ["istr", "ist"],
    "x-jcamp-dx": ["jdx", "dx"],
    "x-kinemage": "kin",
    "x-macmolecule": "mcm",
    "x-macromodel-input": ["mmd", "mmod"],
    "x-mdl-molfile": "mol",
    "x-mdl-rdfile": "rd",
    "x-mdl-rxnfile": "rxn",
    "x-mdl-sdfile": ["sd", "sdf"],
    "x-mdl-tgf": "tgf",
    "x-mmcif": "mcif",
    "x-mol2": "mol2",
    "x-molconn-Z": "b",
    "x-mopac-graph": "gpt",
    "x-mopac-input": ["mop", "mopcrt", "mpc", "zmt"],
    "x-mopac-out": "moo",
    "x-ncbi-asn1": "asn",
    "x-ncbi-asn1-ascii": ["prt", "ent"],
    "x-ncbi-asn1-binary": ["val", "aso"],
    "x-pdb": ["pdb", "ent"],
    "x-rosdal": "ros",
    "x-swissprot": "sw",
    "x-vamas-iso14976": "vms",
    "x-vmd": "vmd",
    "x-xtel": "xtel",
    "x-xyz": "xyz"
  },
  "image": {
    "gif": "gif",
    "ief": "ief",
    "jpeg": ["jpeg", "jpg", "jpe"],
    "pcx": "pcx",
    "png": "png",
    "svg+xml": ["svg", "svgz"],
    "tiff": ["tiff", "tif"],
    "vnd.djvu": ["djvu", "djv"],
    "vnd.wap.wbmp": "wbmp",
    "x-canon-cr2": "cr2",
    "x-canon-crw": "crw",
    "x-cmu-raster": "ras",
    "x-coreldraw": "cdr",
    "x-coreldrawpattern": "pat",
    "x-coreldrawtemplate": "cdt",
    "x-corelphotopaint": "cpt",
    "x-epson-erf": "erf",
    "x-icon": "ico",
    "x-jg": "art",
    "x-jng": "jng",
    "x-nikon-nef": "nef",
    "x-olympus-orf": "orf",
    "x-photoshop": "psd",
    "x-portable-anymap": "pnm",
    "x-portable-bitmap": "pbm",
    "x-portable-graymap": "pgm",
    "x-portable-pixmap": "ppm",
    "x-rgb": "rgb",
    "x-xbitmap": "xbm",
    "x-xpixmap": "xpm",
    "x-xwindowdump": "xwd",
    "bmp": "bmp",
    "cgm": "cgm",
    "g3fax": "g3",
    "ktx": "ktx",
    "prs.btif": "btif",
    "sgi": "sgi",
    "vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"],
    "vnd.dwg": "dwg",
    "vnd.dxf": "dxf",
    "vnd.fastbidsheet": "fbs",
    "vnd.fpx": "fpx",
    "vnd.fst": "fst",
    "vnd.fujixerox.edmics-mmr": "mmr",
    "vnd.fujixerox.edmics-rlc": "rlc",
    "vnd.ms-modi": "mdi",
    "vnd.ms-photo": "wdp",
    "vnd.net-fpx": "npx",
    "vnd.xiff": "xif",
    "webp": "webp",
    "x-3ds": "3ds",
    "x-cmx": "cmx",
    "x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"],
    "x-pict": ["pic", "pct"],
    "x-tga": "tga",
    "cis-cod": "cod",
    "pipeg": "jfif"
  },
  "message": {
    "rfc822": ["eml", "mime", "mht", "mhtml", "nws"]
  },
  "model": {
    "iges": ["igs", "iges"],
    "mesh": ["msh", "mesh", "silo"],
    "vrml": ["wrl", "vrml"],
    "x3d+vrml": ["x3dv", "x3dvz"],
    "x3d+xml": ["x3d", "x3dz"],
    "x3d+binary": ["x3db", "x3dbz"],
    "vnd.collada+xml": "dae",
    "vnd.dwf": "dwf",
    "vnd.gdl": "gdl",
    "vnd.gtw": "gtw",
    "vnd.mts": "mts",
    "vnd.vtu": "vtu"
  },
  "text": {
    "cache-manifest": ["manifest", "appcache"],
    "calendar": ["ics", "icz", "ifb"],
    "css": "css",
    "csv": "csv",
    "h323": "323",
    "html": ["html", "htm", "shtml", "stm"],
    "iuls": "uls",
    "mathml": "mml",
    "plain": ["txt", "text", "brf", "conf", "def", "list", "log", "in", "bas"],
    "richtext": "rtx",
    "scriptlet": ["sct", "wsc"],
    "texmacs": ["tm", "ts"],
    "tab-separated-values": "tsv",
    "vnd.sun.j2me.app-descriptor": "jad",
    "vnd.wap.wml": "wml",
    "vnd.wap.wmlscript": "wmls",
    "x-bibtex": "bib",
    "x-boo": "boo",
    "x-c++hdr": ["h++", "hpp", "hxx", "hh"],
    "x-c++src": ["c++", "cpp", "cxx", "cc"],
    "x-component": "htc",
    "x-dsrc": "d",
    "x-diff": ["diff", "patch"],
    "x-haskell": "hs",
    "x-java": "java",
    "x-literate-haskell": "lhs",
    "x-moc": "moc",
    "x-pascal": ["p", "pas"],
    "x-pcs-gcd": "gcd",
    "x-perl": ["pl", "pm"],
    "x-python": "py",
    "x-scala": "scala",
    "x-setext": "etx",
    "x-tcl": ["tcl", "tk"],
    "x-tex": ["tex", "ltx", "sty", "cls"],
    "x-vcalendar": "vcs",
    "x-vcard": "vcf",
    "n3": "n3",
    "prs.lines.tag": "dsc",
    "sgml": ["sgml", "sgm"],
    "troff": ["t", "tr", "roff", "man", "me", "ms"],
    "turtle": "ttl",
    "uri-list": ["uri", "uris", "urls"],
    "vcard": "vcard",
    "vnd.curl": "curl",
    "vnd.curl.dcurl": "dcurl",
    "vnd.curl.scurl": "scurl",
    "vnd.curl.mcurl": "mcurl",
    "vnd.dvb.subtitle": "sub",
    "vnd.fly": "fly",
    "vnd.fmi.flexstor": "flx",
    "vnd.graphviz": "gv",
    "vnd.in3d.3dml": "3dml",
    "vnd.in3d.spot": "spot",
    "x-asm": ["s", "asm"],
    "x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
    "x-fortran": ["f", "for", "f77", "f90"],
    "x-opml": "opml",
    "x-nfo": "nfo",
    "x-sfv": "sfv",
    "x-uuencode": "uu",
    "webviewhtml": "htt"
  },
  "video": {
    "avif": ".avif",
    "3gpp": "3gp",
    "annodex": "axv",
    "dl": "dl",
    "dv": ["dif", "dv"],
    "fli": "fli",
    "gl": "gl",
    "mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v", "mp2", "mpa", "mpv2"],
    "mp4": ["mp4", "mp4v", "mpg4"],
    "quicktime": ["qt", "mov"],
    "ogg": "ogv",
    "vnd.mpegurl": ["mxu", "m4u"],
    "x-flv": "flv",
    "x-la-asf": ["lsf", "lsx"],
    "x-mng": "mng",
    "x-ms-asf": ["asf", "asx", "asr"],
    "x-ms-wm": "wm",
    "x-ms-wmv": "wmv",
    "x-ms-wmx": "wmx",
    "x-ms-wvx": "wvx",
    "x-msvideo": "avi",
    "x-sgi-movie": "movie",
    "x-matroska": ["mpv", "mkv", "mk3d", "mks"],
    "3gpp2": "3g2",
    "h261": "h261",
    "h263": "h263",
    "h264": "h264",
    "jpeg": "jpgv",
    "jpm": ["jpm", "jpgm"],
    "mj2": ["mj2", "mjp2"],
    "vnd.dece.hd": ["uvh", "uvvh"],
    "vnd.dece.mobile": ["uvm", "uvvm"],
    "vnd.dece.pd": ["uvp", "uvvp"],
    "vnd.dece.sd": ["uvs", "uvvs"],
    "vnd.dece.video": ["uvv", "uvvv"],
    "vnd.dvb.file": "dvb",
    "vnd.fvt": "fvt",
    "vnd.ms-playready.media.pyv": "pyv",
    "vnd.uvvu.mp4": ["uvu", "uvvu"],
    "vnd.vivo": "viv",
    "webm": "webm",
    "x-f4v": "f4v",
    "x-m4v": "m4v",
    "x-ms-vob": "vob",
    "x-smv": "smv"
  },
  "x-conference": {
    "x-cooltalk": "ice"
  },
  "x-world": {
    "x-vrml": ["vrm", "vrml", "wrl", "flr", "wrz", "xaf", "xof"]
  }
};
(() => {
  const mimeTypes = {};
  for (const type in table$1) {
    if (table$1.hasOwnProperty(type)) {
      for (const subtype in table$1[type]) {
        if (table$1[type].hasOwnProperty(subtype)) {
          const value = table$1[type][subtype];
          if (typeof value == "string") {
            mimeTypes[value] = type + "/" + subtype;
          } else {
            for (let indexMimeType = 0; indexMimeType < value.length; indexMimeType++) {
              mimeTypes[value[indexMimeType]] = type + "/" + subtype;
            }
          }
        }
      }
    }
  }
  return mimeTypes;
})();
const table = [];
for (let i = 0; i < 256; i++) {
  let t = i;
  for (let j = 0; j < 8; j++) {
    if (t & 1) {
      t = t >>> 1 ^ 3988292384;
    } else {
      t = t >>> 1;
    }
  }
  table[i] = t;
}
class Crc32 {
  constructor(crc) {
    this.crc = crc || -1;
  }
  append(data) {
    let crc = this.crc | 0;
    for (let offset = 0, length = data.length | 0; offset < length; offset++) {
      crc = crc >>> 8 ^ table[(crc ^ data[offset]) & 255];
    }
    this.crc = crc;
  }
  get() {
    return ~this.crc;
  }
}
class Crc32Stream extends TransformStream {
  constructor() {
    super({
      start() {
        this.crc32 = new Crc32();
      },
      transform(chunk) {
        this.crc32.append(chunk);
      },
      flush(controller) {
        const value = new Uint8Array(4);
        const dataView = new DataView(value.buffer);
        dataView.setUint32(0, this.crc32.get());
        controller.enqueue(value);
      }
    });
  }
}
function encodeText(value) {
  if (typeof TextEncoder == "undefined") {
    value = unescape(encodeURIComponent(value));
    const result = new Uint8Array(value.length);
    for (let i = 0; i < result.length; i++) {
      result[i] = value.charCodeAt(i);
    }
    return result;
  } else {
    return new TextEncoder().encode(value);
  }
}
const bitArray = {
  concat(a1, a2) {
    if (a1.length === 0 || a2.length === 0) {
      return a1.concat(a2);
    }
    const last = a1[a1.length - 1], shift = bitArray.getPartial(last);
    if (shift === 32) {
      return a1.concat(a2);
    } else {
      return bitArray._shiftRight(a2, shift, last | 0, a1.slice(0, a1.length - 1));
    }
  },
  bitLength(a) {
    const l = a.length;
    if (l === 0) {
      return 0;
    }
    const x = a[l - 1];
    return (l - 1) * 32 + bitArray.getPartial(x);
  },
  clamp(a, len) {
    if (a.length * 32 < len) {
      return a;
    }
    a = a.slice(0, Math.ceil(len / 32));
    const l = a.length;
    len = len & 31;
    if (l > 0 && len) {
      a[l - 1] = bitArray.partial(len, a[l - 1] & 2147483648 >> len - 1, 1);
    }
    return a;
  },
  partial(len, x, _end) {
    if (len === 32) {
      return x;
    }
    return (_end ? x | 0 : x << 32 - len) + len * 1099511627776;
  },
  getPartial(x) {
    return Math.round(x / 1099511627776) || 32;
  },
  _shiftRight(a, shift, carry, out) {
    if (out === void 0) {
      out = [];
    }
    for (; shift >= 32; shift -= 32) {
      out.push(carry);
      carry = 0;
    }
    if (shift === 0) {
      return out.concat(a);
    }
    for (let i = 0; i < a.length; i++) {
      out.push(carry | a[i] >>> shift);
      carry = a[i] << 32 - shift;
    }
    const last2 = a.length ? a[a.length - 1] : 0;
    const shift2 = bitArray.getPartial(last2);
    out.push(bitArray.partial(shift + shift2 & 31, shift + shift2 > 32 ? carry : out.pop(), 1));
    return out;
  }
};
const codec = {
  bytes: {
    fromBits(arr) {
      const bl = bitArray.bitLength(arr);
      const byteLength2 = bl / 8;
      const out = new Uint8Array(byteLength2);
      let tmp;
      for (let i = 0; i < byteLength2; i++) {
        if ((i & 3) === 0) {
          tmp = arr[i / 4];
        }
        out[i] = tmp >>> 24;
        tmp <<= 8;
      }
      return out;
    },
    toBits(bytes) {
      const out = [];
      let i;
      let tmp = 0;
      for (i = 0; i < bytes.length; i++) {
        tmp = tmp << 8 | bytes[i];
        if ((i & 3) === 3) {
          out.push(tmp);
          tmp = 0;
        }
      }
      if (i & 3) {
        out.push(bitArray.partial(8 * (i & 3), tmp));
      }
      return out;
    }
  }
};
const hash = {};
hash.sha1 = function(hash2) {
  if (hash2) {
    this._h = hash2._h.slice(0);
    this._buffer = hash2._buffer.slice(0);
    this._length = hash2._length;
  } else {
    this.reset();
  }
};
hash.sha1.prototype = {
  blockSize: 512,
  reset: function() {
    const sha1 = this;
    sha1._h = this._init.slice(0);
    sha1._buffer = [];
    sha1._length = 0;
    return sha1;
  },
  update: function(data) {
    const sha1 = this;
    if (typeof data === "string") {
      data = codec.utf8String.toBits(data);
    }
    const b = sha1._buffer = bitArray.concat(sha1._buffer, data);
    const ol = sha1._length;
    const nl = sha1._length = ol + bitArray.bitLength(data);
    if (nl > 9007199254740991) {
      throw new Error("Cannot hash more than 2^53 - 1 bits");
    }
    const c = new Uint32Array(b);
    let j = 0;
    for (let i = sha1.blockSize + ol - (sha1.blockSize + ol & sha1.blockSize - 1); i <= nl; i += sha1.blockSize) {
      sha1._block(c.subarray(16 * j, 16 * (j + 1)));
      j += 1;
    }
    b.splice(0, 16 * j);
    return sha1;
  },
  finalize: function() {
    const sha1 = this;
    let b = sha1._buffer;
    const h = sha1._h;
    b = bitArray.concat(b, [bitArray.partial(1, 1)]);
    for (let i = b.length + 2; i & 15; i++) {
      b.push(0);
    }
    b.push(Math.floor(sha1._length / 4294967296));
    b.push(sha1._length | 0);
    while (b.length) {
      sha1._block(b.splice(0, 16));
    }
    sha1.reset();
    return h;
  },
  _init: [1732584193, 4023233417, 2562383102, 271733878, 3285377520],
  _key: [1518500249, 1859775393, 2400959708, 3395469782],
  _f: function(t, b, c, d) {
    if (t <= 19) {
      return b & c | ~b & d;
    } else if (t <= 39) {
      return b ^ c ^ d;
    } else if (t <= 59) {
      return b & c | b & d | c & d;
    } else if (t <= 79) {
      return b ^ c ^ d;
    }
  },
  _S: function(n, x) {
    return x << n | x >>> 32 - n;
  },
  _block: function(words) {
    const sha1 = this;
    const h = sha1._h;
    const w = Array(80);
    for (let j = 0; j < 16; j++) {
      w[j] = words[j];
    }
    let a = h[0];
    let b = h[1];
    let c = h[2];
    let d = h[3];
    let e2 = h[4];
    for (let t = 0; t <= 79; t++) {
      if (t >= 16) {
        w[t] = sha1._S(1, w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16]);
      }
      const tmp = sha1._S(5, a) + sha1._f(t, b, c, d) + e2 + w[t] + sha1._key[Math.floor(t / 20)] | 0;
      e2 = d;
      d = c;
      c = sha1._S(30, b);
      b = a;
      a = tmp;
    }
    h[0] = h[0] + a | 0;
    h[1] = h[1] + b | 0;
    h[2] = h[2] + c | 0;
    h[3] = h[3] + d | 0;
    h[4] = h[4] + e2 | 0;
  }
};
const cipher = {};
cipher.aes = class {
  constructor(key) {
    const aes = this;
    aes._tables = [[[], [], [], [], []], [[], [], [], [], []]];
    if (!aes._tables[0][0][0]) {
      aes._precompute();
    }
    const sbox = aes._tables[0][4];
    const decTable = aes._tables[1];
    const keyLen = key.length;
    let i, encKey, decKey, rcon = 1;
    if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
      throw new Error("invalid aes key size");
    }
    aes._key = [encKey = key.slice(0), decKey = []];
    for (i = keyLen; i < 4 * keyLen + 28; i++) {
      let tmp = encKey[i - 1];
      if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
        tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
        if (i % keyLen === 0) {
          tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
          rcon = rcon << 1 ^ (rcon >> 7) * 283;
        }
      }
      encKey[i] = encKey[i - keyLen] ^ tmp;
    }
    for (let j = 0; i; j++, i--) {
      const tmp = encKey[j & 3 ? i : i - 4];
      if (i <= 4 || j < 4) {
        decKey[j] = tmp;
      } else {
        decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
      }
    }
  }
  encrypt(data) {
    return this._crypt(data, 0);
  }
  decrypt(data) {
    return this._crypt(data, 1);
  }
  _precompute() {
    const encTable = this._tables[0];
    const decTable = this._tables[1];
    const sbox = encTable[4];
    const sboxInv = decTable[4];
    const d = [];
    const th = [];
    let xInv, x2, x4, x8;
    for (let i = 0; i < 256; i++) {
      th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
    }
    for (let x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
      let s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
      s = s >> 8 ^ s & 255 ^ 99;
      sbox[x] = s;
      sboxInv[s] = x;
      x8 = d[x4 = d[x2 = d[x]]];
      let tDec = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
      let tEnc = d[s] * 257 ^ s * 16843008;
      for (let i = 0; i < 4; i++) {
        encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
        decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
      }
    }
    for (let i = 0; i < 5; i++) {
      encTable[i] = encTable[i].slice(0);
      decTable[i] = decTable[i].slice(0);
    }
  }
  _crypt(input, dir) {
    if (input.length !== 4) {
      throw new Error("invalid aes block size");
    }
    const key = this._key[dir];
    const nInnerRounds = key.length / 4 - 2;
    const out = [0, 0, 0, 0];
    const table2 = this._tables[dir];
    const t0 = table2[0];
    const t1 = table2[1];
    const t2 = table2[2];
    const t3 = table2[3];
    const sbox = table2[4];
    let a = input[0] ^ key[0];
    let b = input[dir ? 3 : 1] ^ key[1];
    let c = input[2] ^ key[2];
    let d = input[dir ? 1 : 3] ^ key[3];
    let kIndex = 4;
    let a2, b2, c2;
    for (let i = 0; i < nInnerRounds; i++) {
      a2 = t0[a >>> 24] ^ t1[b >> 16 & 255] ^ t2[c >> 8 & 255] ^ t3[d & 255] ^ key[kIndex];
      b2 = t0[b >>> 24] ^ t1[c >> 16 & 255] ^ t2[d >> 8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
      c2 = t0[c >>> 24] ^ t1[d >> 16 & 255] ^ t2[a >> 8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
      d = t0[d >>> 24] ^ t1[a >> 16 & 255] ^ t2[b >> 8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
      kIndex += 4;
      a = a2;
      b = b2;
      c = c2;
    }
    for (let i = 0; i < 4; i++) {
      out[dir ? 3 & -i : i] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];
      a2 = a;
      a = b;
      b = c;
      c = d;
      d = a2;
    }
    return out;
  }
};
const random = {
  getRandomValues(typedArray) {
    const words = new Uint32Array(typedArray.buffer);
    const r = (m_w) => {
      let m_z = 987654321;
      const mask = 4294967295;
      return function() {
        m_z = 36969 * (m_z & 65535) + (m_z >> 16) & mask;
        m_w = 18e3 * (m_w & 65535) + (m_w >> 16) & mask;
        const result = ((m_z << 16) + m_w & mask) / 4294967296 + 0.5;
        return result * (Math.random() > 0.5 ? 1 : -1);
      };
    };
    for (let i = 0, rcache; i < typedArray.length; i += 4) {
      const _r = r((rcache || Math.random()) * 4294967296);
      rcache = _r() * 987654071;
      words[i / 4] = _r() * 4294967296 | 0;
    }
    return typedArray;
  }
};
const mode = {};
mode.ctrGladman = class {
  constructor(prf, iv) {
    this._prf = prf;
    this._initIv = iv;
    this._iv = iv;
  }
  reset() {
    this._iv = this._initIv;
  }
  update(data) {
    return this.calculate(this._prf, data, this._iv);
  }
  incWord(word) {
    if ((word >> 24 & 255) === 255) {
      let b1 = word >> 16 & 255;
      let b2 = word >> 8 & 255;
      let b3 = word & 255;
      if (b1 === 255) {
        b1 = 0;
        if (b2 === 255) {
          b2 = 0;
          if (b3 === 255) {
            b3 = 0;
          } else {
            ++b3;
          }
        } else {
          ++b2;
        }
      } else {
        ++b1;
      }
      word = 0;
      word += b1 << 16;
      word += b2 << 8;
      word += b3;
    } else {
      word += 1 << 24;
    }
    return word;
  }
  incCounter(counter) {
    if ((counter[0] = this.incWord(counter[0])) === 0) {
      counter[1] = this.incWord(counter[1]);
    }
  }
  calculate(prf, data, iv) {
    let l;
    if (!(l = data.length)) {
      return [];
    }
    const bl = bitArray.bitLength(data);
    for (let i = 0; i < l; i += 4) {
      this.incCounter(iv);
      const e2 = prf.encrypt(iv);
      data[i] ^= e2[0];
      data[i + 1] ^= e2[1];
      data[i + 2] ^= e2[2];
      data[i + 3] ^= e2[3];
    }
    return bitArray.clamp(data, bl);
  }
};
const misc = {
  importKey(password) {
    return new misc.hmacSha1(codec.bytes.toBits(password));
  },
  pbkdf2(prf, salt, count, length) {
    count = count || 1e4;
    if (length < 0 || count < 0) {
      throw new Error("invalid params to pbkdf2");
    }
    const byteLength2 = (length >> 5) + 1 << 2;
    let u, ui, i, j, k;
    const arrayBuffer = new ArrayBuffer(byteLength2);
    const out = new DataView(arrayBuffer);
    let outLength = 0;
    const b = bitArray;
    salt = codec.bytes.toBits(salt);
    for (k = 1; outLength < (byteLength2 || 1); k++) {
      u = ui = prf.encrypt(b.concat(salt, [k]));
      for (i = 1; i < count; i++) {
        ui = prf.encrypt(ui);
        for (j = 0; j < ui.length; j++) {
          u[j] ^= ui[j];
        }
      }
      for (i = 0; outLength < (byteLength2 || 1) && i < u.length; i++) {
        out.setInt32(outLength, u[i]);
        outLength += 4;
      }
    }
    return arrayBuffer.slice(0, length / 8);
  }
};
misc.hmacSha1 = class {
  constructor(key) {
    const hmac = this;
    const Hash = hmac._hash = hash.sha1;
    const exKey = [[], []];
    const bs = Hash.prototype.blockSize / 32;
    hmac._baseHash = [new Hash(), new Hash()];
    if (key.length > bs) {
      key = Hash.hash(key);
    }
    for (let i = 0; i < bs; i++) {
      exKey[0][i] = key[i] ^ 909522486;
      exKey[1][i] = key[i] ^ 1549556828;
    }
    hmac._baseHash[0].update(exKey[0]);
    hmac._baseHash[1].update(exKey[1]);
    hmac._resultHash = new Hash(hmac._baseHash[0]);
  }
  reset() {
    const hmac = this;
    hmac._resultHash = new hmac._hash(hmac._baseHash[0]);
    hmac._updated = false;
  }
  update(data) {
    const hmac = this;
    hmac._updated = true;
    hmac._resultHash.update(data);
  }
  digest() {
    const hmac = this;
    const w = hmac._resultHash.finalize();
    const result = new hmac._hash(hmac._baseHash[1]).update(w).finalize();
    hmac.reset();
    return result;
  }
  encrypt(data) {
    if (!this._updated) {
      this.update(data);
      return this.digest(data);
    } else {
      throw new Error("encrypt on already updated hmac called!");
    }
  }
};
const ERR_INVALID_PASSWORD = "Invalid pasword";
const BLOCK_LENGTH = 16;
const RAW_FORMAT = "raw";
const PBKDF2_ALGORITHM = { name: "PBKDF2" };
const HASH_ALGORITHM = { name: "HMAC" };
const HASH_FUNCTION = "SHA-1";
const BASE_KEY_ALGORITHM = Object.assign({ hash: HASH_ALGORITHM }, PBKDF2_ALGORITHM);
const DERIVED_BITS_ALGORITHM = Object.assign({ iterations: 1e3, hash: { name: HASH_FUNCTION } }, PBKDF2_ALGORITHM);
const DERIVED_BITS_USAGE = ["deriveBits"];
const SALT_LENGTH = [8, 12, 16];
const KEY_LENGTH = [16, 24, 32];
const SIGNATURE_LENGTH = 10;
const COUNTER_DEFAULT_VALUE = [0, 0, 0, 0];
const UNDEFINED_TYPE$1 = "undefined";
const FUNCTION_TYPE = "function";
const CRYPTO_API_SUPPORTED = typeof crypto != UNDEFINED_TYPE$1;
const SUBTLE_API_SUPPORTED = CRYPTO_API_SUPPORTED && typeof crypto.subtle != UNDEFINED_TYPE$1;
const GET_RANDOM_VALUES_SUPPORTED = CRYPTO_API_SUPPORTED && typeof crypto.getRandomValues == FUNCTION_TYPE;
const IMPORT_KEY_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof crypto.subtle.importKey == FUNCTION_TYPE;
const DERIVE_BITS_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof crypto.subtle.deriveBits == FUNCTION_TYPE;
const codecBytes = codec.bytes;
const Aes = cipher.aes;
const CtrGladman = mode.ctrGladman;
const HmacSha1 = misc.hmacSha1;
class AESDecryptionStream extends TransformStream {
  constructor(password, signed, strength) {
    let stream;
    super({
      start() {
        Object.assign(this, {
          ready: new Promise((resolve2) => this.resolveReady = resolve2),
          password,
          signed,
          strength: strength - 1,
          pending: new Uint8Array(0)
        });
      },
      async transform(chunk, controller) {
        const aesCrypto = this;
        if (aesCrypto.password) {
          const password2 = aesCrypto.password;
          aesCrypto.password = null;
          const preamble = subarray(chunk, 0, SALT_LENGTH[aesCrypto.strength] + 2);
          await createDecryptionKeys(aesCrypto, preamble, password2);
          aesCrypto.ctr = new CtrGladman(new Aes(aesCrypto.keys.key), Array.from(COUNTER_DEFAULT_VALUE));
          aesCrypto.hmac = new HmacSha1(aesCrypto.keys.authentication);
          chunk = subarray(chunk, SALT_LENGTH[aesCrypto.strength] + 2);
          aesCrypto.resolveReady();
        } else {
          await aesCrypto.ready;
        }
        const output = new Uint8Array(chunk.length - SIGNATURE_LENGTH - (chunk.length - SIGNATURE_LENGTH) % BLOCK_LENGTH);
        controller.enqueue(append(aesCrypto, chunk, output, 0, SIGNATURE_LENGTH, true));
      },
      async flush(controller) {
        const aesCrypto = this;
        await aesCrypto.ready;
        const pending = aesCrypto.pending;
        const chunkToDecrypt = subarray(pending, 0, pending.length - SIGNATURE_LENGTH);
        const originalSignature = subarray(pending, pending.length - SIGNATURE_LENGTH);
        let decryptedChunkArray = new Uint8Array(0);
        if (chunkToDecrypt.length) {
          const encryptedChunk = toBits(codecBytes, chunkToDecrypt);
          aesCrypto.hmac.update(encryptedChunk);
          const decryptedChunk = aesCrypto.ctr.update(encryptedChunk);
          decryptedChunkArray = fromBits(codecBytes, decryptedChunk);
        }
        stream.valid = true;
        if (aesCrypto.signed) {
          const signature = subarray(fromBits(codecBytes, aesCrypto.hmac.digest()), 0, SIGNATURE_LENGTH);
          for (let indexSignature = 0; indexSignature < SIGNATURE_LENGTH; indexSignature++) {
            if (signature[indexSignature] != originalSignature[indexSignature]) {
              stream.valid = false;
            }
          }
        }
        controller.enqueue(decryptedChunkArray);
      }
    });
    stream = this;
  }
}
class AESEncryptionStream extends TransformStream {
  constructor(password, strength) {
    let stream;
    super({
      start() {
        Object.assign(this, {
          ready: new Promise((resolve2) => this.resolveReady = resolve2),
          password,
          strength: strength - 1,
          pending: new Uint8Array(0)
        });
      },
      async transform(chunk, controller) {
        const aesCrypto = this;
        let preamble = new Uint8Array(0);
        if (aesCrypto.password) {
          const password2 = aesCrypto.password;
          aesCrypto.password = null;
          preamble = await createEncryptionKeys(aesCrypto, password2);
          aesCrypto.ctr = new CtrGladman(new Aes(aesCrypto.keys.key), Array.from(COUNTER_DEFAULT_VALUE));
          aesCrypto.hmac = new HmacSha1(aesCrypto.keys.authentication);
          aesCrypto.resolveReady();
        } else {
          await aesCrypto.ready;
        }
        const output = new Uint8Array(preamble.length + chunk.length - chunk.length % BLOCK_LENGTH);
        output.set(preamble, 0);
        controller.enqueue(append(aesCrypto, chunk, output, preamble.length, 0));
      },
      async flush(controller) {
        const aesCrypto = this;
        await aesCrypto.ready;
        let encryptedChunkArray = new Uint8Array(0);
        if (aesCrypto.pending.length) {
          const encryptedChunk = aesCrypto.ctr.update(toBits(codecBytes, aesCrypto.pending));
          aesCrypto.hmac.update(encryptedChunk);
          encryptedChunkArray = fromBits(codecBytes, encryptedChunk);
        }
        stream.signature = fromBits(codecBytes, aesCrypto.hmac.digest()).slice(0, SIGNATURE_LENGTH);
        controller.enqueue(concat(encryptedChunkArray, stream.signature));
      }
    });
    stream = this;
  }
}
function append(aesCrypto, input, output, paddingStart, paddingEnd, verifySignature) {
  const inputLength = input.length - paddingEnd;
  if (aesCrypto.pending.length) {
    input = concat(aesCrypto.pending, input);
    output = expand(output, inputLength - inputLength % BLOCK_LENGTH);
  }
  let offset;
  for (offset = 0; offset <= inputLength - BLOCK_LENGTH; offset += BLOCK_LENGTH) {
    const inputChunk = toBits(codecBytes, subarray(input, offset, offset + BLOCK_LENGTH));
    if (verifySignature) {
      aesCrypto.hmac.update(inputChunk);
    }
    const outputChunk = aesCrypto.ctr.update(inputChunk);
    if (!verifySignature) {
      aesCrypto.hmac.update(outputChunk);
    }
    output.set(fromBits(codecBytes, outputChunk), offset + paddingStart);
  }
  aesCrypto.pending = subarray(input, offset);
  return output;
}
async function createDecryptionKeys(decrypt2, preambleArray, password) {
  await createKeys$1(decrypt2, password, subarray(preambleArray, 0, SALT_LENGTH[decrypt2.strength]));
  const passwordVerification = subarray(preambleArray, SALT_LENGTH[decrypt2.strength]);
  const passwordVerificationKey = decrypt2.keys.passwordVerification;
  if (passwordVerificationKey[0] != passwordVerification[0] || passwordVerificationKey[1] != passwordVerification[1]) {
    throw new Error(ERR_INVALID_PASSWORD);
  }
}
async function createEncryptionKeys(encrypt2, password) {
  const salt = getRandomValues(new Uint8Array(SALT_LENGTH[encrypt2.strength]));
  await createKeys$1(encrypt2, password, salt);
  return concat(salt, encrypt2.keys.passwordVerification);
}
async function createKeys$1(target, password, salt) {
  const encodedPassword = encodeText(password);
  const basekey = await importKey(RAW_FORMAT, encodedPassword, BASE_KEY_ALGORITHM, false, DERIVED_BITS_USAGE);
  const derivedBits = await deriveBits(Object.assign({ salt }, DERIVED_BITS_ALGORITHM), basekey, 8 * (KEY_LENGTH[target.strength] * 2 + 2));
  const compositeKey = new Uint8Array(derivedBits);
  target.keys = {
    key: toBits(codecBytes, subarray(compositeKey, 0, KEY_LENGTH[target.strength])),
    authentication: toBits(codecBytes, subarray(compositeKey, KEY_LENGTH[target.strength], KEY_LENGTH[target.strength] * 2)),
    passwordVerification: subarray(compositeKey, KEY_LENGTH[target.strength] * 2)
  };
}
function getRandomValues(array) {
  if (GET_RANDOM_VALUES_SUPPORTED) {
    return crypto.getRandomValues(array);
  } else {
    return random.getRandomValues(array);
  }
}
function importKey(format2, password, algorithm, extractable, keyUsages) {
  if (IMPORT_KEY_SUPPORTED) {
    return crypto.subtle.importKey(format2, password, algorithm, extractable, keyUsages);
  } else {
    return misc.importKey(password);
  }
}
async function deriveBits(algorithm, baseKey, length) {
  if (DERIVE_BITS_SUPPORTED) {
    return await crypto.subtle.deriveBits(algorithm, baseKey, length);
  } else {
    return misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);
  }
}
function concat(leftArray, rightArray) {
  let array = leftArray;
  if (leftArray.length + rightArray.length) {
    array = new Uint8Array(leftArray.length + rightArray.length);
    array.set(leftArray, 0);
    array.set(rightArray, leftArray.length);
  }
  return array;
}
function expand(inputArray, length) {
  if (length && length > inputArray.length) {
    const array = inputArray;
    inputArray = new Uint8Array(length);
    inputArray.set(array, 0);
  }
  return inputArray;
}
function subarray(array, begin, end) {
  return array.subarray(begin, end);
}
function fromBits(codecBytes2, chunk) {
  return codecBytes2.fromBits(chunk);
}
function toBits(codecBytes2, chunk) {
  return codecBytes2.toBits(chunk);
}
const HEADER_LENGTH = 12;
class ZipCryptoDecryptionStream extends TransformStream {
  constructor(password, passwordVerification) {
    let stream;
    super({
      start() {
        Object.assign(this, {
          password,
          passwordVerification
        });
        createKeys(this, password);
      },
      transform(chunk, controller) {
        const zipCrypto = this;
        if (zipCrypto.password) {
          const decryptedHeader = decrypt(zipCrypto, chunk.subarray(0, HEADER_LENGTH));
          zipCrypto.password = null;
          if (decryptedHeader[HEADER_LENGTH - 1] != zipCrypto.passwordVerification) {
            throw new Error(ERR_INVALID_PASSWORD);
          }
          chunk = chunk.subarray(HEADER_LENGTH);
        }
        controller.enqueue(decrypt(zipCrypto, chunk));
      },
      flush() {
        stream.valid = true;
      }
    });
    stream = this;
  }
}
class ZipCryptoEncryptionStream extends TransformStream {
  constructor(password, passwordVerification) {
    super({
      start() {
        Object.assign(this, {
          password,
          passwordVerification
        });
        createKeys(this, password);
      },
      transform(chunk, controller) {
        const zipCrypto = this;
        let output;
        let offset;
        if (zipCrypto.password) {
          zipCrypto.password = null;
          const header = crypto.getRandomValues(new Uint8Array(HEADER_LENGTH));
          header[HEADER_LENGTH - 1] = zipCrypto.passwordVerification;
          output = new Uint8Array(chunk.length + header.length);
          output.set(encrypt(zipCrypto, header), 0);
          offset = HEADER_LENGTH;
        } else {
          output = new Uint8Array(chunk.length);
          offset = 0;
        }
        output.set(encrypt(zipCrypto, chunk), offset);
        controller.enqueue(output);
      },
      flush() {
      }
    });
  }
}
function decrypt(target, input) {
  const output = new Uint8Array(input.length);
  for (let index2 = 0; index2 < input.length; index2++) {
    output[index2] = getByte(target) ^ input[index2];
    updateKeys(target, output[index2]);
  }
  return output;
}
function encrypt(target, input) {
  const output = new Uint8Array(input.length);
  for (let index2 = 0; index2 < input.length; index2++) {
    output[index2] = getByte(target) ^ input[index2];
    updateKeys(target, input[index2]);
  }
  return output;
}
function createKeys(target, password) {
  target.keys = [305419896, 591751049, 878082192];
  target.crcKey0 = new Crc32(target.keys[0]);
  target.crcKey2 = new Crc32(target.keys[2]);
  for (let index2 = 0; index2 < password.length; index2++) {
    updateKeys(target, password.charCodeAt(index2));
  }
}
function updateKeys(target, byte) {
  target.crcKey0.append([byte]);
  target.keys[0] = ~target.crcKey0.get();
  target.keys[1] = getInt32(target.keys[1] + getInt8(target.keys[0]));
  target.keys[1] = getInt32(Math.imul(target.keys[1], 134775813) + 1);
  target.crcKey2.append([target.keys[1] >>> 24]);
  target.keys[2] = ~target.crcKey2.get();
}
function getByte(target) {
  const temp2 = target.keys[2] | 2;
  return getInt8(Math.imul(temp2, temp2 ^ 1) >>> 8);
}
function getInt8(number) {
  return number & 255;
}
function getInt32(number) {
  return number & 4294967295;
}
class CodecStream extends TransformStream {
  constructor(Codec, options) {
    let codec2;
    super({
      start() {
        codec2 = new Codec(options);
      },
      transform(chunk, controller) {
        chunk = codec2.append(chunk);
        controller.enqueue(chunk);
      },
      flush(controller) {
        const chunk = codec2.flush();
        if (chunk) {
          controller.enqueue(chunk);
        }
      }
    });
  }
}
const ERR_INVALID_SIGNATURE = "Invalid signature";
const COMPRESSION_FORMAT = "deflate-raw";
const UNDEFINED_TYPE = "undefined";
const COMPRESSION_STREAM_API_SUPPORTED = typeof CompressionStream == UNDEFINED_TYPE;
const DECOMPRESSION_STREAM_API_SUPPORTED = typeof DecompressionStream == UNDEFINED_TYPE;
let INFLATE_RAW_SUPPORTED = true;
let DEFLATE_RAW_SUPPORTED = true;
class DeflateStream extends TransformStream {
  constructor(codecConstructor, options, { chunkSize }, ...strategies) {
    super({}, ...strategies);
    const { compressed, useCompressionStream, password, passwordVerification, encryptionStrength, zipCrypto, signed } = options;
    const stream = this;
    let crc32Stream, encryptionStream;
    let readable = filterEmptyChunks(super.readable);
    const encrypted = Boolean(password);
    if ((!encrypted || zipCrypto) && signed) {
      [readable, crc32Stream] = readable.tee();
      crc32Stream = crc32Stream.pipeThrough(new Crc32Stream());
    }
    if (compressed) {
      if (useCompressionStream !== void 0 && !useCompressionStream || COMPRESSION_STREAM_API_SUPPORTED && !DEFLATE_RAW_SUPPORTED) {
        readable = pipeCodecStream(codecConstructor, readable, chunkSize);
      } else {
        try {
          const compressionStream = new CompressionStream(COMPRESSION_FORMAT);
          readable = readable.pipeThrough(compressionStream);
        } catch (_error) {
          DEFLATE_RAW_SUPPORTED = false;
          readable = pipeCodecStream(codecConstructor, readable, chunkSize);
        }
      }
    }
    if (encrypted) {
      if (zipCrypto) {
        readable = readable.pipeThrough(new ZipCryptoEncryptionStream(password, passwordVerification));
      } else {
        encryptionStream = new AESEncryptionStream(password, encryptionStrength);
        readable = readable.pipeThrough(encryptionStream);
      }
    }
    setReadable(stream, readable, async () => {
      let signature;
      if (encrypted && !zipCrypto) {
        signature = encryptionStream.signature;
      }
      if ((!encrypted || zipCrypto) && signed) {
        signature = await crc32Stream.getReader().read();
        signature = new DataView(signature.value.buffer).getUint32(0);
      }
      stream.signature = signature;
    });
  }
}
class InflateStream extends TransformStream {
  constructor(codecConstructor, options, { chunkSize }, ...strategies) {
    super({}, ...strategies);
    const { zipCrypto, password, passwordVerification, signed, encryptionStrength, compressed, useCompressionStream } = options;
    const stream = this;
    let crc32Stream, decryptionStream;
    let readable = filterEmptyChunks(super.readable);
    const encrypted = Boolean(password);
    if (encrypted) {
      if (zipCrypto) {
        readable = readable.pipeThrough(new ZipCryptoDecryptionStream(password, passwordVerification));
      } else {
        decryptionStream = new AESDecryptionStream(password, signed, encryptionStrength);
        readable = readable.pipeThrough(decryptionStream);
      }
    }
    if (compressed) {
      if (useCompressionStream !== void 0 && !useCompressionStream || DECOMPRESSION_STREAM_API_SUPPORTED && !INFLATE_RAW_SUPPORTED) {
        readable = pipeCodecStream(codecConstructor, readable, chunkSize);
      } else {
        try {
          readable = readable.pipeThrough(new DecompressionStream(COMPRESSION_FORMAT));
        } catch (_error) {
          INFLATE_RAW_SUPPORTED = false;
          readable = pipeCodecStream(codecConstructor, readable, chunkSize);
        }
      }
    }
    if ((!encrypted || zipCrypto) && signed) {
      [readable, crc32Stream] = readable.tee();
      crc32Stream = crc32Stream.pipeThrough(new Crc32Stream());
    }
    setReadable(stream, readable, async () => {
      if (encrypted && !zipCrypto) {
        if (!decryptionStream.valid) {
          throw new Error(ERR_INVALID_SIGNATURE);
        }
      }
      if ((!encrypted || zipCrypto) && signed) {
        const signature = await crc32Stream.getReader().read();
        const dataViewSignature = new DataView(signature.value.buffer);
        if (signature != dataViewSignature.getUint32(0, false)) {
          throw new Error(ERR_INVALID_SIGNATURE);
        }
      }
    });
  }
}
function pipeCodecStream(codecConstructor, stream, chunkSize) {
  return stream.pipeThrough(new CodecStream(codecConstructor, { chunkSize }));
}
function filterEmptyChunks(readable) {
  return readable.pipeThrough(new TransformStream({
    transform(chunk, controller) {
      if (chunk && chunk.length) {
        controller.enqueue(chunk);
      }
    }
  }));
}
function setReadable(stream, readable, flush) {
  stream.length = 0;
  readable = readable.pipeThrough(new TransformStream({
    transform(chunk, controller) {
      if (chunk && chunk.length) {
        stream.length += chunk.length;
        controller.enqueue(chunk);
      }
    },
    flush
  }));
  Object.defineProperty(stream, "readable", {
    get() {
      return readable;
    }
  });
}
const CODEC_DEFLATE = "deflate";
const CODEC_INFLATE = "inflate";
const MESSAGE_EVENT_TYPE = "message";
const MESSAGE_START = "start";
const MESSAGE_PULL = "pull";
const MESSAGE_DATA = "data";
const MESSAGE_ABORT = "abort";
const MESSAGE_CLOSE = "close";
const ERR_ABORT = "AbortError";
function createCodec(codecConstructor, readable, writable, options, config2) {
  const controller = new AbortController();
  const { signal } = controller;
  if (options.codecType.startsWith(CODEC_DEFLATE)) {
    return {
      run: () => run(DeflateStream),
      abort
    };
  } else if (options.codecType.startsWith(CODEC_INFLATE)) {
    return {
      run: () => run(InflateStream),
      abort
    };
  }
  async function run(StreamConstructor) {
    const stream = new StreamConstructor(codecConstructor, options, config2);
    await readable.pipeThrough(stream, { signal }).pipeTo(writable, { preventClose: true });
    const { length, signature } = stream;
    return { length, signature };
  }
  function abort() {
    controller.abort();
  }
}
let classicWorkersSupported = true;
function getWorker(workerData, codecConstructor, readable, writable, options, config2, streamOptions, onTaskFinished, webWorker, scripts) {
  Object.assign(workerData, {
    busy: true,
    codecConstructor,
    readable,
    writable,
    options: Object.assign({}, options),
    scripts,
    terminate() {
      if (workerData.worker && !workerData.busy) {
        workerData.worker.terminate();
        workerData.interface = null;
      }
    },
    onTaskFinished() {
      workerData.busy = false;
      onTaskFinished(workerData);
    }
  });
  const { signal, onprogress, size } = streamOptions;
  if (signal || onprogress) {
    let chunkOffset = 0;
    const transformer = {};
    if (onprogress) {
      transformer.transform = (chunk, controller) => {
        chunkOffset += chunk.length;
        try {
          onprogress(chunkOffset, size());
        } catch (_error) {
        }
        controller.enqueue(chunk);
      };
    }
    workerData.readable = readable.pipeThrough(new TransformStream(transformer), { signal });
  }
  return webWorker ? createWebWorkerInterface(workerData, config2) : createWorkerInterface(workerData, config2);
}
function createWorkerInterface(workerData, config2) {
  const interfaceCodec = createCodec(workerData.codecConstructor, workerData.readable, workerData.writable, workerData.options, config2);
  const codec2 = {
    abort() {
      interfaceCodec.abort();
      workerData.onTaskFinished();
    },
    run() {
      const result = interfaceCodec.run();
      workerData.onTaskFinished();
      return result;
    }
  };
  return codec2;
}
function createWebWorkerInterface(workerData, { baseURL: baseURL2, chunkSize }) {
  const workerOptions = { type: "module" };
  workerData.reader = workerData.readable.getReader();
  workerData.writer = workerData.writable.getWriter();
  workerData.result = new Promise((resolve2, reject2) => {
    workerData.resolveResult = resolve2;
    workerData.rejectResult = reject2;
  });
  if (!workerData.interface) {
    if (!classicWorkersSupported) {
      workerData.worker = getWorker2(workerOptions);
    } else {
      try {
        workerData.worker = getWorker2({});
      } catch (_error) {
        classicWorkersSupported = false;
        workerData.worker = getWorker2(workerOptions);
      }
    }
    workerData.worker.addEventListener(MESSAGE_EVENT_TYPE, onMessage, false);
    workerData.interface = {
      abort() {
        sendMessage({ type: MESSAGE_ABORT });
        workerData.writer.releaseLock();
        workerData.onTaskFinished();
      },
      run() {
        const options = workerData.options;
        const scripts = workerData.scripts.slice(1);
        sendMessage({ type: MESSAGE_START, scripts, options, config: { chunkSize } });
        return workerData.result;
      }
    };
  }
  return workerData.interface;
  function getWorker2(options) {
    let url2, scriptUrl;
    url2 = workerData.scripts[0];
    if (typeof url2 == "function") {
      url2 = url2();
    }
    try {
      scriptUrl = new URL(url2, baseURL2);
    } catch (_error) {
      scriptUrl = url2;
    }
    return new Worker(scriptUrl, options);
  }
  function sendMessage(message) {
    const worker = workerData.worker;
    try {
      if (message.data) {
        try {
          message.data = message.data.buffer;
          worker.postMessage(message, [message.data]);
        } catch (_error) {
          worker.postMessage(message);
        }
      } else {
        worker.postMessage(message);
      }
    } catch (error) {
      workerData.writer.releaseLock();
      workerData.onTaskFinished();
      throw error;
    }
  }
  async function onMessage(event) {
    const message = event.data;
    const reponseError = message.error;
    try {
      if (reponseError) {
        const error = new Error(reponseError.message);
        error.stack = reponseError.stack;
        workerData.rejectResult(error);
        workerData.writer.releaseLock();
        workerData.onTaskFinished();
      } else {
        if (message.type == MESSAGE_PULL) {
          const { value, done } = await workerData.reader.read();
          sendMessage({ type: MESSAGE_DATA, data: value, done, messageId: message.messageId });
        }
        if (message.type == MESSAGE_DATA) {
          let { data } = message;
          data = new Uint8Array(data);
          await workerData.writer.ready;
          await workerData.writer.write(data);
        }
        if (message.type == MESSAGE_CLOSE) {
          workerData.resolveResult(message.result);
          workerData.writer.releaseLock();
          workerData.onTaskFinished();
        }
      }
    } catch (error) {
      workerData.rejectResult(error);
      workerData.writer.releaseLock();
      workerData.onTaskFinished();
    }
  }
}
let pool = [];
const pendingRequests = [];
let indexWorker = 0;
async function runCodec(codecConstructor, readable, writable, options, config2, streamOptions) {
  const streamCopy = !options.compressed && !options.signed && !options.encrypted;
  const webWorker = !streamCopy && (options.useWebWorkers || options.useWebWorkers === void 0 && config2.useWebWorkers);
  const scripts = webWorker && config2.workerScripts ? config2.workerScripts[options.codecType] : [];
  options.useCompressionStream = options.useCompressionStream === void 0 ? config2.useCompressionStream : options.useCompressionStream;
  let codec2;
  if (pool.length < config2.maxWorkers) {
    const workerData = { indexWorker };
    indexWorker++;
    pool.push(workerData);
    codec2 = getWorker(workerData, codecConstructor, readable, writable, options, config2, streamOptions, onTaskFinished, webWorker, scripts);
  } else {
    const workerData = pool.find((workerData2) => !workerData2.busy);
    if (workerData) {
      clearTerminateTimeout(workerData);
      codec2 = getWorker(workerData, codecConstructor, readable, writable, options, config2, streamOptions, onTaskFinished, webWorker, scripts);
    } else {
      codec2 = await new Promise((resolve2) => pendingRequests.push({ resolve: resolve2, codecConstructor, readable, writable, options, webWorker, scripts }));
    }
  }
  const { signal } = streamOptions;
  try {
    return await codec2.run(signal);
  } catch (error) {
    if (signal && signal.aborted && (signal.reason == error || error.name == ERR_ABORT)) {
      codec2.abort();
      throw new Error(ERR_ABORT);
    } else {
      throw error;
    }
  }
  function onTaskFinished(workerData) {
    if (pendingRequests.length) {
      const [{ resolve: resolve2, codecConstructor: codecConstructor2, readable: readable2, writable: writable2, options: options2, webWorker: webWorker2, scripts: scripts2 }] = pendingRequests.splice(0, 1);
      resolve2(getWorker(workerData, codecConstructor2, readable2, writable2, options2, config2, streamOptions, onTaskFinished, webWorker2, scripts2));
    } else if (workerData.worker) {
      clearTerminateTimeout(workerData);
      if (Number.isFinite(config2.terminateWorkerTimeout) && config2.terminateWorkerTimeout >= 0) {
        workerData.terminateTimeout = setTimeout(() => {
          pool = pool.filter((data) => data != workerData);
          workerData.terminate();
        }, config2.terminateWorkerTimeout);
      }
    } else {
      pool = pool.filter((data) => data != workerData);
    }
  }
}
function clearTerminateTimeout(workerData) {
  if (workerData.terminateTimeout) {
    clearTimeout(workerData.terminateTimeout);
    workerData.terminateTimeout = null;
  }
}
var e = (e2) => {
  if (typeof URL.createObjectURL == "function") {
    const t = () => URL.createObjectURL(new Blob(['const{Array:t,Object:e,Math:n,Error:r,Uint8Array:i,Uint16Array:s,Uint32Array:o,Int32Array:f,DataView:c,TextEncoder:l,crypto:u,postMessage:a,TransformStream:w,ReadableStream:h,WritableStream:d,CompressionStream:p,DecompressionStream:b}=globalThis,y=[];for(let t=0;256>t;t++){let e=t;for(let t=0;8>t;t++)1&e?e=e>>>1^3988292384:e>>>=1;y[t]=e}class m{constructor(t){this.t=t||-1}append(t){let e=0|this.t;for(let n=0,r=0|t.length;r>n;n++)e=e>>>8^y[255&(e^t[n])];this.t=e}get(){return~this.t}}class k extends w{constructor(){super({start(){this.i=new m},transform(t){this.i.append(t)},flush(t){const e=new i(4);new c(e.buffer).setUint32(0,this.i.get()),t.enqueue(e)}})}}const g={concat(t,e){if(0===t.length||0===e.length)return t.concat(e);const n=t[t.length-1],r=g.o(n);return 32===r?t.concat(e):g.l(e,r,0|n,t.slice(0,t.length-1))},u(t){const e=t.length;if(0===e)return 0;const n=t[e-1];return 32*(e-1)+g.o(n)},h(t,e){if(32*t.length<e)return t;const r=(t=t.slice(0,n.ceil(e/32))).length;return e&=31,r>0&&e&&(t[r-1]=g.p(e,t[r-1]&2147483648>>e-1,1)),t},p:(t,e,n)=>32===t?e:(n?0|e:e<<32-t)+1099511627776*t,o:t=>n.round(t/1099511627776)||32,l(t,e,n,r){for(void 0===r&&(r=[]);e>=32;e-=32)r.push(n),n=0;if(0===e)return r.concat(t);for(let i=0;i<t.length;i++)r.push(n|t[i]>>>e),n=t[i]<<32-e;const i=t.length?t[t.length-1]:0,s=g.o(i);return r.push(g.p(e+s&31,e+s>32?n:r.pop(),1)),r}},v={m:{k(t){const e=g.u(t)/8,n=new i(e);let r;for(let i=0;e>i;i++)0==(3&i)&&(r=t[i/4]),n[i]=r>>>24,r<<=8;return n},g(t){const e=[];let n,r=0;for(n=0;n<t.length;n++)r=r<<8|t[n],3==(3&n)&&(e.push(r),r=0);return 3&n&&e.push(g.p(8*(3&n),r)),e}}},S={v:function(t){t?(this.S=t.S.slice(0),this._=t._.slice(0),this.C=t.C):this.reset()}};S.v.prototype={blockSize:512,reset:function(){const t=this;return t.S=this.A.slice(0),t._=[],t.C=0,t},update:function(t){const e=this;"string"==typeof t&&(t=v.I.g(t));const n=e._=g.concat(e._,t),i=e.C,s=e.C=i+g.u(t);if(s>9007199254740991)throw new r("Cannot hash more than 2^53 - 1 bits");const f=new o(n);let c=0;for(let t=e.blockSize+i-(e.blockSize+i&e.blockSize-1);s>=t;t+=e.blockSize)e.V(f.subarray(16*c,16*(c+1))),c+=1;return n.splice(0,16*c),e},P:function(){const t=this;let e=t._;const r=t.S;e=g.concat(e,[g.p(1,1)]);for(let t=e.length+2;15&t;t++)e.push(0);for(e.push(n.floor(t.C/4294967296)),e.push(0|t.C);e.length;)t.V(e.splice(0,16));return t.reset(),r},A:[1732584193,4023233417,2562383102,271733878,3285377520],B:[1518500249,1859775393,2400959708,3395469782],D:(t,e,n,r)=>t>19?t>39?t>59?t>79?void 0:e^n^r:e&n|e&r|n&r:e^n^r:e&n|~e&r,M:(t,e)=>e<<t|e>>>32-t,V:function(e){const r=this,i=r.S,s=t(80);for(let t=0;16>t;t++)s[t]=e[t];let o=i[0],f=i[1],c=i[2],l=i[3],u=i[4];for(let t=0;79>=t;t++){16>t||(s[t]=r.M(1,s[t-3]^s[t-8]^s[t-14]^s[t-16]));const e=r.M(5,o)+r.D(t,f,c,l)+u+s[t]+r.B[n.floor(t/20)]|0;u=l,l=c,c=r.M(30,f),f=o,o=e}i[0]=i[0]+o|0,i[1]=i[1]+f|0,i[2]=i[2]+c|0,i[3]=i[3]+l|0,i[4]=i[4]+u|0}};const _={getRandomValues(t){const e=new o(t.buffer),r=t=>{let e=987654321;const r=4294967295;return()=>(e=36969*(65535&e)+(e>>16)&r,(((e<<16)+(t=18e3*(65535&t)+(t>>16)&r)&r)/4294967296+.5)*(n.random()>.5?1:-1))};for(let i,s=0;s<t.length;s+=4){const t=r(4294967296*(i||n.random()));i=987654071*t(),e[s/4]=4294967296*t()|0}return t}},C={importKey:t=>new C.R(v.m.g(t)),U(t,e,n,i){if(n=n||1e4,0>i||0>n)throw new r("invalid params to pbkdf2");const s=1+(i>>5)<<2;let o,f,l,u,a;const w=new ArrayBuffer(s),h=new c(w);let d=0;const p=g;for(e=v.m.g(e),a=1;(s||1)>d;a++){for(o=f=t.encrypt(p.concat(e,[a])),l=1;n>l;l++)for(f=t.encrypt(f),u=0;u<f.length;u++)o[u]^=f[u];for(l=0;(s||1)>d&&l<o.length;l++)h.setInt32(d,o[l]),d+=4}return w.slice(0,i/8)},R:class{constructor(t){const e=this,n=e.T=S.v,r=[[],[]],i=n.prototype.blockSize/32;e.W=[new n,new n],t.length>i&&(t=n.hash(t));for(let e=0;i>e;e++)r[0][e]=909522486^t[e],r[1][e]=1549556828^t[e];e.W[0].update(r[0]),e.W[1].update(r[1]),e.j=new n(e.W[0])}reset(){const t=this;t.j=new t.T(t.W[0]),t.H=!1}update(t){this.H=!0,this.j.update(t)}digest(){const t=this,e=t.j.P(),n=new t.T(t.W[1]).update(e).P();return t.reset(),n}encrypt(t){if(this.H)throw new r("encrypt on already updated hmac called!");return this.update(t),this.digest(t)}}},z={name:"PBKDF2"},x=e.assign({hash:{name:"HMAC"}},z),A=e.assign({iterations:1e3,hash:{name:"SHA-1"}},z),I=["deriveBits"],V=[8,12,16],P=[16,24,32],B=[0,0,0,0],D=void 0!==u,E=D&&void 0!==u.subtle,M=D&&"function"==typeof u.getRandomValues,R=D&&E&&"function"==typeof u.subtle.importKey,U=D&&E&&"function"==typeof u.subtle.deriveBits,T=v.m,W=class{constructor(t){const e=this;e.K=[[[],[],[],[],[]],[[],[],[],[],[]]],e.K[0][0][0]||e.L();const n=e.K[0][4],i=e.K[1],s=t.length;let o,f,c,l=1;if(4!==s&&6!==s&&8!==s)throw new r("invalid aes key size");for(e.B=[f=t.slice(0),c=[]],o=s;4*s+28>o;o++){let t=f[o-1];(o%s==0||8===s&&o%s==4)&&(t=n[t>>>24]<<24^n[t>>16&255]<<16^n[t>>8&255]<<8^n[255&t],o%s==0&&(t=t<<8^t>>>24^l<<24,l=l<<1^283*(l>>7))),f[o]=f[o-s]^t}for(let t=0;o;t++,o--){const e=f[3&t?o:o-4];c[t]=4>=o||4>t?e:i[0][n[e>>>24]]^i[1][n[e>>16&255]]^i[2][n[e>>8&255]]^i[3][n[255&e]]}}encrypt(t){return this.F(t,0)}decrypt(t){return this.F(t,1)}L(){const t=this.K[0],e=this.K[1],n=t[4],r=e[4],i=[],s=[];let o,f,c,l;for(let t=0;256>t;t++)s[(i[t]=t<<1^283*(t>>7))^t]=t;for(let u=o=0;!n[u];u^=f||1,o=s[o]||1){let s=o^o<<1^o<<2^o<<3^o<<4;s=s>>8^255&s^99,n[u]=s,r[s]=u,l=i[c=i[f=i[u]]];let a=16843009*l^65537*c^257*f^16843008*u,w=257*i[s]^16843008*s;for(let n=0;4>n;n++)t[n][u]=w=w<<24^w>>>8,e[n][s]=a=a<<24^a>>>8}for(let n=0;5>n;n++)t[n]=t[n].slice(0),e[n]=e[n].slice(0)}F(t,e){if(4!==t.length)throw new r("invalid aes block size");const n=this.B[e],i=n.length/4-2,s=[0,0,0,0],o=this.K[e],f=o[0],c=o[1],l=o[2],u=o[3],a=o[4];let w,h,d,p=t[0]^n[0],b=t[e?3:1]^n[1],y=t[2]^n[2],m=t[e?1:3]^n[3],k=4;for(let t=0;i>t;t++)w=f[p>>>24]^c[b>>16&255]^l[y>>8&255]^u[255&m]^n[k],h=f[b>>>24]^c[y>>16&255]^l[m>>8&255]^u[255&p]^n[k+1],d=f[y>>>24]^c[m>>16&255]^l[p>>8&255]^u[255&b]^n[k+2],m=f[m>>>24]^c[p>>16&255]^l[b>>8&255]^u[255&y]^n[k+3],k+=4,p=w,b=h,y=d;for(let t=0;4>t;t++)s[e?3&-t:t]=a[p>>>24]<<24^a[b>>16&255]<<16^a[y>>8&255]<<8^a[255&m]^n[k++],w=p,p=b,b=y,y=m,m=w;return s}},j=class{constructor(t,e){this.O=t,this.q=e,this.G=e}reset(){this.G=this.q}update(t){return this.J(this.O,t,this.G)}N(t){if(255==(t>>24&255)){let e=t>>16&255,n=t>>8&255,r=255&t;255===e?(e=0,255===n?(n=0,255===r?r=0:++r):++n):++e,t=0,t+=e<<16,t+=n<<8,t+=r}else t+=1<<24;return t}X(t){0===(t[0]=this.N(t[0]))&&(t[1]=this.N(t[1]))}J(t,e,n){let r;if(!(r=e.length))return[];const i=g.u(e);for(let i=0;r>i;i+=4){this.X(n);const r=t.encrypt(n);e[i]^=r[0],e[i+1]^=r[1],e[i+2]^=r[2],e[i+3]^=r[3]}return g.h(e,i)}},H=C.R;class K extends w{constructor(n,s,o){let f;super({start(){e.assign(this,{ready:new Promise((t=>this.Y=t)),password:n,signed:s,Z:o-1,pending:new i(0)})},async transform(e,n){const s=this;if(s.password){const n=s.password;s.password=null;const i=G(e,0,V[s.Z]+2);await(async(t,e,n)=>{await O(t,n,G(e,0,V[t.Z]));const i=G(e,V[t.Z]),s=t.keys.passwordVerification;if(s[0]!=i[0]||s[1]!=i[1])throw new r("Invalid pasword")})(s,i,n),s.$=new j(new W(s.keys.key),t.from(B)),s.tt=new H(s.keys.et),e=G(e,V[s.Z]+2),s.Y()}else await s.ready;const o=new i(e.length-10-(e.length-10)%16);n.enqueue(F(s,e,o,0,10,!0))},async flush(t){const e=this;await e.ready;const n=e.pending,r=G(n,0,n.length-10),s=G(n,n.length-10);let o=new i(0);if(r.length){const t=N(T,r);e.tt.update(t);const n=e.$.update(t);o=J(T,n)}if(f.valid=!0,e.signed){const t=G(J(T,e.tt.digest()),0,10);for(let e=0;10>e;e++)t[e]!=s[e]&&(f.valid=!1)}t.enqueue(o)}}),f=this}}class L extends w{constructor(n,r){let s;super({start(){e.assign(this,{ready:new Promise((t=>this.Y=t)),password:n,Z:r-1,pending:new i(0)})},async transform(e,n){const r=this;let s=new i(0);if(r.password){const e=r.password;r.password=null,s=await(async(t,e)=>{const n=(r=new i(V[t.Z]),M?u.getRandomValues(r):_.getRandomValues(r));var r;return await O(t,e,n),q(n,t.keys.passwordVerification)})(r,e),r.$=new j(new W(r.keys.key),t.from(B)),r.tt=new H(r.keys.et),r.Y()}else await r.ready;const o=new i(s.length+e.length-e.length%16);o.set(s,0),n.enqueue(F(r,e,o,s.length,0))},async flush(t){const e=this;await e.ready;let n=new i(0);if(e.pending.length){const t=e.$.update(N(T,e.pending));e.tt.update(t),n=J(T,t)}s.signature=J(T,e.tt.digest()).slice(0,10),t.enqueue(q(n,s.signature))}}),s=this}}function F(t,e,n,r,s,o){const f=e.length-s;let c;for(t.pending.length&&(e=q(t.pending,e),n=((t,e)=>{if(e&&e>t.length){const n=t;(t=new i(e)).set(n,0)}return t})(n,f-f%16)),c=0;f-16>=c;c+=16){const i=N(T,G(e,c,c+16));o&&t.tt.update(i);const s=t.$.update(i);o||t.tt.update(s),n.set(J(T,s),c+r)}return t.pending=G(e,c),n}async function O(t,n,r){const s=(t=>{if(void 0===l){const e=new i((t=unescape(encodeURIComponent(t))).length);for(let n=0;n<e.length;n++)e[n]=t.charCodeAt(n);return e}return(new l).encode(t)})(n),o=await((t,e,n,r,i)=>R?u.subtle.importKey("raw",e,n,!1,i):C.importKey(e))(0,s,x,0,I),f=await(async(t,e,n)=>U?await u.subtle.deriveBits(t,e,n):C.U(e,t.salt,A.iterations,n))(e.assign({salt:r},A),o,8*(2*P[t.Z]+2)),c=new i(f);t.keys={key:N(T,G(c,0,P[t.Z])),et:N(T,G(c,P[t.Z],2*P[t.Z])),passwordVerification:G(c,2*P[t.Z])}}function q(t,e){let n=t;return t.length+e.length&&(n=new i(t.length+e.length),n.set(t,0),n.set(e,t.length)),n}function G(t,e,n){return t.subarray(e,n)}function J(t,e){return t.k(e)}function N(t,e){return t.g(e)}class Q extends w{constructor(t,n){let i;super({start(){e.assign(this,{password:t,passwordVerification:n}),$(this,t)},transform(t,e){const n=this;if(n.password){const e=Y(n,t.subarray(0,12));if(n.password=null,e[11]!=n.passwordVerification)throw new r("Invalid pasword");t=t.subarray(12)}e.enqueue(Y(n,t))},flush(){i.valid=!0}}),i=this}}class X extends w{constructor(t,n){super({start(){e.assign(this,{password:t,passwordVerification:n}),$(this,t)},transform(t,e){const n=this;let r,s;if(n.password){n.password=null;const e=u.getRandomValues(new i(12));e[11]=n.passwordVerification,r=new i(t.length+e.length),r.set(Z(n,e),0),s=12}else r=new i(t.length),s=0;r.set(Z(n,t),s),e.enqueue(r)},flush(){}})}}function Y(t,e){const n=new i(e.length);for(let r=0;r<e.length;r++)n[r]=et(t)^e[r],tt(t,n[r]);return n}function Z(t,e){const n=new i(e.length);for(let r=0;r<e.length;r++)n[r]=et(t)^e[r],tt(t,e[r]);return n}function $(t,e){t.keys=[305419896,591751049,878082192],t.nt=new m(t.keys[0]),t.rt=new m(t.keys[2]);for(let n=0;n<e.length;n++)tt(t,e.charCodeAt(n))}function tt(t,e){t.nt.append([e]),t.keys[0]=~t.nt.get(),t.keys[1]=rt(t.keys[1]+nt(t.keys[0])),t.keys[1]=rt(n.imul(t.keys[1],134775813)+1),t.rt.append([t.keys[1]>>>24]),t.keys[2]=~t.rt.get()}function et(t){const e=2|t.keys[2];return nt(n.imul(e,1^e)>>>8)}function nt(t){return 255&t}function rt(t){return 4294967295&t}class it extends w{constructor(t,e){let n;super({start(){n=new t(e)},transform(t,e){t=n.append(t),e.enqueue(t)},flush(t){const e=n.flush();e&&t.enqueue(e)}})}}const st=void 0===p,ot=void 0===b;let ft=!0,ct=!0;class lt extends w{constructor(t,e,{it:n},...r){super({},...r);const{compressed:i,st:s,password:o,passwordVerification:f,encryptionStrength:l,zipCrypto:u,signed:a}=e,w=this;let h,d,b=wt(super.readable);const y=!!o;if(y&&!u||!a||([b,h]=b.tee(),h=h.pipeThrough(new k)),i)if(void 0!==s&&!s||st&&!ct)b=at(t,b,n);else try{const t=new p("deflate-raw");b=b.pipeThrough(t)}catch(e){ct=!1,b=at(t,b,n)}y&&(u?b=b.pipeThrough(new X(o,f)):(d=new L(o,l),b=b.pipeThrough(d))),ht(w,b,(async()=>{let t;y&&!u&&(t=d.signature),y&&!u||!a||(t=await h.getReader().read(),t=new c(t.value.buffer).getUint32(0)),w.signature=t}))}}class ut extends w{constructor(t,e,{it:n},...i){super({},...i);const{zipCrypto:s,password:o,passwordVerification:f,signed:l,encryptionStrength:u,compressed:a,st:w}=e;let h,d,p=wt(super.readable);const y=!!o;if(y&&(s?p=p.pipeThrough(new Q(o,f)):(d=new K(o,l,u),p=p.pipeThrough(d))),a)if(void 0!==w&&!w||ot&&!ft)p=at(t,p,n);else try{p=p.pipeThrough(new b("deflate-raw"))}catch(e){ft=!1,p=at(t,p,n)}y&&!s||!l||([p,h]=p.tee(),h=h.pipeThrough(new k)),ht(this,p,(async()=>{if(y&&!s&&!d.valid)throw new r("Invalid signature");if((!y||s)&&l){const t=await h.getReader().read();if(t!=new c(t.value.buffer).getUint32(0,!1))throw new r("Invalid signature")}}))}}function at(t,e,n){return e.pipeThrough(new it(t,{it:n}))}function wt(t){return t.pipeThrough(new w({transform(t,e){t&&t.length&&e.enqueue(t)}}))}function ht(t,n,r){t.length=0,n=n.pipeThrough(new w({transform(e,n){e&&e.length&&(t.length+=e.length,n.enqueue(e))},flush:r})),e.defineProperty(t,"readable",{get:()=>n})}const dt=new Map;let pt,bt=0;function yt(t){if(t.data){const e=t.data;if(e&&e.length)try{t.data=e.buffer,a(t,[t.data])}catch(e){a(t)}else a(t)}else a(t)}addEventListener("message",(async t=>{const e=t.data,n=e.type;try{if("start"==n&&(async t=>{try{t.scripts&&t.scripts.length&&importScripts.apply(void 0,t.scripts);const e=t.options;let n;self.initCodec&&self.initCodec(),e.codecType.startsWith("deflate")?n=self.Deflate:e.codecType.startsWith("inflate")&&(n=self.Inflate);const r=new h({async pull(t){let e=new Promise(((t,e)=>dt.set(bt,{resolve:t,reject:e})));yt({type:"pull",messageId:bt}),bt++;const{value:n,done:r}=await e;t.enqueue(n),r&&t.close()}},{highWaterMark:1}),i=new d({write(t){yt({type:"data",data:t})}});pt=((t,e,n,r,i)=>{const s=new AbortController,{signal:o}=s;if(r.codecType.startsWith("deflate"))return{ot:()=>f(lt),abort:c};if(r.codecType.startsWith("inflate"))return{ot:()=>f(ut),abort:c};async function f(s){const f=new s(t,r,i);await e.pipeThrough(f,{signal:o}).pipeTo(n,{ft:!0});const{length:c,signature:l}=f;return{length:c,signature:l}}function c(){s.abort()}})(n,r,i,e,t.config),yt({type:"close",result:await pt.ot()})}catch(t){a({error:{message:t.message,stack:t.stack}})}})(e),"data"==n){const{resolve:t}=dt.get(e.messageId);dt.delete(e.messageId),t({value:new i(e.data),done:e.done})}"abort"==n&&pt.abort()}catch(t){a({error:{message:t.message,stack:t.stack}})}}));const mt=(()=>{const e=-2;function o(e){return f(e.map((([e,n])=>new t(e).fill(n,0,e))))}function f(e){return e.reduce(((e,n)=>e.concat(t.isArray(n)?f(n):n)),[])}const c=[0,1,2,3].concat(...o([[2,4],[2,5],[4,6],[4,7],[8,8],[8,9],[16,10],[16,11],[32,12],[32,13],[64,14],[64,15],[2,0],[1,16],[1,17],[2,18],[2,19],[4,20],[4,21],[8,22],[8,23],[16,24],[16,25],[32,26],[32,27],[64,28],[64,29]]));function l(){const t=this;function e(t,e){let n=0;do{n|=1&t,t>>>=1,n<<=1}while(--e>0);return n>>>1}t.ct=r=>{const i=t.lt,s=t.wt.ut,o=t.wt.ht;let f,c,l,u=-1;for(r.dt=0,r.bt=573,f=0;o>f;f++)0!==i[2*f]?(r.yt[++r.dt]=u=f,r.kt[f]=0):i[2*f+1]=0;for(;2>r.dt;)l=r.yt[++r.dt]=2>u?++u:0,i[2*l]=1,r.kt[l]=0,r.gt--,s&&(r.vt-=s[2*l+1]);for(t.St=u,f=n.floor(r.dt/2);f>=1;f--)r._t(i,f);l=o;do{f=r.yt[1],r.yt[1]=r.yt[r.dt--],r._t(i,1),c=r.yt[1],r.yt[--r.bt]=f,r.yt[--r.bt]=c,i[2*l]=i[2*f]+i[2*c],r.kt[l]=n.max(r.kt[f],r.kt[c])+1,i[2*f+1]=i[2*c+1]=l,r.yt[1]=l++,r._t(i,1)}while(r.dt>=2);r.yt[--r.bt]=r.yt[1],(e=>{const n=t.lt,r=t.wt.ut,i=t.wt.Ct,s=t.wt.zt,o=t.wt.xt;let f,c,l,u,a,w,h=0;for(u=0;15>=u;u++)e.At[u]=0;for(n[2*e.yt[e.bt]+1]=0,f=e.bt+1;573>f;f++)c=e.yt[f],u=n[2*n[2*c+1]+1]+1,u>o&&(u=o,h++),n[2*c+1]=u,c>t.St||(e.At[u]++,a=0,s>c||(a=i[c-s]),w=n[2*c],e.gt+=w*(u+a),r&&(e.vt+=w*(r[2*c+1]+a)));if(0!==h){do{for(u=o-1;0===e.At[u];)u--;e.At[u]--,e.At[u+1]+=2,e.At[o]--,h-=2}while(h>0);for(u=o;0!==u;u--)for(c=e.At[u];0!==c;)l=e.yt[--f],l>t.St||(n[2*l+1]!=u&&(e.gt+=(u-n[2*l+1])*n[2*l],n[2*l+1]=u),c--)}})(r),((t,n,r)=>{const i=[];let s,o,f,c=0;for(s=1;15>=s;s++)i[s]=c=c+r[s-1]<<1;for(o=0;n>=o;o++)f=t[2*o+1],0!==f&&(t[2*o]=e(i[f]++,f))})(i,t.St,r.At)}}function u(t,e,n,r,i){const s=this;s.ut=t,s.Ct=e,s.zt=n,s.ht=r,s.xt=i}l.It=[0,1,2,3,4,5,6,7].concat(...o([[2,8],[2,9],[2,10],[2,11],[4,12],[4,13],[4,14],[4,15],[8,16],[8,17],[8,18],[8,19],[16,20],[16,21],[16,22],[16,23],[32,24],[32,25],[32,26],[31,27],[1,28]])),l.Vt=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],l.Pt=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],l.Bt=t=>256>t?c[t]:c[256+(t>>>7)],l.Dt=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],l.Et=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],l.Mt=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],l.Rt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];const a=o([[144,8],[112,9],[24,7],[8,8]]);u.Ut=f([12,140,76,204,44,172,108,236,28,156,92,220,60,188,124,252,2,130,66,194,34,162,98,226,18,146,82,210,50,178,114,242,10,138,74,202,42,170,106,234,26,154,90,218,58,186,122,250,6,134,70,198,38,166,102,230,22,150,86,214,54,182,118,246,14,142,78,206,46,174,110,238,30,158,94,222,62,190,126,254,1,129,65,193,33,161,97,225,17,145,81,209,49,177,113,241,9,137,73,201,41,169,105,233,25,153,89,217,57,185,121,249,5,133,69,197,37,165,101,229,21,149,85,213,53,181,117,245,13,141,77,205,45,173,109,237,29,157,93,221,61,189,125,253,19,275,147,403,83,339,211,467,51,307,179,435,115,371,243,499,11,267,139,395,75,331,203,459,43,299,171,427,107,363,235,491,27,283,155,411,91,347,219,475,59,315,187,443,123,379,251,507,7,263,135,391,71,327,199,455,39,295,167,423,103,359,231,487,23,279,151,407,87,343,215,471,55,311,183,439,119,375,247,503,15,271,143,399,79,335,207,463,47,303,175,431,111,367,239,495,31,287,159,415,95,351,223,479,63,319,191,447,127,383,255,511,0,64,32,96,16,80,48,112,8,72,40,104,24,88,56,120,4,68,36,100,20,84,52,116,3,131,67,195,35,163,99,227].map(((t,e)=>[t,a[e]])));const w=o([[30,5]]);function h(t,e,n,r,i){const s=this;s.Tt=t,s.Wt=e,s.jt=n,s.Ht=r,s.Kt=i}u.Lt=f([0,16,8,24,4,20,12,28,2,18,10,26,6,22,14,30,1,17,9,25,5,21,13,29,3,19,11,27,7,23].map(((t,e)=>[t,w[e]]))),u.Ft=new u(u.Ut,l.Dt,257,286,15),u.Ot=new u(u.Lt,l.Et,0,30,15),u.qt=new u(null,l.Mt,0,19,7);const d=[new h(0,0,0,0,0),new h(4,4,8,4,1),new h(4,5,16,8,1),new h(4,6,32,32,1),new h(4,4,16,16,2),new h(8,16,32,32,2),new h(8,16,128,128,2),new h(8,32,128,256,2),new h(32,128,258,1024,2),new h(32,258,258,4096,2)],p=["need dictionary","stream end","","","stream error","data error","","buffer error","",""],b=113,y=666,m=262;function k(t,e,n,r){const i=t[2*e],s=t[2*n];return s>i||i==s&&r[e]<=r[n]}function g(){const t=this;let r,o,f,c,a,w,h,g,v,S,_,C,z,x,A,I,V,P,B,D,E,M,R,U,T,W,j,H,K,L,F,O,q;const G=new l,J=new l,N=new l;let Q,X,Y,Z,$,tt;function et(){let e;for(e=0;286>e;e++)F[2*e]=0;for(e=0;30>e;e++)O[2*e]=0;for(e=0;19>e;e++)q[2*e]=0;F[512]=1,t.gt=t.vt=0,X=Y=0}function nt(t,e){let n,r=-1,i=t[1],s=0,o=7,f=4;0===i&&(o=138,f=3),t[2*(e+1)+1]=65535;for(let c=0;e>=c;c++)n=i,i=t[2*(c+1)+1],++s<o&&n==i||(f>s?q[2*n]+=s:0!==n?(n!=r&&q[2*n]++,q[32]++):s>10?q[36]++:q[34]++,s=0,r=n,0===i?(o=138,f=3):n==i?(o=6,f=3):(o=7,f=4))}function rt(e){t.Gt[t.pending++]=e}function it(t){rt(255&t),rt(t>>>8&255)}function st(t,e){let n;const r=e;tt>16-r?(n=t,$|=n<<tt&65535,it($),$=n>>>16-tt,tt+=r-16):($|=t<<tt&65535,tt+=r)}function ot(t,e){const n=2*t;st(65535&e[n],65535&e[n+1])}function ft(t,e){let n,r,i=-1,s=t[1],o=0,f=7,c=4;for(0===s&&(f=138,c=3),n=0;e>=n;n++)if(r=s,s=t[2*(n+1)+1],++o>=f||r!=s){if(c>o)do{ot(r,q)}while(0!=--o);else 0!==r?(r!=i&&(ot(r,q),o--),ot(16,q),st(o-3,2)):o>10?(ot(18,q),st(o-11,7)):(ot(17,q),st(o-3,3));o=0,i=r,0===s?(f=138,c=3):r==s?(f=6,c=3):(f=7,c=4)}}function ct(){16==tt?(it($),$=0,tt=0):8>tt||(rt(255&$),$>>>=8,tt-=8)}function lt(e,r){let i,s,o;if(t.Jt[X]=e,t.Nt[X]=255&r,X++,0===e?F[2*r]++:(Y++,e--,F[2*(l.It[r]+256+1)]++,O[2*l.Bt(e)]++),0==(8191&X)&&j>2){for(i=8*X,s=E-V,o=0;30>o;o++)i+=O[2*o]*(5+l.Et[o]);if(i>>>=3,Y<n.floor(X/2)&&i<n.floor(s/2))return!0}return X==Q-1}function ut(e,n){let r,i,s,o,f=0;if(0!==X)do{r=t.Jt[f],i=t.Nt[f],f++,0===r?ot(i,e):(s=l.It[i],ot(s+256+1,e),o=l.Dt[s],0!==o&&(i-=l.Vt[s],st(i,o)),r--,s=l.Bt(r),ot(s,n),o=l.Et[s],0!==o&&(r-=l.Pt[s],st(r,o)))}while(X>f);ot(256,e),Z=e[513]}function at(){tt>8?it($):tt>0&&rt(255&$),$=0,tt=0}function wt(e,n,r){st(0+(r?1:0),3),((e,n)=>{at(),Z=8,it(n),it(~n),t.Gt.set(g.subarray(e,e+n),t.pending),t.pending+=n})(e,n)}function ht(e){((e,n,r)=>{let i,s,o=0;j>0?(G.ct(t),J.ct(t),o=(()=>{let e;for(nt(F,G.St),nt(O,J.St),N.ct(t),e=18;e>=3&&0===q[2*l.Rt[e]+1];e--);return t.gt+=14+3*(e+1),e})(),i=t.gt+3+7>>>3,s=t.vt+3+7>>>3,s>i||(i=s)):i=s=n+5,n+4>i||-1==e?s==i?(st(2+(r?1:0),3),ut(u.Ut,u.Lt)):(st(4+(r?1:0),3),((t,e,n)=>{let r;for(st(t-257,5),st(e-1,5),st(n-4,4),r=0;n>r;r++)st(q[2*l.Rt[r]+1],3);ft(F,t-1),ft(O,e-1)})(G.St+1,J.St+1,o+1),ut(F,O)):wt(e,n,r),et(),r&&at()})(0>V?-1:V,E-V,e),V=E,r.Qt()}function dt(){let t,e,n,i;do{if(i=v-R-E,0===i&&0===E&&0===R)i=a;else if(-1==i)i--;else if(E>=a+a-m){g.set(g.subarray(a,a+a),0),M-=a,E-=a,V-=a,t=z,n=t;do{e=65535&_[--n],_[n]=a>e?0:e-a}while(0!=--t);t=a,n=t;do{e=65535&S[--n],S[n]=a>e?0:e-a}while(0!=--t);i+=a}if(0===r.Xt)return;t=r.Yt(g,E+R,i),R+=t,3>R||(C=255&g[E],C=(C<<I^255&g[E+1])&A)}while(m>R&&0!==r.Xt)}function pt(t){let e,n,r=T,i=E,s=U;const o=E>a-m?E-(a-m):0;let f=L;const c=h,l=E+258;let u=g[i+s-1],w=g[i+s];K>U||(r>>=2),f>R&&(f=R);do{if(e=t,g[e+s]==w&&g[e+s-1]==u&&g[e]==g[i]&&g[++e]==g[i+1]){i+=2,e++;do{}while(g[++i]==g[++e]&&g[++i]==g[++e]&&g[++i]==g[++e]&&g[++i]==g[++e]&&g[++i]==g[++e]&&g[++i]==g[++e]&&g[++i]==g[++e]&&g[++i]==g[++e]&&l>i);if(n=258-(l-i),i=l-258,n>s){if(M=t,s=n,n>=f)break;u=g[i+s-1],w=g[i+s]}}}while((t=65535&S[t&c])>o&&0!=--r);return s>R?R:s}t.kt=[],t.At=[],t.yt=[],F=[],O=[],q=[],t._t=(e,n)=>{const r=t.yt,i=r[n];let s=n<<1;for(;s<=t.dt&&(s<t.dt&&k(e,r[s+1],r[s],t.kt)&&s++,!k(e,i,r[s],t.kt));)r[n]=r[s],n=s,s<<=1;r[n]=i},t.Zt=(r,l,p,y,m,k)=>(y||(y=8),m||(m=8),k||(k=0),r.$t=null,-1==l&&(l=6),1>m||m>9||8!=y||9>p||p>15||0>l||l>9||0>k||k>2?e:(r.te=t,w=p,a=1<<w,h=a-1,x=m+7,z=1<<x,A=z-1,I=n.floor((x+3-1)/3),g=new i(2*a),S=[],_=[],Q=1<<m+6,t.Gt=new i(4*Q),f=4*Q,t.Jt=new s(Q),t.Nt=new i(Q),j=l,H=k,(e=>(e.ee=e.ne=0,e.$t=null,t.pending=0,t.re=0,o=b,c=0,G.lt=F,G.wt=u.Ft,J.lt=O,J.wt=u.Ot,N.lt=q,N.wt=u.qt,$=0,tt=0,Z=8,et(),(()=>{v=2*a,_[z-1]=0;for(let t=0;z-1>t;t++)_[t]=0;W=d[j].Wt,K=d[j].Tt,L=d[j].jt,T=d[j].Ht,E=0,V=0,R=0,P=U=2,D=0,C=0})(),0))(r))),t.ie=()=>42!=o&&o!=b&&o!=y?e:(t.Nt=null,t.Jt=null,t.Gt=null,_=null,S=null,g=null,t.te=null,o==b?-3:0),t.se=(t,n,r)=>{let i=0;return-1==n&&(n=6),0>n||n>9||0>r||r>2?e:(d[j].Kt!=d[n].Kt&&0!==t.ee&&(i=t.oe(1)),j!=n&&(j=n,W=d[j].Wt,K=d[j].Tt,L=d[j].jt,T=d[j].Ht),H=r,i)},t.fe=(t,n,r)=>{let i,s=r,f=0;if(!n||42!=o)return e;if(3>s)return 0;for(s>a-m&&(s=a-m,f=r-s),g.set(n.subarray(f,f+s),0),E=s,V=s,C=255&g[0],C=(C<<I^255&g[1])&A,i=0;s-3>=i;i++)C=(C<<I^255&g[i+2])&A,S[i&h]=_[C],_[C]=i;return 0},t.oe=(n,i)=>{let s,l,k,v,x;if(i>4||0>i)return e;if(!n.ce||!n.le&&0!==n.Xt||o==y&&4!=i)return n.$t=p[4],e;if(0===n.ue)return n.$t=p[7],-5;var T;if(r=n,v=c,c=i,42==o&&(l=8+(w-8<<4)<<8,k=(j-1&255)>>1,k>3&&(k=3),l|=k<<6,0!==E&&(l|=32),l+=31-l%31,o=b,rt((T=l)>>8&255),rt(255&T)),0!==t.pending){if(r.Qt(),0===r.ue)return c=-1,0}else if(0===r.Xt&&v>=i&&4!=i)return r.$t=p[7],-5;if(o==y&&0!==r.Xt)return n.$t=p[7],-5;if(0!==r.Xt||0!==R||0!=i&&o!=y){switch(x=-1,d[j].Kt){case 0:x=(t=>{let e,n=65535;for(n>f-5&&(n=f-5);;){if(1>=R){if(dt(),0===R&&0==t)return 0;if(0===R)break}if(E+=R,R=0,e=V+n,(0===E||E>=e)&&(R=E-e,E=e,ht(!1),0===r.ue))return 0;if(E-V>=a-m&&(ht(!1),0===r.ue))return 0}return ht(4==t),0===r.ue?4==t?2:0:4==t?3:1})(i);break;case 1:x=(t=>{let e,n=0;for(;;){if(m>R){if(dt(),m>R&&0==t)return 0;if(0===R)break}if(3>R||(C=(C<<I^255&g[E+2])&A,n=65535&_[C],S[E&h]=_[C],_[C]=E),0===n||(E-n&65535)>a-m||2!=H&&(P=pt(n)),3>P)e=lt(0,255&g[E]),R--,E++;else if(e=lt(E-M,P-3),R-=P,P>W||3>R)E+=P,P=0,C=255&g[E],C=(C<<I^255&g[E+1])&A;else{P--;do{E++,C=(C<<I^255&g[E+2])&A,n=65535&_[C],S[E&h]=_[C],_[C]=E}while(0!=--P);E++}if(e&&(ht(!1),0===r.ue))return 0}return ht(4==t),0===r.ue?4==t?2:0:4==t?3:1})(i);break;case 2:x=(t=>{let e,n,i=0;for(;;){if(m>R){if(dt(),m>R&&0==t)return 0;if(0===R)break}if(3>R||(C=(C<<I^255&g[E+2])&A,i=65535&_[C],S[E&h]=_[C],_[C]=E),U=P,B=M,P=2,0!==i&&W>U&&a-m>=(E-i&65535)&&(2!=H&&(P=pt(i)),5>=P&&(1==H||3==P&&E-M>4096)&&(P=2)),3>U||P>U)if(0!==D){if(e=lt(0,255&g[E-1]),e&&ht(!1),E++,R--,0===r.ue)return 0}else D=1,E++,R--;else{n=E+R-3,e=lt(E-1-B,U-3),R-=U-1,U-=2;do{++E>n||(C=(C<<I^255&g[E+2])&A,i=65535&_[C],S[E&h]=_[C],_[C]=E)}while(0!=--U);if(D=0,P=2,E++,e&&(ht(!1),0===r.ue))return 0}}return 0!==D&&(e=lt(0,255&g[E-1]),D=0),ht(4==t),0===r.ue?4==t?2:0:4==t?3:1})(i)}if(2!=x&&3!=x||(o=y),0==x||2==x)return 0===r.ue&&(c=-1),0;if(1==x){if(1==i)st(2,3),ot(256,u.Ut),ct(),9>1+Z+10-tt&&(st(2,3),ot(256,u.Ut),ct()),Z=7;else if(wt(0,0,!1),3==i)for(s=0;z>s;s++)_[s]=0;if(r.Qt(),0===r.ue)return c=-1,0}}return 4!=i?0:1}}function v(){const t=this;t.ae=0,t.we=0,t.Xt=0,t.ee=0,t.ue=0,t.ne=0}return v.prototype={Zt:function(t,e){const n=this;return n.te=new g,e||(e=15),n.te.Zt(n,t,e)},oe:function(t){const n=this;return n.te?n.te.oe(n,t):e},ie:function(){const t=this;if(!t.te)return e;const n=t.te.ie();return t.te=null,n},se:function(t,n){const r=this;return r.te?r.te.se(r,t,n):e},fe:function(t,n){const r=this;return r.te?r.te.fe(r,t,n):e},Yt:function(t,e,n){const r=this;let i=r.Xt;return i>n&&(i=n),0===i?0:(r.Xt-=i,t.set(r.le.subarray(r.ae,r.ae+i),e),r.ae+=i,r.ee+=i,i)},Qt:function(){const t=this;let e=t.te.pending;e>t.ue&&(e=t.ue),0!==e&&(t.ce.set(t.te.Gt.subarray(t.te.re,t.te.re+e),t.we),t.we+=e,t.te.re+=e,t.ne+=e,t.ue-=e,t.te.pending-=e,0===t.te.pending&&(t.te.re=0))}},function(t){const e=new v,s=(o=t&&t.it?t.it:65536)+5*(n.floor(o/16383)+1);var o;const f=new i(s);let c=t?t.level:-1;void 0===c&&(c=-1),e.Zt(c),e.ce=f,this.append=(t,n)=>{let o,c,l=0,u=0,a=0;const w=[];if(t.length){e.ae=0,e.le=t,e.Xt=t.length;do{if(e.we=0,e.ue=s,o=e.oe(0),0!=o)throw new r("deflating: "+e.$t);e.we&&(e.we==s?w.push(new i(f)):w.push(f.slice(0,e.we))),a+=e.we,n&&e.ae>0&&e.ae!=l&&(n(e.ae),l=e.ae)}while(e.Xt>0||0===e.ue);return w.length>1?(c=new i(a),w.forEach((t=>{c.set(t,u),u+=t.length}))):c=w[0]||new i(0),c}},this.flush=()=>{let t,n,o=0,c=0;const l=[];do{if(e.we=0,e.ue=s,t=e.oe(4),1!=t&&0!=t)throw new r("deflating: "+e.$t);s-e.ue>0&&l.push(f.slice(0,e.we)),c+=e.we}while(e.Xt>0||0===e.ue);return e.ie(),n=new i(c),l.forEach((t=>{n.set(t,o),o+=t.length})),n}}})(),kt=(()=>{const t=-2,e=-3,s=-5,o=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],c=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],l=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],u=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],a=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],w=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],h=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function d(){let t,n,r,i,o,c;function l(t,n,f,l,u,a,w,h,d,p,b){let y,m,k,g,v,S,_,C,z,x,A,I,V,P,B;x=0,v=f;do{r[t[n+x]]++,x++,v--}while(0!==v);if(r[0]==f)return w[0]=-1,h[0]=0,0;for(C=h[0],S=1;15>=S&&0===r[S];S++);for(_=S,S>C&&(C=S),v=15;0!==v&&0===r[v];v--);for(k=v,C>v&&(C=v),h[0]=C,P=1<<S;v>S;S++,P<<=1)if(0>(P-=r[S]))return e;if(0>(P-=r[v]))return e;for(r[v]+=P,c[1]=S=0,x=1,V=2;0!=--v;)c[V]=S+=r[x],V++,x++;v=0,x=0;do{0!==(S=t[n+x])&&(b[c[S]++]=v),x++}while(++v<f);for(f=c[k],c[0]=v=0,x=0,g=-1,I=-C,o[0]=0,A=0,B=0;k>=_;_++)for(y=r[_];0!=y--;){for(;_>I+C;){if(g++,I+=C,B=k-I,B=B>C?C:B,(m=1<<(S=_-I))>y+1&&(m-=y+1,V=_,B>S))for(;++S<B&&(m<<=1)>r[++V];)m-=r[V];if(B=1<<S,p[0]+B>1440)return e;o[g]=A=p[0],p[0]+=B,0!==g?(c[g]=v,i[0]=S,i[1]=C,S=v>>>I-C,i[2]=A-o[g-1]-S,d.set(i,3*(o[g-1]+S))):w[0]=A}for(i[1]=_-I,f>x?b[x]<l?(i[0]=256>b[x]?0:96,i[2]=b[x++]):(i[0]=a[b[x]-l]+16+64,i[2]=u[b[x++]-l]):i[0]=192,m=1<<_-I,S=v>>>I;B>S;S+=m)d.set(i,3*(A+S));for(S=1<<_-1;0!=(v&S);S>>>=1)v^=S;for(v^=S,z=(1<<I)-1;(v&z)!=c[g];)g--,I-=C,z=(1<<I)-1}return 0!==P&&1!=k?s:0}function d(e){let s;for(t||(t=[],n=[],r=new f(16),i=[],o=new f(15),c=new f(16)),n.length<e&&(n=[]),s=0;e>s;s++)n[s]=0;for(s=0;16>s;s++)r[s]=0;for(s=0;3>s;s++)i[s]=0;o.set(r.subarray(0,15),0),c.set(r.subarray(0,16),0)}this.he=(r,i,o,f,c)=>{let u;return d(19),t[0]=0,u=l(r,0,19,19,null,null,o,i,f,t,n),u==e?c.$t="oversubscribed dynamic bit lengths tree":u!=s&&0!==i[0]||(c.$t="incomplete dynamic bit lengths tree",u=e),u},this.de=(r,i,o,f,c,p,b,y,m)=>{let k;return d(288),t[0]=0,k=l(o,0,r,257,u,a,p,f,y,t,n),0!=k||0===f[0]?(k==e?m.$t="oversubscribed literal/length tree":-4!=k&&(m.$t="incomplete literal/length tree",k=e),k):(d(288),k=l(o,r,i,0,w,h,b,c,y,t,n),0!=k||0===c[0]&&r>257?(k==e?m.$t="oversubscribed distance tree":k==s?(m.$t="incomplete distance tree",k=e):-4!=k&&(m.$t="empty distance tree with lengths",k=e),k):0)}}function p(){const n=this;let r,i,s,f,c=0,l=0,u=0,a=0,w=0,h=0,d=0,p=0,b=0,y=0;function m(t,n,r,i,s,f,c,l){let u,a,w,h,d,p,b,y,m,k,g,v,S,_,C,z;b=l.ae,y=l.Xt,d=c.pe,p=c.be,m=c.write,k=m<c.read?c.read-m-1:c.end-m,g=o[t],v=o[n];do{for(;20>p;)y--,d|=(255&l.ye(b++))<<p,p+=8;if(u=d&g,a=r,w=i,z=3*(w+u),0!==(h=a[z]))for(;;){if(d>>=a[z+1],p-=a[z+1],0!=(16&h)){for(h&=15,S=a[z+2]+(d&o[h]),d>>=h,p-=h;15>p;)y--,d|=(255&l.ye(b++))<<p,p+=8;for(u=d&v,a=s,w=f,z=3*(w+u),h=a[z];;){if(d>>=a[z+1],p-=a[z+1],0!=(16&h)){for(h&=15;h>p;)y--,d|=(255&l.ye(b++))<<p,p+=8;if(_=a[z+2]+(d&o[h]),d>>=h,p-=h,k-=S,_>m){C=m-_;do{C+=c.end}while(0>C);if(h=c.end-C,S>h){if(S-=h,m-C>0&&h>m-C)do{c.me[m++]=c.me[C++]}while(0!=--h);else c.me.set(c.me.subarray(C,C+h),m),m+=h,C+=h,h=0;C=0}}else C=m-_,m-C>0&&2>m-C?(c.me[m++]=c.me[C++],c.me[m++]=c.me[C++],S-=2):(c.me.set(c.me.subarray(C,C+2),m),m+=2,C+=2,S-=2);if(m-C>0&&S>m-C)do{c.me[m++]=c.me[C++]}while(0!=--S);else c.me.set(c.me.subarray(C,C+S),m),m+=S,C+=S,S=0;break}if(0!=(64&h))return l.$t="invalid distance code",S=l.Xt-y,S=S>p>>3?p>>3:S,y+=S,b-=S,p-=S<<3,c.pe=d,c.be=p,l.Xt=y,l.ee+=b-l.ae,l.ae=b,c.write=m,e;u+=a[z+2],u+=d&o[h],z=3*(w+u),h=a[z]}break}if(0!=(64&h))return 0!=(32&h)?(S=l.Xt-y,S=S>p>>3?p>>3:S,y+=S,b-=S,p-=S<<3,c.pe=d,c.be=p,l.Xt=y,l.ee+=b-l.ae,l.ae=b,c.write=m,1):(l.$t="invalid literal/length code",S=l.Xt-y,S=S>p>>3?p>>3:S,y+=S,b-=S,p-=S<<3,c.pe=d,c.be=p,l.Xt=y,l.ee+=b-l.ae,l.ae=b,c.write=m,e);if(u+=a[z+2],u+=d&o[h],z=3*(w+u),0===(h=a[z])){d>>=a[z+1],p-=a[z+1],c.me[m++]=a[z+2],k--;break}}else d>>=a[z+1],p-=a[z+1],c.me[m++]=a[z+2],k--}while(k>=258&&y>=10);return S=l.Xt-y,S=S>p>>3?p>>3:S,y+=S,b-=S,p-=S<<3,c.pe=d,c.be=p,l.Xt=y,l.ee+=b-l.ae,l.ae=b,c.write=m,0}n.init=(t,e,n,o,c,l)=>{r=0,d=t,p=e,s=n,b=o,f=c,y=l,i=null},n.ke=(n,k,g)=>{let v,S,_,C,z,x,A,I=0,V=0,P=0;for(P=k.ae,C=k.Xt,I=n.pe,V=n.be,z=n.write,x=z<n.read?n.read-z-1:n.end-z;;)switch(r){case 0:if(x>=258&&C>=10&&(n.pe=I,n.be=V,k.Xt=C,k.ee+=P-k.ae,k.ae=P,n.write=z,g=m(d,p,s,b,f,y,n,k),P=k.ae,C=k.Xt,I=n.pe,V=n.be,z=n.write,x=z<n.read?n.read-z-1:n.end-z,0!=g)){r=1==g?7:9;break}u=d,i=s,l=b,r=1;case 1:for(v=u;v>V;){if(0===C)return n.pe=I,n.be=V,k.Xt=C,k.ee+=P-k.ae,k.ae=P,n.write=z,n.ge(k,g);g=0,C--,I|=(255&k.ye(P++))<<V,V+=8}if(S=3*(l+(I&o[v])),I>>>=i[S+1],V-=i[S+1],_=i[S],0===_){a=i[S+2],r=6;break}if(0!=(16&_)){w=15&_,c=i[S+2],r=2;break}if(0==(64&_)){u=_,l=S/3+i[S+2];break}if(0!=(32&_)){r=7;break}return r=9,k.$t="invalid literal/length code",g=e,n.pe=I,n.be=V,k.Xt=C,k.ee+=P-k.ae,k.ae=P,n.write=z,n.ge(k,g);case 2:for(v=w;v>V;){if(0===C)return n.pe=I,n.be=V,k.Xt=C,k.ee+=P-k.ae,k.ae=P,n.write=z,n.ge(k,g);g=0,C--,I|=(255&k.ye(P++))<<V,V+=8}c+=I&o[v],I>>=v,V-=v,u=p,i=f,l=y,r=3;case 3:for(v=u;v>V;){if(0===C)return n.pe=I,n.be=V,k.Xt=C,k.ee+=P-k.ae,k.ae=P,n.write=z,n.ge(k,g);g=0,C--,I|=(255&k.ye(P++))<<V,V+=8}if(S=3*(l+(I&o[v])),I>>=i[S+1],V-=i[S+1],_=i[S],0!=(16&_)){w=15&_,h=i[S+2],r=4;break}if(0==(64&_)){u=_,l=S/3+i[S+2];break}return r=9,k.$t="invalid distance code",g=e,n.pe=I,n.be=V,k.Xt=C,k.ee+=P-k.ae,k.ae=P,n.write=z,n.ge(k,g);case 4:for(v=w;v>V;){if(0===C)return n.pe=I,n.be=V,k.Xt=C,k.ee+=P-k.ae,k.ae=P,n.write=z,n.ge(k,g);g=0,C--,I|=(255&k.ye(P++))<<V,V+=8}h+=I&o[v],I>>=v,V-=v,r=5;case 5:for(A=z-h;0>A;)A+=n.end;for(;0!==c;){if(0===x&&(z==n.end&&0!==n.read&&(z=0,x=z<n.read?n.read-z-1:n.end-z),0===x&&(n.write=z,g=n.ge(k,g),z=n.write,x=z<n.read?n.read-z-1:n.end-z,z==n.end&&0!==n.read&&(z=0,x=z<n.read?n.read-z-1:n.end-z),0===x)))return n.pe=I,n.be=V,k.Xt=C,k.ee+=P-k.ae,k.ae=P,n.write=z,n.ge(k,g);n.me[z++]=n.me[A++],x--,A==n.end&&(A=0),c--}r=0;break;case 6:if(0===x&&(z==n.end&&0!==n.read&&(z=0,x=z<n.read?n.read-z-1:n.end-z),0===x&&(n.write=z,g=n.ge(k,g),z=n.write,x=z<n.read?n.read-z-1:n.end-z,z==n.end&&0!==n.read&&(z=0,x=z<n.read?n.read-z-1:n.end-z),0===x)))return n.pe=I,n.be=V,k.Xt=C,k.ee+=P-k.ae,k.ae=P,n.write=z,n.ge(k,g);g=0,n.me[z++]=a,x--,r=0;break;case 7:if(V>7&&(V-=8,C++,P--),n.write=z,g=n.ge(k,g),z=n.write,x=z<n.read?n.read-z-1:n.end-z,n.read!=n.write)return n.pe=I,n.be=V,k.Xt=C,k.ee+=P-k.ae,k.ae=P,n.write=z,n.ge(k,g);r=8;case 8:return g=1,n.pe=I,n.be=V,k.Xt=C,k.ee+=P-k.ae,k.ae=P,n.write=z,n.ge(k,g);case 9:return g=e,n.pe=I,n.be=V,k.Xt=C,k.ee+=P-k.ae,k.ae=P,n.write=z,n.ge(k,g);default:return g=t,n.pe=I,n.be=V,k.Xt=C,k.ee+=P-k.ae,k.ae=P,n.write=z,n.ge(k,g)}},n.ve=()=>{}}d.Se=(t,e,n,r)=>(t[0]=9,e[0]=5,n[0]=c,r[0]=l,0);const b=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function y(n,r){const c=this;let l,u=0,a=0,w=0,h=0;const y=[0],m=[0],k=new p;let g=0,v=new f(4320);const S=new d;c.be=0,c.pe=0,c.me=new i(r),c.end=r,c.read=0,c.write=0,c.reset=(t,e)=>{e&&(e[0]=0),6==u&&k.ve(t),u=0,c.be=0,c.pe=0,c.read=c.write=0},c.reset(n,null),c.ge=(t,e)=>{let n,r,i;return r=t.we,i=c.read,n=(i>c.write?c.end:c.write)-i,n>t.ue&&(n=t.ue),0!==n&&e==s&&(e=0),t.ue-=n,t.ne+=n,t.ce.set(c.me.subarray(i,i+n),r),r+=n,i+=n,i==c.end&&(i=0,c.write==c.end&&(c.write=0),n=c.write-i,n>t.ue&&(n=t.ue),0!==n&&e==s&&(e=0),t.ue-=n,t.ne+=n,t.ce.set(c.me.subarray(i,i+n),r),r+=n,i+=n),t.we=r,c.read=i,e},c.ke=(n,r)=>{let i,s,f,p,_,C,z,x;for(p=n.ae,_=n.Xt,s=c.pe,f=c.be,C=c.write,z=C<c.read?c.read-C-1:c.end-C;;){let A,I,V,P,B,D,E,M;switch(u){case 0:for(;3>f;){if(0===_)return c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,c.ge(n,r);r=0,_--,s|=(255&n.ye(p++))<<f,f+=8}switch(i=7&s,g=1&i,i>>>1){case 0:s>>>=3,f-=3,i=7&f,s>>>=i,f-=i,u=1;break;case 1:A=[],I=[],V=[[]],P=[[]],d.Se(A,I,V,P),k.init(A[0],I[0],V[0],0,P[0],0),s>>>=3,f-=3,u=6;break;case 2:s>>>=3,f-=3,u=3;break;case 3:return s>>>=3,f-=3,u=9,n.$t="invalid block type",r=e,c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,c.ge(n,r)}break;case 1:for(;32>f;){if(0===_)return c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,c.ge(n,r);r=0,_--,s|=(255&n.ye(p++))<<f,f+=8}if((~s>>>16&65535)!=(65535&s))return u=9,n.$t="invalid stored block lengths",r=e,c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,c.ge(n,r);a=65535&s,s=f=0,u=0!==a?2:0!==g?7:0;break;case 2:if(0===_)return c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,c.ge(n,r);if(0===z&&(C==c.end&&0!==c.read&&(C=0,z=C<c.read?c.read-C-1:c.end-C),0===z&&(c.write=C,r=c.ge(n,r),C=c.write,z=C<c.read?c.read-C-1:c.end-C,C==c.end&&0!==c.read&&(C=0,z=C<c.read?c.read-C-1:c.end-C),0===z)))return c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,c.ge(n,r);if(r=0,i=a,i>_&&(i=_),i>z&&(i=z),c.me.set(n.Yt(p,i),C),p+=i,_-=i,C+=i,z-=i,0!=(a-=i))break;u=0!==g?7:0;break;case 3:for(;14>f;){if(0===_)return c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,c.ge(n,r);r=0,_--,s|=(255&n.ye(p++))<<f,f+=8}if(w=i=16383&s,(31&i)>29||(i>>5&31)>29)return u=9,n.$t="too many length or distance symbols",r=e,c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,c.ge(n,r);if(i=258+(31&i)+(i>>5&31),!l||l.length<i)l=[];else for(x=0;i>x;x++)l[x]=0;s>>>=14,f-=14,h=0,u=4;case 4:for(;4+(w>>>10)>h;){for(;3>f;){if(0===_)return c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,c.ge(n,r);r=0,_--,s|=(255&n.ye(p++))<<f,f+=8}l[b[h++]]=7&s,s>>>=3,f-=3}for(;19>h;)l[b[h++]]=0;if(y[0]=7,i=S.he(l,y,m,v,n),0!=i)return(r=i)==e&&(l=null,u=9),c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,c.ge(n,r);h=0,u=5;case 5:for(;i=w,258+(31&i)+(i>>5&31)>h;){let t,a;for(i=y[0];i>f;){if(0===_)return c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,c.ge(n,r);r=0,_--,s|=(255&n.ye(p++))<<f,f+=8}if(i=v[3*(m[0]+(s&o[i]))+1],a=v[3*(m[0]+(s&o[i]))+2],16>a)s>>>=i,f-=i,l[h++]=a;else{for(x=18==a?7:a-14,t=18==a?11:3;i+x>f;){if(0===_)return c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,c.ge(n,r);r=0,_--,s|=(255&n.ye(p++))<<f,f+=8}if(s>>>=i,f-=i,t+=s&o[x],s>>>=x,f-=x,x=h,i=w,x+t>258+(31&i)+(i>>5&31)||16==a&&1>x)return l=null,u=9,n.$t="invalid bit length repeat",r=e,c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,c.ge(n,r);a=16==a?l[x-1]:0;do{l[x++]=a}while(0!=--t);h=x}}if(m[0]=-1,B=[],D=[],E=[],M=[],B[0]=9,D[0]=6,i=w,i=S.de(257+(31&i),1+(i>>5&31),l,B,D,E,M,v,n),0!=i)return i==e&&(l=null,u=9),r=i,c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,c.ge(n,r);k.init(B[0],D[0],v,E[0],v,M[0]),u=6;case 6:if(c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,1!=(r=k.ke(c,n,r)))return c.ge(n,r);if(r=0,k.ve(n),p=n.ae,_=n.Xt,s=c.pe,f=c.be,C=c.write,z=C<c.read?c.read-C-1:c.end-C,0===g){u=0;break}u=7;case 7:if(c.write=C,r=c.ge(n,r),C=c.write,z=C<c.read?c.read-C-1:c.end-C,c.read!=c.write)return c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,c.ge(n,r);u=8;case 8:return r=1,c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,c.ge(n,r);case 9:return r=e,c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,c.ge(n,r);default:return r=t,c.pe=s,c.be=f,n.Xt=_,n.ee+=p-n.ae,n.ae=p,c.write=C,c.ge(n,r)}}},c.ve=t=>{c.reset(t,null),c.me=null,v=null},c._e=(t,e,n)=>{c.me.set(t.subarray(e,e+n),0),c.read=c.write=n},c.Ce=()=>1==u?1:0}const m=13,k=[0,0,255,255];function g(){const n=this;function r(e){return e&&e.ze?(e.ee=e.ne=0,e.$t=null,e.ze.mode=7,e.ze.xe.reset(e,null),0):t}n.mode=0,n.method=0,n.Ae=[0],n.Ie=0,n.marker=0,n.Ve=0,n.Pe=t=>(n.xe&&n.xe.ve(t),n.xe=null,0),n.Be=(e,i)=>(e.$t=null,n.xe=null,8>i||i>15?(n.Pe(e),t):(n.Ve=i,e.ze.xe=new y(e,1<<i),r(e),0)),n.De=(n,r)=>{let i,o;if(!n||!n.ze||!n.le)return t;const f=n.ze;for(r=4==r?s:0,i=s;;)switch(f.mode){case 0:if(0===n.Xt)return i;if(i=r,n.Xt--,n.ee++,8!=(15&(f.method=n.ye(n.ae++)))){f.mode=m,n.$t="unknown compression method",f.marker=5;break}if(8+(f.method>>4)>f.Ve){f.mode=m,n.$t="invalid win size",f.marker=5;break}f.mode=1;case 1:if(0===n.Xt)return i;if(i=r,n.Xt--,n.ee++,o=255&n.ye(n.ae++),((f.method<<8)+o)%31!=0){f.mode=m,n.$t="incorrect header check",f.marker=5;break}if(0==(32&o)){f.mode=7;break}f.mode=2;case 2:if(0===n.Xt)return i;i=r,n.Xt--,n.ee++,f.Ie=(255&n.ye(n.ae++))<<24&4278190080,f.mode=3;case 3:if(0===n.Xt)return i;i=r,n.Xt--,n.ee++,f.Ie+=(255&n.ye(n.ae++))<<16&16711680,f.mode=4;case 4:if(0===n.Xt)return i;i=r,n.Xt--,n.ee++,f.Ie+=(255&n.ye(n.ae++))<<8&65280,f.mode=5;case 5:return 0===n.Xt?i:(i=r,n.Xt--,n.ee++,f.Ie+=255&n.ye(n.ae++),f.mode=6,2);case 6:return f.mode=m,n.$t="need dictionary",f.marker=0,t;case 7:if(i=f.xe.ke(n,i),i==e){f.mode=m,f.marker=0;break}if(0==i&&(i=r),1!=i)return i;i=r,f.xe.reset(n,f.Ae),f.mode=12;case 12:return n.Xt=0,1;case m:return e;default:return t}},n.Ee=(e,n,r)=>{let i=0,s=r;if(!e||!e.ze||6!=e.ze.mode)return t;const o=e.ze;return s<1<<o.Ve||(s=(1<<o.Ve)-1,i=r-s),o.xe._e(n,i,s),o.mode=7,0},n.Me=n=>{let i,o,f,c,l;if(!n||!n.ze)return t;const u=n.ze;if(u.mode!=m&&(u.mode=m,u.marker=0),0===(i=n.Xt))return s;for(o=n.ae,f=u.marker;0!==i&&4>f;)n.ye(o)==k[f]?f++:f=0!==n.ye(o)?0:4-f,o++,i--;return n.ee+=o-n.ae,n.ae=o,n.Xt=i,u.marker=f,4!=f?e:(c=n.ee,l=n.ne,r(n),n.ee=c,n.ne=l,u.mode=7,0)},n.Re=e=>e&&e.ze&&e.ze.xe?e.ze.xe.Ce():t}function v(){}return v.prototype={Be:function(t){const e=this;return e.ze=new g,t||(t=15),e.ze.Be(e,t)},De:function(e){const n=this;return n.ze?n.ze.De(n,e):t},Pe:function(){const e=this;if(!e.ze)return t;const n=e.ze.Pe(e);return e.ze=null,n},Me:function(){const e=this;return e.ze?e.ze.Me(e):t},Ee:function(e,n){const r=this;return r.ze?r.ze.Ee(r,e,n):t},ye:function(t){return this.le[t]},Yt:function(t,e){return this.le.subarray(t,t+e)}},function(t){const e=new v,o=t&&t.it?n.floor(2*t.it):131072,f=new i(o);let c=!1;e.Be(),e.ce=f,this.append=(t,n)=>{const l=[];let u,a,w=0,h=0,d=0;if(0!==t.length){e.ae=0,e.le=t,e.Xt=t.length;do{if(e.we=0,e.ue=o,0!==e.Xt||c||(e.ae=0,c=!0),u=e.De(0),c&&u===s){if(0!==e.Xt)throw new r("inflating: bad input")}else if(0!==u&&1!==u)throw new r("inflating: "+e.$t);if((c||1===u)&&e.Xt===t.length)throw new r("inflating: bad input");e.we&&(e.we===o?l.push(new i(f)):l.push(f.slice(0,e.we))),d+=e.we,n&&e.ae>0&&e.ae!=w&&(n(e.ae),w=e.ae)}while(e.Xt>0||0===e.ue);return l.length>1?(a=new i(d),l.forEach((t=>{a.set(t,h),h+=t.length}))):a=l[0]||new i(0),a}},this.flush=()=>{e.Pe()}}})();self.initCodec=()=>{self.Deflate=mt,self.Inflate=kt};\n'], { type: "text/javascript" }));
    e2({ workerScripts: { inflate: [t], deflate: [t] } });
  }
};
const DEFAULT_CHUNK_SIZE = 64 * 1024;
class Stream {
  constructor() {
    this.size = 0;
  }
  init() {
    this.initialized = true;
  }
}
class Reader extends Stream {
  getStream({ offset, size, chunkSize } = { offset: 0, chunkSize: DEFAULT_CHUNK_SIZE }) {
    const reader = this;
    return new ReadableStream({
      start() {
        this.chunkOffset = 0;
      },
      async pull(controller) {
        const { chunkOffset } = this;
        controller.enqueue(await reader.readUint8Array(offset + chunkOffset, Math.min(chunkSize, size() - chunkOffset)));
        if (chunkOffset + chunkSize > size()) {
          controller.close();
        } else {
          this.chunkOffset += chunkSize;
        }
      }
    });
  }
}
class WriterStream extends Stream {
  getStream() {
    const writer = this;
    return new WritableStream({
      write(chunk) {
        return writer.writeUint8Array(chunk);
      }
    });
  }
}
class Writer extends WriterStream {
  writeUint8Array(array) {
    this.size += array.length;
  }
}
class BlobReader extends Reader {
  constructor(blob) {
    super();
    this.blob = blob;
    this.size = blob.size;
  }
  async readUint8Array(offset, length) {
    const reader = this;
    if (reader.blob.arrayBuffer) {
      return new Uint8Array(await reader.blob.slice(offset, offset + length).arrayBuffer());
    } else {
      const reader2 = new FileReader();
      return new Promise((resolve2, reject2) => {
        reader2.onload = (event) => resolve2(new Uint8Array(event.target.result));
        reader2.onerror = () => reject2(reader2.error);
        reader2.readAsArrayBuffer(reader2.blob.slice(offset, offset + length));
      });
    }
  }
}
class BlobWriter extends Writer {
  constructor(contentType) {
    super();
    this.contentType = contentType;
    this.arrayBuffersMaxlength = 8;
    initArrayBuffers(this);
  }
  writeUint8Array(array) {
    super.writeUint8Array(array);
    const writer = this;
    if (writer.arrayBuffers.length == writer.arrayBuffersMaxlength) {
      flushArrayBuffers(writer);
    }
    writer.arrayBuffers.push(array.buffer);
  }
  getData() {
    const writer = this;
    if (!writer.blob) {
      if (writer.arrayBuffers.length) {
        flushArrayBuffers(writer);
      }
      writer.blob = writer.pendingBlob;
      initArrayBuffers(writer);
    }
    return writer.blob;
  }
}
function initArrayBuffers(blobWriter) {
  blobWriter.pendingBlob = new Blob([], { type: blobWriter.contentType });
  blobWriter.arrayBuffers = [];
}
function flushArrayBuffers(blobWriter) {
  blobWriter.pendingBlob = new Blob([blobWriter.pendingBlob, ...blobWriter.arrayBuffers], { type: blobWriter.contentType });
  blobWriter.arrayBuffers = [];
}
const MAX_32_BITS = 4294967295;
const MAX_16_BITS = 65535;
const COMPRESSION_METHOD_DEFLATE = 8;
const COMPRESSION_METHOD_STORE = 0;
const COMPRESSION_METHOD_AES = 99;
const LOCAL_FILE_HEADER_SIGNATURE = 67324752;
const CENTRAL_FILE_HEADER_SIGNATURE = 33639248;
const END_OF_CENTRAL_DIR_SIGNATURE = 101010256;
const ZIP64_END_OF_CENTRAL_DIR_SIGNATURE = 101075792;
const ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE = 117853008;
const END_OF_CENTRAL_DIR_LENGTH = 22;
const ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH = 20;
const ZIP64_END_OF_CENTRAL_DIR_LENGTH = 56;
const EXTRAFIELD_TYPE_ZIP64 = 1;
const EXTRAFIELD_TYPE_AES = 39169;
const EXTRAFIELD_TYPE_NTFS = 10;
const EXTRAFIELD_TYPE_NTFS_TAG1 = 1;
const EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP = 21589;
const EXTRAFIELD_TYPE_UNICODE_PATH = 28789;
const EXTRAFIELD_TYPE_UNICODE_COMMENT = 25461;
const BITFLAG_ENCRYPTED = 1;
const BITFLAG_LEVEL = 6;
const BITFLAG_DATA_DESCRIPTOR = 8;
const BITFLAG_LANG_ENCODING_FLAG = 2048;
const FILE_ATTR_MSDOS_DIR_MASK = 16;
const DIRECTORY_SIGNATURE = "/";
const CP437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0 ".split("");
var decodeCP437 = (stringValue) => {
  let result = "";
  for (let indexCharacter = 0; indexCharacter < stringValue.length; indexCharacter++) {
    result += CP437[stringValue[indexCharacter]];
  }
  return result;
};
function decodeText(value, encoding) {
  if (encoding && encoding.trim().toLowerCase() == "cp437") {
    return decodeCP437(value);
  } else if (typeof TextDecoder == "undefined") {
    const fileReader = new FileReader();
    return new Promise((resolve2, reject2) => {
      fileReader.onload = (event) => resolve2(event.target.result);
      fileReader.onerror = () => reject2(fileReader.error);
      fileReader.readAsText(new Blob([value]));
    });
  } else {
    return new TextDecoder(encoding).decode(value);
  }
}
const PROPERTY_NAMES = [
  "filename",
  "rawFilename",
  "directory",
  "encrypted",
  "compressedSize",
  "uncompressedSize",
  "lastModDate",
  "rawLastModDate",
  "comment",
  "rawComment",
  "signature",
  "extraField",
  "rawExtraField",
  "bitFlag",
  "extraFieldZip64",
  "extraFieldUnicodePath",
  "extraFieldUnicodeComment",
  "extraFieldAES",
  "filenameUTF8",
  "commentUTF8",
  "offset",
  "zip64",
  "compressionMethod",
  "extraFieldNTFS",
  "lastAccessDate",
  "creationDate",
  "extraFieldExtendedTimestamp",
  "version",
  "versionMadeBy",
  "msDosCompatible",
  "internalFileAttribute",
  "externalFileAttribute"
];
class Entry {
  constructor(data) {
    PROPERTY_NAMES.forEach((name) => this[name] = data[name]);
  }
}
const ERR_BAD_FORMAT = "File format is not recognized";
const ERR_EOCDR_NOT_FOUND = "End of central directory not found";
const ERR_EOCDR_ZIP64_NOT_FOUND = "End of Zip64 central directory not found";
const ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND = "End of Zip64 central directory locator not found";
const ERR_CENTRAL_DIRECTORY_NOT_FOUND = "Central directory header not found";
const ERR_LOCAL_FILE_HEADER_NOT_FOUND = "Local file header not found";
const ERR_EXTRAFIELD_ZIP64_NOT_FOUND = "Zip64 extra field not found";
const ERR_ENCRYPTED = "File contains encrypted entry";
const ERR_UNSUPPORTED_ENCRYPTION = "Encryption method not supported";
const ERR_UNSUPPORTED_COMPRESSION = "Compression method not supported";
const CHARSET_UTF8 = "utf-8";
const CHARSET_CP437 = "cp437";
const ZIP64_PROPERTIES = ["uncompressedSize", "compressedSize", "offset"];
class ZipReader {
  constructor(reader, options = {}) {
    Object.assign(this, {
      reader,
      options,
      config: getConfiguration()
    });
  }
  async *getEntriesGenerator(options = {}) {
    const zipReader = this;
    const reader = zipReader.reader;
    if (!reader.initialized) {
      await reader.init();
    }
    if (reader.size < END_OF_CENTRAL_DIR_LENGTH) {
      throw new Error(ERR_BAD_FORMAT);
    }
    const endOfDirectoryInfo = await seekSignature(reader, END_OF_CENTRAL_DIR_SIGNATURE, reader.size, END_OF_CENTRAL_DIR_LENGTH, MAX_16_BITS * 16);
    if (!endOfDirectoryInfo) {
      throw new Error(ERR_EOCDR_NOT_FOUND);
    }
    const endOfDirectoryView = getDataView(endOfDirectoryInfo);
    let directoryDataLength = getUint32(endOfDirectoryView, 12);
    let directoryDataOffset = getUint32(endOfDirectoryView, 16);
    let filesLength = getUint16(endOfDirectoryView, 8);
    let prependedDataLength = 0;
    if (directoryDataOffset == MAX_32_BITS || directoryDataLength == MAX_32_BITS || filesLength == MAX_16_BITS) {
      const endOfDirectoryLocatorArray = await readUint8Array(reader, endOfDirectoryInfo.offset - ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH);
      const endOfDirectoryLocatorView = getDataView(endOfDirectoryLocatorArray);
      if (getUint32(endOfDirectoryLocatorView, 0) != ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE) {
        throw new Error(ERR_EOCDR_ZIP64_NOT_FOUND);
      }
      directoryDataOffset = getBigUint64(endOfDirectoryLocatorView, 8);
      let endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH);
      let endOfDirectoryView2 = getDataView(endOfDirectoryArray);
      const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH - ZIP64_END_OF_CENTRAL_DIR_LENGTH;
      if (getUint32(endOfDirectoryView2, 0) != ZIP64_END_OF_CENTRAL_DIR_SIGNATURE && directoryDataOffset != expectedDirectoryDataOffset) {
        const originalDirectoryDataOffset = directoryDataOffset;
        directoryDataOffset = expectedDirectoryDataOffset;
        prependedDataLength = directoryDataOffset - originalDirectoryDataOffset;
        endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH);
        endOfDirectoryView2 = getDataView(endOfDirectoryArray);
      }
      if (getUint32(endOfDirectoryView2, 0) != ZIP64_END_OF_CENTRAL_DIR_SIGNATURE) {
        throw new Error(ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND);
      }
      filesLength = getBigUint64(endOfDirectoryView2, 32);
      directoryDataLength = getBigUint64(endOfDirectoryView2, 40);
      directoryDataOffset -= directoryDataLength;
    }
    if (directoryDataOffset < 0 || directoryDataOffset >= reader.size) {
      throw new Error(ERR_BAD_FORMAT);
    }
    let offset = 0;
    let directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength);
    let directoryView = getDataView(directoryArray);
    if (directoryDataLength) {
      const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - directoryDataLength;
      if (getUint32(directoryView, offset) != CENTRAL_FILE_HEADER_SIGNATURE && directoryDataOffset != expectedDirectoryDataOffset) {
        const originalDirectoryDataOffset = directoryDataOffset;
        directoryDataOffset = expectedDirectoryDataOffset;
        prependedDataLength = directoryDataOffset - originalDirectoryDataOffset;
        directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength);
        directoryView = getDataView(directoryArray);
      }
    }
    if (directoryDataOffset < 0 || directoryDataOffset >= reader.size) {
      throw new Error(ERR_BAD_FORMAT);
    }
    for (let indexFile = 0; indexFile < filesLength; indexFile++) {
      const fileEntry = new ZipEntry(reader, zipReader.config, zipReader.options);
      if (getUint32(directoryView, offset) != CENTRAL_FILE_HEADER_SIGNATURE) {
        throw new Error(ERR_CENTRAL_DIRECTORY_NOT_FOUND);
      }
      readCommonHeader(fileEntry, directoryView, offset + 6);
      const languageEncodingFlag = Boolean(fileEntry.bitFlag.languageEncodingFlag);
      const filenameOffset = offset + 46;
      const extraFieldOffset = filenameOffset + fileEntry.filenameLength;
      const commentOffset = extraFieldOffset + fileEntry.extraFieldLength;
      const versionMadeBy = getUint16(directoryView, offset + 4);
      const msDosCompatible = (versionMadeBy & 0) == 0;
      Object.assign(fileEntry, {
        versionMadeBy,
        msDosCompatible,
        compressedSize: 0,
        uncompressedSize: 0,
        commentLength: getUint16(directoryView, offset + 32),
        directory: msDosCompatible && (getUint8(directoryView, offset + 38) & FILE_ATTR_MSDOS_DIR_MASK) == FILE_ATTR_MSDOS_DIR_MASK,
        offset: getUint32(directoryView, offset + 42) + prependedDataLength,
        internalFileAttribute: getUint32(directoryView, offset + 34),
        externalFileAttribute: getUint32(directoryView, offset + 38),
        rawFilename: directoryArray.subarray(filenameOffset, extraFieldOffset),
        filenameUTF8: languageEncodingFlag,
        commentUTF8: languageEncodingFlag,
        rawExtraField: directoryArray.subarray(extraFieldOffset, commentOffset)
      });
      const endOffset = commentOffset + fileEntry.commentLength;
      fileEntry.rawComment = directoryArray.subarray(commentOffset, endOffset);
      const filenameEncoding = getOptionValue(zipReader, options, "filenameEncoding");
      const commentEncoding = getOptionValue(zipReader, options, "commentEncoding");
      const [filename, comment] = await Promise.all([
        decodeText(fileEntry.rawFilename, fileEntry.filenameUTF8 ? CHARSET_UTF8 : filenameEncoding || CHARSET_CP437),
        decodeText(fileEntry.rawComment, fileEntry.commentUTF8 ? CHARSET_UTF8 : commentEncoding || CHARSET_CP437)
      ]);
      fileEntry.filename = filename;
      fileEntry.comment = comment;
      if (!fileEntry.directory && fileEntry.filename.endsWith(DIRECTORY_SIGNATURE)) {
        fileEntry.directory = true;
      }
      await readCommonFooter(fileEntry, fileEntry, directoryView, offset + 6);
      const entry = new Entry(fileEntry);
      entry.getData = (writer, options2) => fileEntry.getData(writer, entry, options2);
      offset = endOffset;
      if (options.onprogress) {
        try {
          options.onprogress(indexFile + 1, filesLength, new Entry(fileEntry));
        } catch (_error) {
        }
      }
      yield entry;
    }
    return true;
  }
  async getEntries(options = {}) {
    const entries = [];
    const iterator = this.getEntriesGenerator(options);
    let result = iterator.next();
    while (!(await result).done) {
      entries.push((await result).value);
      result = iterator.next();
    }
    return entries;
  }
  async close() {
  }
}
class ZipEntry {
  constructor(reader, config2, options) {
    Object.assign(this, {
      reader,
      config: config2,
      options
    });
  }
  async getData(writer, fileEntry, options = {}) {
    const zipEntry = this;
    const {
      reader,
      offset,
      extraFieldAES,
      compressionMethod,
      config: config2,
      bitFlag,
      signature,
      rawLastModDate,
      compressedSize
    } = zipEntry;
    const localDirectory = zipEntry.localDirectory = {};
    if (!reader.initialized) {
      await reader.init();
    }
    let dataArray = await readUint8Array(reader, offset, 30);
    const dataView = getDataView(dataArray);
    let password = getOptionValue(zipEntry, options, "password");
    password = password && password.length && password;
    if (extraFieldAES) {
      if (extraFieldAES.originalCompressionMethod != COMPRESSION_METHOD_AES) {
        throw new Error(ERR_UNSUPPORTED_COMPRESSION);
      }
    }
    if (compressionMethod != COMPRESSION_METHOD_STORE && compressionMethod != COMPRESSION_METHOD_DEFLATE) {
      throw new Error(ERR_UNSUPPORTED_COMPRESSION);
    }
    if (getUint32(dataView, 0) != LOCAL_FILE_HEADER_SIGNATURE) {
      throw new Error(ERR_LOCAL_FILE_HEADER_NOT_FOUND);
    }
    readCommonHeader(localDirectory, dataView, 4);
    dataArray = await readUint8Array(reader, offset, 30 + localDirectory.filenameLength + localDirectory.extraFieldLength);
    localDirectory.rawExtraField = dataArray.subarray(30 + localDirectory.filenameLength);
    await readCommonFooter(zipEntry, localDirectory, dataView, 4);
    fileEntry.lastAccessDate = localDirectory.lastAccessDate;
    fileEntry.creationDate = localDirectory.creationDate;
    const encrypted = zipEntry.encrypted && localDirectory.encrypted;
    const zipCrypto = encrypted && !extraFieldAES;
    if (encrypted) {
      if (!zipCrypto && extraFieldAES.strength === void 0) {
        throw new Error(ERR_UNSUPPORTED_ENCRYPTION);
      } else if (!password) {
        throw new Error(ERR_ENCRYPTED);
      }
    }
    const dataOffset = offset + 30 + localDirectory.filenameLength + localDirectory.extraFieldLength;
    const size = () => compressedSize;
    const readable = reader.getStream({ offset: dataOffset, size, chunkSize: getChunkSize(config2) });
    const writable = writer.getStream();
    const signal = getOptionValue(zipEntry, options, "signal");
    if (!writer.initialized) {
      await writer.init();
    }
    await runCodec(config2.Inflate, readable, writable, {
      codecType: CODEC_INFLATE,
      password,
      zipCrypto,
      encryptionStrength: extraFieldAES && extraFieldAES.strength,
      signed: getOptionValue(zipEntry, options, "checkSignature"),
      passwordVerification: zipCrypto && (bitFlag.dataDescriptor ? rawLastModDate >>> 8 & 255 : signature >>> 24 & 255),
      signature,
      compressed: compressionMethod != 0,
      encrypted,
      useWebWorkers: getOptionValue(zipEntry, options, "useWebWorkers"),
      useCompressionStream: getOptionValue(zipEntry, options, "useCompressionStream")
    }, config2, { signal, onprogress: options.onprogress, size });
    return writer.getData();
  }
}
function readCommonHeader(directory, dataView, offset) {
  const rawBitFlag = directory.rawBitFlag = getUint16(dataView, offset + 2);
  const encrypted = (rawBitFlag & BITFLAG_ENCRYPTED) == BITFLAG_ENCRYPTED;
  const rawLastModDate = getUint32(dataView, offset + 6);
  Object.assign(directory, {
    encrypted,
    version: getUint16(dataView, offset),
    bitFlag: {
      level: (rawBitFlag & BITFLAG_LEVEL) >> 1,
      dataDescriptor: (rawBitFlag & BITFLAG_DATA_DESCRIPTOR) == BITFLAG_DATA_DESCRIPTOR,
      languageEncodingFlag: (rawBitFlag & BITFLAG_LANG_ENCODING_FLAG) == BITFLAG_LANG_ENCODING_FLAG
    },
    rawLastModDate,
    lastModDate: getDate(rawLastModDate),
    filenameLength: getUint16(dataView, offset + 22),
    extraFieldLength: getUint16(dataView, offset + 24)
  });
}
async function readCommonFooter(fileEntry, directory, dataView, offset) {
  const rawExtraField = directory.rawExtraField;
  const extraField = directory.extraField = /* @__PURE__ */ new Map();
  const rawExtraFieldView = getDataView(new Uint8Array(rawExtraField));
  let offsetExtraField = 0;
  try {
    while (offsetExtraField < rawExtraField.length) {
      const type = getUint16(rawExtraFieldView, offsetExtraField);
      const size = getUint16(rawExtraFieldView, offsetExtraField + 2);
      extraField.set(type, {
        type,
        data: rawExtraField.slice(offsetExtraField + 4, offsetExtraField + 4 + size)
      });
      offsetExtraField += 4 + size;
    }
  } catch (_error) {
  }
  const compressionMethod = getUint16(dataView, offset + 4);
  directory.signature = getUint32(dataView, offset + 10);
  directory.uncompressedSize = getUint32(dataView, offset + 18);
  directory.compressedSize = getUint32(dataView, offset + 14);
  const extraFieldZip64 = extraField.get(EXTRAFIELD_TYPE_ZIP64);
  if (extraFieldZip64) {
    readExtraFieldZip64(extraFieldZip64, directory);
    directory.extraFieldZip64 = extraFieldZip64;
  }
  const extraFieldUnicodePath = extraField.get(EXTRAFIELD_TYPE_UNICODE_PATH);
  if (extraFieldUnicodePath) {
    await readExtraFieldUnicode(extraFieldUnicodePath, "filename", "rawFilename", directory, fileEntry);
    directory.extraFieldUnicodePath = extraFieldUnicodePath;
  }
  const extraFieldUnicodeComment = extraField.get(EXTRAFIELD_TYPE_UNICODE_COMMENT);
  if (extraFieldUnicodeComment) {
    await readExtraFieldUnicode(extraFieldUnicodeComment, "comment", "rawComment", directory, fileEntry);
    directory.extraFieldUnicodeComment = extraFieldUnicodeComment;
  }
  const extraFieldAES = extraField.get(EXTRAFIELD_TYPE_AES);
  if (extraFieldAES) {
    readExtraFieldAES(extraFieldAES, directory, compressionMethod);
    directory.extraFieldAES = extraFieldAES;
  } else {
    directory.compressionMethod = compressionMethod;
  }
  const extraFieldNTFS = extraField.get(EXTRAFIELD_TYPE_NTFS);
  if (extraFieldNTFS) {
    readExtraFieldNTFS(extraFieldNTFS, directory);
    directory.extraFieldNTFS = extraFieldNTFS;
  }
  const extraFieldExtendedTimestamp = extraField.get(EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);
  if (extraFieldExtendedTimestamp) {
    readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory);
    directory.extraFieldExtendedTimestamp = extraFieldExtendedTimestamp;
  }
}
function readExtraFieldZip64(extraFieldZip64, directory) {
  directory.zip64 = true;
  const extraFieldView = getDataView(extraFieldZip64.data);
  extraFieldZip64.values = [];
  for (let indexValue = 0; indexValue < Math.floor(extraFieldZip64.data.length / 8); indexValue++) {
    extraFieldZip64.values.push(getBigUint64(extraFieldView, 0 + indexValue * 8));
  }
  const missingProperties = ZIP64_PROPERTIES.filter((propertyName) => directory[propertyName] == MAX_32_BITS);
  for (let indexMissingProperty = 0; indexMissingProperty < missingProperties.length; indexMissingProperty++) {
    extraFieldZip64[missingProperties[indexMissingProperty]] = extraFieldZip64.values[indexMissingProperty];
  }
  ZIP64_PROPERTIES.forEach((propertyName) => {
    if (directory[propertyName] == MAX_32_BITS) {
      if (extraFieldZip64[propertyName] !== void 0) {
        directory[propertyName] = extraFieldZip64[propertyName];
      } else {
        throw new Error(ERR_EXTRAFIELD_ZIP64_NOT_FOUND);
      }
    }
  });
}
async function readExtraFieldUnicode(extraFieldUnicode, propertyName, rawPropertyName, directory, fileEntry) {
  const extraFieldView = getDataView(extraFieldUnicode.data);
  extraFieldUnicode.version = getUint8(extraFieldView, 0);
  extraFieldUnicode.signature = getUint32(extraFieldView, 1);
  const crc32 = new Crc32();
  crc32.append(fileEntry[rawPropertyName]);
  const dataViewSignature = getDataView(new Uint8Array(4));
  dataViewSignature.setUint32(0, crc32.get(), true);
  extraFieldUnicode[propertyName] = await decodeText(extraFieldUnicode.data.subarray(5));
  extraFieldUnicode.valid = !fileEntry.bitFlag.languageEncodingFlag && extraFieldUnicode.signature == getUint32(dataViewSignature, 0);
  if (extraFieldUnicode.valid) {
    directory[propertyName] = extraFieldUnicode[propertyName];
    directory[propertyName + "UTF8"] = true;
  }
}
function readExtraFieldAES(extraFieldAES, directory, compressionMethod) {
  const extraFieldView = getDataView(extraFieldAES.data);
  extraFieldAES.vendorVersion = getUint8(extraFieldView, 0);
  extraFieldAES.vendorId = getUint8(extraFieldView, 2);
  const strength = getUint8(extraFieldView, 4);
  extraFieldAES.strength = strength;
  extraFieldAES.originalCompressionMethod = compressionMethod;
  directory.compressionMethod = extraFieldAES.compressionMethod = getUint16(extraFieldView, 5);
}
function readExtraFieldNTFS(extraFieldNTFS, directory) {
  const extraFieldView = getDataView(extraFieldNTFS.data);
  let offsetExtraField = 4;
  let tag1Data;
  try {
    while (offsetExtraField < extraFieldNTFS.data.length && !tag1Data) {
      const tagValue = getUint16(extraFieldView, offsetExtraField);
      const attributeSize = getUint16(extraFieldView, offsetExtraField + 2);
      if (tagValue == EXTRAFIELD_TYPE_NTFS_TAG1) {
        tag1Data = extraFieldNTFS.data.slice(offsetExtraField + 4, offsetExtraField + 4 + attributeSize);
      }
      offsetExtraField += 4 + attributeSize;
    }
  } catch (_error) {
  }
  try {
    if (tag1Data && tag1Data.length == 24) {
      const tag1View = getDataView(tag1Data);
      const rawLastModDate = tag1View.getBigUint64(0, true);
      const rawLastAccessDate = tag1View.getBigUint64(8, true);
      const rawCreationDate = tag1View.getBigUint64(16, true);
      Object.assign(extraFieldNTFS, {
        rawLastModDate,
        rawLastAccessDate,
        rawCreationDate
      });
      const lastModDate = getDateNTFS(rawLastModDate);
      const lastAccessDate = getDateNTFS(rawLastAccessDate);
      const creationDate = getDateNTFS(rawCreationDate);
      const extraFieldData = { lastModDate, lastAccessDate, creationDate };
      Object.assign(extraFieldNTFS, extraFieldData);
      Object.assign(directory, extraFieldData);
    }
  } catch (_error) {
  }
}
function readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory) {
  const extraFieldView = getDataView(extraFieldExtendedTimestamp.data);
  const flags = getUint8(extraFieldView, 0);
  const timeProperties = [];
  const timeRawProperties = [];
  if ((flags & 1) == 1) {
    timeProperties.push("lastModDate");
    timeRawProperties.push("rawLastModDate");
  }
  if ((flags & 2) == 2) {
    timeProperties.push("lastAccessDate");
    timeRawProperties.push("rawLastAccessDate");
  }
  if ((flags & 4) == 4) {
    timeProperties.push("creationDate");
    timeRawProperties.push("rawCreationDate");
  }
  let offset = 1;
  timeProperties.forEach((propertyName, indexProperty) => {
    if (extraFieldExtendedTimestamp.data.length >= offset + 4) {
      const time = getUint32(extraFieldView, offset);
      directory[propertyName] = extraFieldExtendedTimestamp[propertyName] = new Date(time * 1e3);
      const rawPropertyName = timeRawProperties[indexProperty];
      extraFieldExtendedTimestamp[rawPropertyName] = time;
    }
    offset += 4;
  });
}
async function seekSignature(reader, signature, startOffset, minimumBytes, maximumLength) {
  const signatureArray = new Uint8Array(4);
  const signatureView = getDataView(signatureArray);
  setUint32(signatureView, 0, signature);
  const maximumBytes = minimumBytes + maximumLength;
  return await seek(minimumBytes) || await seek(Math.min(maximumBytes, startOffset));
  async function seek(length) {
    const offset = startOffset - length;
    const bytes = await readUint8Array(reader, offset, length);
    for (let indexByte = bytes.length - minimumBytes; indexByte >= 0; indexByte--) {
      if (bytes[indexByte] == signatureArray[0] && bytes[indexByte + 1] == signatureArray[1] && bytes[indexByte + 2] == signatureArray[2] && bytes[indexByte + 3] == signatureArray[3]) {
        return {
          offset: offset + indexByte,
          buffer: bytes.slice(indexByte, indexByte + minimumBytes).buffer
        };
      }
    }
  }
}
function getOptionValue(zipReader, options, name) {
  return options[name] === void 0 ? zipReader.options[name] : options[name];
}
function getDate(timeRaw) {
  const date = (timeRaw & 4294901760) >> 16, time = timeRaw & 65535;
  try {
    return new Date(1980 + ((date & 65024) >> 9), ((date & 480) >> 5) - 1, date & 31, (time & 63488) >> 11, (time & 2016) >> 5, (time & 31) * 2, 0);
  } catch (_error) {
  }
}
function getDateNTFS(timeRaw) {
  return new Date(Number(timeRaw / BigInt(1e4) - BigInt(116444736e5)));
}
function getUint8(view, offset) {
  return view.getUint8(offset);
}
function getUint16(view, offset) {
  return view.getUint16(offset, true);
}
function getUint32(view, offset) {
  return view.getUint32(offset, true);
}
function getBigUint64(view, offset) {
  return Number(view.getBigUint64(offset, true));
}
function setUint32(view, offset, value) {
  view.setUint32(offset, value, true);
}
function getDataView(array) {
  return new DataView(array.buffer);
}
function readUint8Array(reader, offset, size) {
  return reader.readUint8Array(offset, size);
}
let baseURL;
try {
  baseURL = import_meta.url;
} catch (_error) {
}
configure({ baseURL });
e(configure);
configure({ Deflate: ZipDeflate, Inflate: ZipInflate });
function generateBlobURL(data, fileFormat) {
  var _a2;
  const mimeType = (_a2 = lite.getType(fileFormat)) != null ? _a2 : void 0;
  const blob = new Blob([data], { type: mimeType });
  return URL.createObjectURL(blob);
}
async function extractOsk(file) {
  const reader = new BlobReader(file);
  const extractor = new ZipReader(reader);
  const skinElements = [];
  await extractor.getEntries().then((entries) => {
    const promises = entries.map(async (entry) => {
      var _a2, _b2;
      const fileName = entry.filename;
      const fileFormat = getFileExtension(fileName);
      getFileType(fileName);
      const fileMime = (_a2 = lite.getType(fileFormat)) != null ? _a2 : void 0;
      const blobWriter = new BlobWriter();
      const data = await ((_b2 = entry.getData) == null ? void 0 : _b2.call(entry, blobWriter));
      if (!data)
        return;
      const url2 = generateBlobURL(data, fileFormat);
      skinElements.push({
        name: fileName,
        url: url2,
        mimeType: fileMime != null ? fileMime : ""
      });
    });
    return Promise.all(promises);
  });
  return skinElements;
}
async function extractOsz(file) {
  const reader = new BlobReader(file);
  const extractor = new ZipReader(reader);
  const assets = [];
  await extractor.getEntries().then((entries) => {
    const promises = entries.map(async (entry) => {
      var _a2, _b2;
      const fileName = entry.filename;
      const fileFormat = getFileExtension(fileName);
      const fileMime = (_a2 = lite.getType(fileFormat)) != null ? _a2 : void 0;
      const blobWriter = new BlobWriter();
      const data = await ((_b2 = entry.getData) == null ? void 0 : _b2.call(entry, blobWriter));
      if (!data)
        return;
      const url2 = generateBlobURL(data, fileFormat);
      assets.push({
        name: fileName,
        url: url2,
        mimeType: fileMime != null ? fileMime : ""
      });
    });
    return Promise.all(promises);
  });
  return assets;
}
async function extractOsr(file) {
  const arrayBuffer = await file.arrayBuffer();
  const replay = await Replay.FromArrayBuffer(arrayBuffer);
  return replay;
}
async function wait(time = 1e3) {
  return new Promise((resolve2) => {
    setTimeout(() => {
      resolve2();
    }, time);
  });
}
var index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  extractOsk,
  extractOsr,
  extractOsz,
  HSBToRGB,
  RGBToHSB,
  hexToInt,
  intToRGB,
  rgbToInt,
  compareNameOnly,
  getExtensionType,
  getFileExtension,
  getFileType,
  omitFileExtension,
  calculateFitRatio,
  getPlayfieldScale,
  wait
}, Symbol.toStringTag, { value: "Module" }));
class Obviewer {
  constructor(obviewerConfig) {
    this.beatmapAssets = [];
    this.skinAssets = [];
    this.replay = null;
    this.beatmap = null;
    this.isModsOverriden = false;
    this.mods = null;
    this.isPaused = true;
    this.timestamp = 0;
    this._rate = 1;
    this.lastFrameTimestamp = 0;
    this.loop = (time) => {
      if (this.isPaused)
        return;
      let deltaTime = time - this.lastFrameTimestamp;
      this.timestamp += deltaTime * this._rate;
      this.renderer.timestamp = this.timestamp;
      this.gameInstance.time = this.timestamp;
      this.lastFrameTimestamp = time;
      this._rafID = requestAnimationFrame(this.loop);
    };
    const { container } = obviewerConfig;
    this.renderer = new Renderer(container);
    this.audioHandler = new AudioHandler();
    this.gameInstance = new GameInstance(this.renderer, this.audioHandler);
    this.gameInstance._setAppRate = (rate) => {
      this.rate = rate;
    };
    this.assetsLoader = AssetsLoader.instance;
    const middleware = audioMiddleware(this.audioHandler);
    this.assetsLoader.use(middleware);
    Howler.volume(Settings.get("AudioVolume"));
  }
  get rate() {
    return this._rate;
  }
  set rate(value) {
    this._rate = value;
    this.gameInstance.rate = value;
  }
  addSkin(skinAssets) {
    this.assetsLoader.resetSkin();
    this.skinAssets = skinAssets;
  }
  addBeatmap(beatmapAssets) {
    this.beatmapAssets = beatmapAssets;
  }
  async load(filename, replay) {
    await this.loadBeatmap(filename);
    if (replay) {
      this.loadReplay(replay);
    }
  }
  async loadBeatmap(filename) {
    var _a2;
    const difficultyFile = this.beatmapAssets.find((asset) => asset.name === filename);
    if (!difficultyFile) {
      console.error(`Beatmap '${filename}' not found`);
      return;
    }
    const beatmapString = await fetch(difficultyFile.url).then((response) => response.text());
    const isPlaying = !this.isPaused;
    this.pause();
    const beatmap = new Beatmap(beatmapString, (_a2 = this.mods) != null ? _a2 : void 0);
    const beatmapDeps = getBeatmapDependencies(this.beatmapAssets, beatmap);
    const skinDeps = getSkinDependencies(this.skinAssets);
    this.assetsLoader.resetSkin();
    this.assetsLoader.resetBeatmap();
    await this.assetsLoader.loadSkin(skinDeps);
    await this.assetsLoader.loadBeatmap(beatmapDeps);
    this.beatmap = beatmap;
    this.gameInstance.loadBeatmap(beatmap);
    this.renderer.loadBeatmap(beatmap);
    if (isPlaying) {
      this.play();
    }
  }
  checkResources() {
    console.log(AssetsLoader.instance.resources);
  }
  loadReplay(replay) {
    this._replayModsNumeric = replay.mods.numeric;
    if (this.mods !== null) {
      replay.mods = this.mods;
    }
    if (this.beatmap && this.beatmap.getMods().numeric !== replay.mods.numeric) {
      this.beatmap.setMods(replay.mods);
    }
    this.replay = replay;
    this.gameInstance.loadReplay(replay);
    this.renderer.loadReplay(replay);
  }
  enableModsOverride(mods) {
    var _a2, _b2;
    this.isModsOverriden = true;
    if (mods.numeric === ((_a2 = this.mods) == null ? void 0 : _a2.numeric)) {
      return;
    }
    this.mods = mods;
    this.replay && (this.replay.mods = mods);
    const oldMods = (_b2 = this.beatmap) == null ? void 0 : _b2.getMods().numeric;
    if (this.beatmap && oldMods !== mods.numeric) {
      this.beatmap.setMods(mods);
      this.renderer.loadBeatmap(this.beatmap);
    }
  }
  disableModsOverride() {
    var _a2;
    this.mods = null;
    this.isModsOverriden = false;
    if (this._replayModsNumeric === null) {
      return;
    }
    const oldReplayMods = new Mods(this._replayModsNumeric);
    const oldMapMods = (_a2 = this.beatmap) == null ? void 0 : _a2.getMods().numeric;
    this.replay && (this.replay.mods = oldReplayMods);
    if (this.beatmap && oldMapMods !== oldReplayMods.numeric) {
      this.beatmap.setMods(oldReplayMods);
      this.renderer.loadBeatmap(this.beatmap);
    }
  }
  play() {
    if (!this.isPaused)
      return;
    this.isPaused = false;
    this.gameInstance.play();
    this.lastFrameTimestamp = performance.now();
    this.loop(this.lastFrameTimestamp);
  }
  pause() {
    this.isPaused = true;
    this.gameInstance.pause();
    if (this._rafID !== void 0) {
      cancelAnimationFrame(this._rafID);
    }
  }
  seek(timestamp) {
    this.timestamp = timestamp;
    this.renderer.timestamp = timestamp;
  }
}
export { Beatmap, Mod, Mods, Obviewer, Replay, ReplayData, ReplayNode, Settings, index as utils };
